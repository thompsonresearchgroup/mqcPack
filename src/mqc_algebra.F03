! TODO: 1) Expand ability of MQC objects to interact with Fortran intrinsic types. 
!
!>    \brief <b> MQC Algebra contains mathematical objects that are designed to
!>    simplify and automate variable use in Fortran </b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC Algebra contains mathematical objects that are designed to simplify
!>    and automate variable use in Fortran. Arrays can be packed for efficient 
!>    memory use and used for operations completely transparently to the user. 
!>    Furthermore, there is no need to type arrays, as this can be manipulated 
!>    on the fly. Arrays carry their own procedures, and use underlying lapack 
!>    routines for efficiency. The MQC derivd types defined in this package 
!>    are:
!>
!>    1. MQC_Scalar:   Rank 0 array variable
!>    2. MQC_Vector:   Rank 1 array variable
!>    3. MQC_Matrix:   Rank 2 array variable
!>    4. MQC_R4Tensor: Rank 3 array variable
!>
!>    This module is level 1 in the MQC hierarchy and so depends on level 0
!>    modules. 
!>
!>    Note that MQC_Algebra2 provides similar functionality with MQC_Array 
!>    objects that can dynamically adjust rank. However, the vast majority of 
!>    work can be performed using MQC_Algebra derived types which have been 
!>    more developed than MQC_Algebra2 derived types.
!>
!>    \endverbatim
!
      Module MQC_Algebra
!
!     ***********************************************************************
!     ***********************************************************************
!     **                                                                   **
!     **               The Merced Quantum Chemistry Package                **
!     **                            (MQCPack)                              **
!     **                                                                   **
!     ** Written By:                                                       **
!     **    Lee M. Thompson, Xianghai Sheng, Andrew D. Mahler, Dave        **
!     **    Mullally, and Hrant P. Hratchian                               **
!     **                                                                   **
!     **                          Version 25.6.3                           **
!     **                           June 18, 2025                           **
!     **                                                                   **
!     **                                                                   **
!     ** Modules beloning to MQCPack:                                      **
!     **    1. MQC_General                                                 **
!     **    2. MQC_Binary                                                  **
!     **    3. MQC_DataStructures                                          **
!     **    4. MQC_Integrals                                               **
!     **    5. MQC_Algebra                                                 **
!     **    6. MQC_Files                                                   **
!     **    7. MQC_Molecule                                                **
!     **    8. MQC_EST                                                     **
!     **    9. MQC_Gaussian                                                **
!     **                                                                   **
!     ***********************************************************************
!     ***********************************************************************
!
      Use MQC_General
      use iso_fortran_env, only: int32, int64, real64
!
!----------------------------------------------------------------
!                                                               |
!     TYPE AND CLASS DEFINITIONS                                |
!                                                               |
!----------------------------------------------------------------
!
!     Scalars...
!
!>    \brief <b> Rank 0 array variable</b>
      Type MQC_Scalar
        Real(kind=real64),Public,Allocatable::ScaR
        Integer(kind=int64),Public,Allocatable::ScaI
        Complex(Kind=real64),Public,Allocatable::ScaC
        Character(Len=64),Public::Data_Type ! Real,Integer,Complex
      Contains
!>      \brief <b> Print the MQC Scalar</b>
        Procedure, Public::print => MQC_Print_Scalar_Algebra1
!>      \brief <b> Return the value of MQC Scalar as an intrinsic real</b>
        Procedure, Public::rval => MQC_Scalar_Get_Intrinsic_Real
!>      \brief <b> Return the value of MQC Scalar as an intrinsic integer</b>
        Procedure, Public::ival => MQC_Scalar_Get_Intrinsic_Integer
!>      \brief <b> Return the value of MQC Scalar as an intrinsic complex</b>
        Procedure, Public::cval => MQC_Scalar_Get_Intrinsic_Complex
!>      \brief <b> Take the absolute value of the MQC Scalar</b>
        Procedure, Public::abs => MQC_Scalar_Get_ABS_Value
!>      \brief <b> Take the phase of the MQC Scalar</b>
        Procedure, Public::phase => MQC_Scalar_Get_Phase
!>      \brief <b> Take the square root of the MQC Scalar</b>
        Procedure, Public::sqrt => MQC_Scalar_Sqrt
!>      \brief <b> Take the exponential of the MQC Scalar</b>
        Procedure, Public::exp => MQC_Scalar_Exp
!>      \brief <b> Take the natural log of the MQC Scalar</b>
        Procedure, Public::log => MQC_Scalar_Log
!>      \brief <b> Return a random value to the MQC Scalar</b>
        Procedure, Public::random => MQC_Scalar_Get_Random_Value
      End Type MQC_Scalar
!
!     Vectors...
!
!>    \brief <b> Rank 1 array variable</b>
      Type MQC_Vector
        Integer(kind=int64),Private::Length=0
        Logical,Private::Column=.True.
        Character(Len=64),Public::Data_Type ! Real,Integer,Complex
        Real(kind=real64),Private,Dimension(:),Allocatable::VecR
        Integer(kind=int64),Private,Dimension(:),Allocatable::VecI
        Complex(Kind=real64),Private,Dimension(:),Allocatable::VecC
      Contains
!>      \brief <b> Print the MQC Vector</b>
        Procedure, Public::print => MQC_Print_Vector_Algebra1
!>      \brief <b> Returns the length of the MQC Vector</b>
        Procedure, Public::size => MQC_Length_Vector
!>      \brief <b> Initilizes the MQC Vector</b>
        Procedure, Public::init => MQC_Vector_Initialize
!>      \brief <b> Set all elements in the MQC Vector to a specified value</b>
        Procedure, Public::set => MQC_Vector_Set
!>      \brief <b> Returns the norm of the MQC Vector</b>
        Procedure, Public::norm => MQC_Vector_Norm
!>      \brief <b> Returns the transpose of the MQC Vector</b>
        Procedure, Public::transpose => MQC_Vector_Transpose
!>      \brief <b> Returns the Hermitian conjugate of the MQC Vector</b>
        Procedure, Public::dagger => MQC_Vector_Conjugate_Transpose
        Procedure, Private::at_sca => MQC_Vector_Scalar_At_Scalar
        Procedure, Private::at_int => MQC_Vector_Scalar_At_Int
!>      \brief <b> Returns the value at the specified element of the MQC Vector</b>
        Generic,   Public::at => at_sca, at_int
!>      \brief <b> Returns the subvector between specified element of the MQC Vector</b>
        Procedure, Public::vat => MQC_Vector_Vector_At
!>      \brief <b> Returns the VecI element of the MQC Vector</b>
        Procedure, Public::getArrayI => MQC_Vector_Integer_Get_Array
!>      \brief <b> Returns the VecR element of the MQC Vector</b>
        Procedure, Public::getArrayR => MQC_Vector_Real_Get_Array
!>      \brief <b> Returns the VecC element of the MQC Vector</b>
        Procedure, Public::getArrayC => MQC_Vector_Complex_Get_Array
        Procedure, Private::put_sca => MQC_Vector_Scalar_Put_Scalar
        Procedure, Private::put_int => MQC_Vector_Scalar_Put_Int
!>      \brief <b> Updates the specified element of the MQC_Vector with the specified value</b>
        Generic,   Public::put => put_sca, put_int
!>      \brief <b> Updates the specified subvector of the MQC_Vector with the specified vector</b>
        Procedure, Public::vput => MQC_Vector_Vector_Put
!>      \brief <b> Appends the specified value to the end of the MQC_Vector</b>
        Procedure, Public::push => MQC_Vector_Push
!>      \brief <b> Prepends the specified value to the beginning of the MQC_Vector</b>
        Procedure, Public::unshift => MQC_Vector_Unshift
!>      \brief <b> Removes the last element of the MQC_Vector and returns the value</b>
        Procedure, Public::pop => MQC_Vector_Pop
!>      \brief <b> Removes the first element of the MQC_Vector and returns the value</b>
        Procedure, Public::shift => MQC_Vector_Shift
!>      \brief <b> Returns the maximum value in the MQC_Vector</b>
        Procedure, Public::maxval => MQC_Vector_MaxVal
!>      \brief <b> Returns the minimum value in the MQC_Vector</b>
        Procedure, Public::minval => MQC_Vector_MinVal
!>      \brief <b> Returns the location of the maximum value in the MQC_Vector</b>
        Procedure, Public::maxloc => MQC_Vector_MaxLoc
!>      \brief <b> Returns the location of the minimum value in the MQC_Vector</b>
        Procedure, Public::minloc => MQC_Vector_MinLoc
!>      \brief <b> Returns the indices of the MQC_Vector sorted from low to high</b>
        Procedure, Public::argsort => MQC_Vector_argsort
!>      \brief <b> Returns the MQC_Vector sorted from low to high unless vector specifying
!>      index order is provided</b>
        Procedure, Public::sort => MQC_Vector_sort
!>      \brief <b> Returns the square root of each element in the MQC_Vector</b>
        Procedure, Public::sqrt => MQC_Vector_Sqrt
!>      \brief <b> Returns the exponential of the MQC Vector</b>
        Procedure, Public::exp => MQC_Vector_Exp
!>      \brief <b> Returns the absolute value of each element in the MQC_Vector</b>
        Procedure, Public::abs => MQC_Vector_Abs
!>      \brief <b> Returns the sum of elements in the MQC_Vector</b>
        Procedure, Public::sum => MQC_Vector_Sum
!>      \brief <b> Returns the product of elements in the MQC_Vector</b>
        Procedure, Public::product => MQC_Vector_Product
!>      \brief <b> Returns each element in the MQC_Vector raised to a specified power</b>
        Procedure, Public::power => MQC_Vector_Power
!>      \brief <b> Returns a diagonal MQC Matrix with values specified by the MQC_Vector (subroutine)</b>
        Procedure, Public::diag => MQC_Matrix_DiagMatrix_Put_Vector
        Procedure, Public::hphdiag => MQC_Matrix_DiagMatrix_Put_Vector
!>      \brief <b> Returns a diagonal MQC Matrix with values specified by the MQC_Vector (function)</b>
        Procedure, Public::diagf => MQC_Matrix_DiagMatrix_Put_Vector_func
      End Type MQC_Vector
!
!     Matrices...
!     Lower triangular matrix is stored in a row-major manner so that it is stored one row at a time.
!     Matrices with StorSymm flag are symmetric for both real and complex parts. StorHerm, StorASymm 
!     and StorAHerm are also available but note these are not necessarily true to the mathematical
!     definition because any diagonal elements are permitted to make these definitions more useful
!     for storage..
!     
!>    \brief <b> Rank 2 array variable</b>
      Type MQC_Matrix
        Integer(kind=int64),Private::NCol=0,NRow=0
        Character(Len=64),Private::Data_Type ! Real,Integer,Complex
        Character(Len=64),Private::Storage ! StorFull,StorSymm,StorDiag,StorAsym,StorHerm,StorAhrm
        Real(kind=real64),Private,Dimension(:,:),Allocatable::MatR
        Integer(kind=int64),Private,Dimension(:,:),Allocatable::MatI
        Complex(Kind=real64),Private,Dimension(:,:),Allocatable::MatC
      Contains
!>      \brief <b> Print the MQC Matrix</b>
        Procedure, Public::print => MQC_Print_Matrix_Algebra1
!>      \brief <b> Initialize the MQC Matrix with a specified value</b>
        Procedure, Public::init => MQC_Matrix_Initialize
!>      \brief <b> Initialize the MQC Matrix as the identity matrix</b>
        Procedure, Public::identity => MQC_Matrix_Identity
!>      \brief <b> Set all elements in the MQC Matrix to a specified value</b>
        Procedure, Public::set => MQC_Matrix_Set
!>      \brief <b> Returns the norm of the MQC Matrix</b>
        Procedure, Public::norm => MQC_Matrix_Norm
!>      \brief <b> Returns the transpose of the MQC Matrix</b>
        Procedure, Public::transpose => MQC_Matrix_Transpose
!>      \brief <b> Returns the Hemitian transpose of the MQC Matrix</b>
        Procedure, Public::dagger => MQC_Matrix_Conjugate_Transpose
!>      \brief <b> Returns the eigenvalues and eigenvalues of a symmetric or 
!>      hermitian MQC Matrix</b>
        Procedure, Public::diag => MQC_Matrix_Diagonalize
!>      \brief <b> Computes the singular value decomposition of the MQC Matrix</b>
        Procedure, Public::svd => MQC_Matrix_SVD
!>      \brief <b> Solves the generalized eigenproblem of the MQC Matrix</b>
        Procedure, Public::eigensys => mqc_matrix_generalized_eigensystem
!>      \brief <b> Returns the inverse of the MQC Matrix</b>
        Procedure, Public::inv => MQC_Matrix_Inverse
!>      \brief <b> Returns the determinant of the MQC Matrix</b>
        Procedure, Public::det => mqc_matrix_determinant
!>      \brief <b> Returns the minor of the MQC Matrix</b>
        Procedure, Public::minor => mqc_matrix_minor
!>      \brief <b> Returns the cofactor of the MQC Matrix</b>
        Procedure, Public::cofactor => mqc_matrix_cofactor
!>      \brief <b> Returns the trace of the MQC Matrix</b>
        Procedure, Public::trace => mqc_matrix_trace
!>      \brief <b> Returns a vector of diagonal elements of the MQC Matrix</b>
        Procedure, Public::pinv => mqc_matrix_MPInv
!>      \brief <b> Returns a vector of diagonal elements of the MQC Matrix</b>
        Procedure, Public::diagonal => mqc_matrix_diagonal_elements
!>      \brief <b> Returns the root mean square deviation and maximum
!>      deviation of elements of the MQC Matrix</b>
        Procedure, Public::rmsmax => MQC_Matrix_RMS_Max
!>      \brief <b> Returns the square root of the MQC Matrix</b>
        Procedure, Public::sqrt => MQC_Matrix_Sqrt
!>      \brief <b> Returns the exponential of the MQC Matrix</b>
        Procedure, Public::exp => MQC_Matrix_Exp
!>      \brief <b> Returns the sum of elements in the MQC_Matrix</b>
        Procedure, Public::sum => MQC_Matrix_Sum
        Procedure, Public::psum => MQC_Matrix_Partial_Sum
!>      \brief <b> Returns the MQC_Matrix raised to a specified power</b>
        Procedure, Public::power => MQC_Matrix_Power
        Procedure, Private::at_sca => MQC_Matrix_Scalar_At_Scalar
        Procedure, Private::at_scaint => MQC_Matrix_Scalar_At_ScaInt
        Procedure, Private::at_intsca => MQC_Matrix_Scalar_At_IntSca
        Procedure, Private::at_int => MQC_Matrix_Scalar_At_Int
!>      \brief <b> Returns the value of the specified element of the MQC Matrix</b>
        Generic,   Public::at => at_sca, at_int, at_scaint, at_intsca
!>      \brief <b> Returns the vector of the specified subvector of the MQC Matrix</b>
        Procedure, Public::vat => MQC_Matrix_Vector_At
!>      \brief <b> Returns the matrix of the specified submatrix of the MQC Matrix</b>
        Procedure, Public::mat => MQC_Matrix_Matrix_At
        Procedure, Private::put_sca => MQC_Matrix_Scalar_Put_Scalar
        Procedure, Private::put_scaint => MQC_Matrix_Scalar_Put_ScaInt
        Procedure, Private::put_intsca => MQC_Matrix_Scalar_Put_IntSca
        Procedure, Private::put_int => MQC_Matrix_Scalar_Put_Int
!>      \brief <b> Updates the specified element of the MQC Matrix to the specified
!>      value</b>
        Generic,   Public::put => put_sca, put_int, put_scaint, put_intsca
!>      \brief <b> Updates the specified subvector of the MQC Matrix to the specified
!>      vector</b>
        Procedure, Public::vput => MQC_Matrix_Vector_Put
!>      \brief <b> Updates the specified submatrix of the MQC Matrix to the specified
!>      matrix</b>
        Procedure, Public::mput => MQC_Matrix_Matrix_Put
!>      \brief <b> Increases a MQC Matrix dimension and fill the additional elements with
!>      with zeros.</b>
        Procedure, Public::mpad => MQC_Matrix_Pad
      End Type MQC_Matrix
!     
!>    \brief <b> Rank 4 array variable</b>
      Type MQC_R4Tensor
        Integer(kind=int64),Private::I=0,J=0,K=0,L=0
        Character(Len=64),Private::Data_Type ! Real,Integer,Complex
        Character(Len=64),Private::Storage ! StorFull,StorSymm
        Real(kind=real64),Allocatable,Private::RTen(:,:,:,:)
        Integer(kind=int64),Allocatable,Private::ITen(:,:,:,:)
        Complex(Kind=real64),Allocatable,Private::CTen(:,:,:,:)
      Contains
!>      \brief <b> Print the MQC R4Tensor</b>
        Procedure, Public::print => MQC_Print_r4tensor_Algebra1
        Procedure, Private::at_sca => MQC_R4Tensor_At_Scalar
        Procedure, Private::at_int => MQC_R4Tensor_At_Int
!>      \brief <b> Return the specified element in the MQC R4Tensor</b>
        Generic,   Public::at => at_sca, at_int
!>      \brief <b> Return the specified vector from MQC R4Tensor</b>
        Procedure, Public::vat => MQC_R4Tensor_Vector_At
!>      \brief <b> Return the specified vector from MQC R4Tensor</b>
        Procedure, Public::mat => MQC_R4Tensor_Matrix_At
!>      \brief <b> Return the specified rank-4 tensor from MQC R4Tensor</b>
        Procedure, Public::tat => MQC_R4Tensor_R4Tensor_At
        Procedure, Private::put_sca => MQC_R4Tensor_Put_Scalar
        Procedure, Private::put_int => MQC_R4Tensor_Put_Int
!>      \brief <b> Update the specified element in the MQC R4Tensor with the
!>      specified value</b>
        Generic, Public::put => put_sca, put_int 
!>      \brief <b> Update the specified subvector of the MQC R4Tensor to the specified
!>      vector</b>
        Procedure, Public::vput => MQC_R4Tensor_Vector_Put
!>      \brief <b> Update the specified submatrix of the MQC R4Tensor to the specified
!>      matrix</b>
        Procedure, Public::mput => MQC_R4Tensor_Matrix_Put
!>      \brief <b> Updates the specified subarray of the MQC R4Tensor to the specified
!>      rank-4 tensor</b>
        Procedure, Public::tput => MQC_R4Tensor_R4Tensor_Put
!>      \brief <b> Initialize the MQC R4Tensor</b>
        Procedure, Public::init => MQC_R4Tensor_Initialize
      End Type MQC_R4Tensor
!
!
      logical::MQC_Algebra_DEBUG=.false.

!
!
!----------------------------------------------------------------
!                                                               |
!     PROCEDURE INTERFACES                                      |
!                                                               |
!----------------------------------------------------------------
!
!
!>    \brief <b> Prints an object</b>
      Interface MQC_Print
        Module Procedure MQC_Print_Scalar_Algebra1
        Module Procedure MQC_Print_Vector_Algebra1
        Module Procedure MQC_Print_Matrix_Algebra1
        Module Procedure MQC_Print_r4tensor_Algebra1
      End Interface
!
!>    \brief <b> Outputs object as a character string</b>
      Interface num2char
        Module Procedure mqcscalar2character
      End Interface
!
!>    \brief <b> Contracts two arrays</b>
      Interface Contraction
        Module Procedure MQC_Matrix_Matrix_Contraction
        Module Procedure MQC_R4Tensor_R4Tensor_Contraction
      End Interface
!
!>    \brief <b> Returns the complex conjugate</b>
      interface conjg
        module procedure MQC_Scalar_Complex_Conjugate
        module procedure MQC_Vector_Complex_Conjugate
        module procedure MQC_Matrix_Complex_Conjugate
        module procedure MQC_R4Tensor_Complex_Conjugate
      end interface
!
!>    \brief <b> Returns the object as a floating point intrinsic</b>
      Interface float
        Module Procedure MQC_Scalar_Get_Intrinsic_Real
      End Interface
!
!>    \brief <b> Returns the object as an integer intrinsic</b>
      Interface int
        Module Procedure MQC_Scalar_Get_Intrinsic_Integer
      End Interface
!
!>    \brief <b> Determines in an array is real type</b>
      interface mqc_have_real
        module procedure mqc_scalar_havereal
        Module procedure mqc_vector_havereal
        module procedure mqc_matrix_havereal
        module procedure mqc_r4tensor_havereal
      end interface
!
!>    \brief <b> Determines in an array is integer type</b>
      interface mqc_have_int
        module procedure mqc_scalar_haveinteger
        module procedure mqc_vector_haveinteger
        module procedure mqc_matrix_haveinteger
        module procedure mqc_r4tensor_haveinteger
      end interface
!
!>    \brief <b> Determines in an array is complex type</b>
      interface mqc_have_complex
        module procedure mqc_scalar_havecomplex
        module procedure mqc_vector_havecomplex
        module procedure mqc_matrix_havecomplex
        module procedure mqc_r4tensor_havecomplex
      end interface
!
!>    \brief <b> Sets an array to integer type</b>
      interface mqc_cast_integer
        module procedure mqc_vector_cast_integer 
        module procedure mqc_matrix_cast_integer
      end interface
!
!>    \brief <b> Sets an array to real type</b>
      interface mqc_cast_real
        module procedure mqc_vector_cast_real
        module procedure mqc_matrix_cast_real
        module procedure mqc_r4tensor_cast_real
      end interface
!
!>    \brief <b> Sets an array to complex type</b>
      interface mqc_cast_complex
        module procedure mqc_vector_cast_complex
        module procedure mqc_matrix_cast_complex
      end interface
!
!>    \brief <b> Multiplies two arrays</b>
      Interface Matmul
        Module Procedure MQC_MatrixMatrixDotProduct
        Module Procedure MQC_MatrixVectorDotProduct
        Module Procedure MQC_VectorMatrixDotProduct
      End Interface
!
!>    \brief <b> Returns the transpose</b>
      Interface Transpose
        Module Procedure MQC_Vector_Transpose
        Module Procedure MQC_Matrix_Transpose
      End Interface
!
!>    \brief <b> Returns the Hermitian conjugate</b>
      Interface Dagger
        Module Procedure MQC_Vector_Conjugate_Transpose
        Module Procedure MQC_Matrix_Conjugate_Transpose
      End Interface
!      
!>    \brief <b> Defines a complex number</b>
      Interface Cmplx
        Module Procedure MQC_Scalar_Cmplx
        Module Procedure MQC_Scalar_Get_Intrinsic_Complex
        Module Procedure MQC_Vector_Cmplx
        Module Procedure MQC_Matrix_Cmplx
      End Interface
!
!>    \brief <b> Returns the maximum value in the MQC_Vector</b>
      Interface maxval
        Module Procedure MQC_Vector_MaxVal
      End Interface
!
!>    \brief <b> Returns the minimum value in the MQC_Vector</b>
      Interface minval
        Module Procedure MQC_Vector_MinVal
      End Interface
!
!>    \brief <b> Returns the location of the maximum value in the MQC_Vector</b>
      Interface maxloc
        Module Procedure MQC_Vector_MaxLoc
      End Interface
!
!>    \brief <b> Returns the location of the minimum value in the MQC_Vector</b>
      Interface minloc
        Module Procedure MQC_Vector_MinLoc
      End Interface
!
!>    \brief <b> Returns the square root</b>
      Interface Sqrt
        Module Procedure MQC_Scalar_Sqrt
        Module Procedure MQC_Vector_Sqrt_Func 
        Module Procedure MQC_Matrix_Sqrt_Func 
      End Interface
!
!>    \brief <b> Returns the exponential</b>
      Interface Exp 
        Module Procedure MQC_Scalar_Exp 
        Module Procedure MQC_Vector_Exp_Func 
        Module Procedure MQC_Matrix_Exp_Func 
      End Interface
!
!>    \brief <b> Takes the absolute value</b>
      Interface abs
        Module Procedure MQC_Scalar_Get_ABS_Value
        Module Procedure MQC_Vector_Abs_Func
      End Interface 
!
!>    \brief <b> Takes the natural log</b>
      Interface log
        Module Procedure MQC_Scalar_Log
      End Interface 
!
!>    \brief <b> Returns the real part</b>
      Interface real
        Module Procedure MQC_Scalar_Complex_RealPart
        Module Procedure MQC_Vector_Complex_RealPart
        Module Procedure MQC_Matrix_Complex_RealPart
        Module Procedure MQC_R4Tensor_Complex_RealPart
      End Interface
!
!>    \brief <b> Returns the imaginary part</b>
      Interface aimag
        Module Procedure MQC_Scalar_Complex_ImagPart
        Module Procedure MQC_Vector_Complex_ImagPart
        Module Procedure MQC_Matrix_Complex_ImagPart
        Module Procedure MQC_R4Tensor_Complex_ImagPart
      End Interface
!
!>    \brief <b> Returns the sine</b>
      Interface Sin 
        Module Procedure MQC_Scalar_Sin 
      End Interface
!
!>    \brief <b> Returns the cosine</b>
      Interface Cos 
        Module Procedure MQC_Scalar_Cos 
      End Interface
!
!>    \brief <b> Returns the tangent</b>
      Interface Tan 
        Module Procedure MQC_Scalar_Tan 
      End Interface
!
!>    \brief <b> Returns the arcsine</b>
      Interface ASin
        Module Procedure MQC_Scalar_ASin
      End Interface
!
!>    \brief <b> Returns the arccosine</b>
      Interface ACos
        Module Procedure MQC_Scalar_ACos
      End Interface
!
!>    \brief <b> Returns the arctangent</b>
      Interface ATan
        Module Procedure MQC_Scalar_ATan
      End Interface
!
!>    \brief <b> Returns the arctangent accounting for circle quadrant</b>
      Interface ATan2
        Module Procedure MQC_Scalar_ATan2
      End Interface
!
!>    \brief <b> Returns the hyperbolic sine</b>
      Interface Sinh
        Module Procedure MQC_Scalar_Sinh
      End Interface
!
!>    \brief <b> Returns the hyperbolic cosine</b>
      Interface Cosh
        Module Procedure MQC_Scalar_Cosh
      End Interface
!
!>    \brief <b> Sets an intrinsic array as an MQC Algebra object</b>
      Interface MQC_Set_Array2Vector
        Module Procedure MQC_Set_Array2Vector_Integer
        Module Procedure MQC_Set_Array2Vector_Real
        Module Procedure MQC_Set_Array2Vector_Complex
      End Interface
!
!>    \brief <b> MQC_Vector structure constructor</b>
      Interface MQC_Vector
        Module Procedure MQC_Set_Array2Vector_Integer_Func
        Module Procedure MQC_Set_Array2Vector_Real_Func
        Module Procedure MQC_Set_Array2Vector_Complex_Func
      End Interface
!
!>    \brief <b> Sets a symmetric packed intrinsic array as an MQC Matrix object</b>
      Interface MQC_Matrix_SymmMatrix_Put
        Module Procedure MQC_Matrix_SymmMatrix_Put_Integer,MQC_Matrix_SymmMatrix_Put_Real, MQC_Matrix_SymmMatrix_Put_Complex
      End Interface
!
!>    \brief <b> Sets a diagonal packed intinsic array as an MQC Matrix object</b>
      Interface MQC_Matrix_DiagMatrix_Put
        Module Procedure MQC_Matrix_DiagMatrix_Put_Integer,MQC_Matrix_DiagMatrix_Put_Real,MQC_Matrix_DiagMatrix_Put_Complex
        Module Procedure MQC_Matrix_DiagMatrix_Put_Vector
      End Interface
!
!>    \brief <b> Sets a symmetric packed intrinsic array as a square packed intrinsic array</b>
      Interface Matrix_Symm2Sq
        Module Procedure Matrix_Symm2Sq_Integer
        Module Procedure Matrix_Symm2Sq_Real
        Module Procedure Matrix_Symm2Sq_Complex
      End Interface
!
!>    \brief <b> Returns the dot product</b>
      Interface Dot_Product
        Module Procedure MQC_VectorVectorDotProduct
      End Interface
!
!>    \brief <b> Returns the sum of elements in an array</b>
      Interface Sum
        Module Procedure MQC_Vector_Sum
        Module Procedure MQC_Matrix_Sum
      End Interface
!
!>    \brief <b> Reshapes arrays</b>
      Interface Reshape
        Module Procedure MQC_Vector_Reshape_Matrix
        Module Procedure MQC_Matrix_Reshape_Vector
      End Interface
!
!>    \brief <b> Returns the array length along the specified dimension</b>
      Interface Size
        Module Procedure MQC_Length_Vector 
        Module Procedure MQC_Matrix_Size
        Module Procedure MQC_R4Tensor_Size
      End Interface
!
!>    \brief <b> Returns the absolute value of one scalar with the 
!>    sign of another</b>
      interface Sign
        module procedure MQC_Scalar_Sign
      end interface
!
!>    \brief <b> Returns whether object is allocated</b>
      interface Allocated
        module procedure MQC_Scalar_IsAllocated
        module procedure MQC_Vector_IsAllocated
        module procedure MQC_Matrix_IsAllocated
        module procedure MQC_R4Tensor_IsAllocated
      end interface
!
!>    \brief <b> Returns the value of the vector at the specied index</b>
      interface MQC_Vector_Scalar_At
        module procedure MQC_Vector_Scalar_At_Scalar
        module procedure MQC_Vector_Scalar_At_Int 
      end interface
!
!>    \brief <b> Returns the value of the matrix at the specied index</b>
      interface MQC_Matrix_Scalar_At
        module procedure MQC_Matrix_Scalar_At_Scalar
        module procedure MQC_Matrix_Scalar_At_ScaInt
        module procedure MQC_Matrix_Scalar_At_IntSca
        module procedure MQC_Matrix_Scalar_At_Int 
      end interface
!
!>    \brief <b> Returns the value of the R4tensor at the specied index</b>
      interface MQC_R4Tensor_At
        module procedure MQC_R4Tensor_At_Scalar
        module procedure MQC_R4Tensor_At_Int 
      end interface
!
!>    \brief <b> Puts a value in the vector at the specied index</b>
      interface MQC_Vector_Scalar_Put
        module procedure MQC_Vector_Scalar_Put_Scalar
        module procedure MQC_Vector_Scalar_Put_Int 
      end interface
!
!>    \brief <b> Puts a value in the matrix at the specied index</b>
      interface MQC_Matrix_Scalar_Put
        module procedure MQC_Matrix_Scalar_Put_Scalar
        module procedure MQC_Matrix_Scalar_Put_ScaInt
        module procedure MQC_Matrix_Scalar_Put_IntSca
        module procedure MQC_Matrix_Scalar_Put_Int 
      end interface
!
!>    \brief <b> Do the contraction between an R4Tensor and a Matrix</b>
      interface MQC_R4Tensor_Matrix_Contraction
        module procedure MQC_R4Tensor_Matrix_Contraction
      end interface
!
!>    \brief <b> Do a partial contraction between two R4Tensor R4Tensor</b>
      interface MQC_R4Tensor_R4Tensor_Partial_Contraction
        module procedure MQC_R4Tensor_R4Tensor_Partial_Contraction
      end interface
!
!>    \brief <b> Puts a value in the R4tensor at the specied index</b>
      interface MQC_R4Tensor_Put
        module procedure MQC_R4Tensor_Put_Scalar
        module procedure MQC_R4Tensor_Put_Int 
      end interface
!
!>    \brief <b> Puts a value in the R4tensor at the specied index</b>
      interface identity
        module procedure MQC_Matrix_Identity_Func
      end interface
!
!>    \brief <b> Puts a value in the R4tensor at the specied index</b>
      interface init
        module procedure MQC_Matrix_Initialize_Func
      end interface
!
!----------------------------------------------------------------
!                                                               |
!     OPERATOR INTERFACES                                       |
!                                                               |
!----------------------------------------------------------------
!
!
!     Define Operators.
!
!     Scalar operators...
!
!>    \brief <b> Assigns a variable to the value of another</b>
      Interface Assignment (=)
        Module Procedure MQC_Input_Integer_Scalar
        Module Procedure MQC_Input_Real_Scalar
        Module Procedure MQC_Input_Complex_Scalar
        Module Procedure MQC_Output_MQCScalar_Scalar
        Module Procedure MQC_Output_Integer_Scalar
        Module Procedure MQC_Output_Real_Scalar
        Module Procedure MQC_Output_Complex_Scalar
      End Interface
!
!>    \brief <b> Sums two variables</b>
      Interface Operator (+)
        Module Procedure MQC_ScalarAdd
        Module Procedure MQC_IntegerScalarAdd
        Module Procedure MQC_ScalarIntegerAdd
        Module Procedure MQC_RealScalarAdd
        Module Procedure MQC_ScalarRealAdd
        Module Procedure MQC_ComplexScalarAdd
        Module Procedure MQC_ScalarComplexAdd
      End Interface
!
!>    \brief <b> Subtracts two variables</b>
      Interface Operator (-)
        Module Procedure MQC_ScalarSubtract
        Module Procedure MQC_IntegerScalarSubtract
        Module Procedure MQC_ScalarIntegerSubtract
        Module Procedure MQC_RealScalarSubtract
        Module Procedure MQC_ScalarRealSubtract
        Module Procedure MQC_ComplexScalarSubtract
        Module Procedure MQC_ScalarComplexSubtract
      End Interface
!
!>    \brief <b> Multiplies two variables</b>
      Interface Operator (*)
        Module Procedure MQC_ScalarMultiply
        Module Procedure MQC_IntegerScalarMultiply
        Module Procedure MQC_ScalarIntegerMultiply
        Module Procedure MQC_RealScalarMultiply
        Module Procedure MQC_ScalarRealMultiply
        Module Procedure MQC_ComplexScalarMultiply
        Module Procedure MQC_ScalarComplexMultiply
        Module Procedure MQC_ScalarVectorProduct
        Module Procedure MQC_VectorScalarProduct
        Module Procedure MQC_ScalarMatrixProduct
        Module Procedure MQC_MatrixScalarProduct
        Module Procedure MQC_IntegerMatrixProduct
        Module Procedure MQC_MatrixIntegerProduct
        Module Procedure MQC_RealMatrixProduct
        Module Procedure MQC_MatrixRealProduct
        Module Procedure MQC_ComplexMatrixProduct
        Module Procedure MQC_MatrixComplexProduct
        Module Procedure MQC_ScalarR4TensorProduct
        Module Procedure MQC_R4TensorScalarProduct
      End Interface
!
!>    \brief <b> Divides two variables</b>
      Interface Operator (/)
        Module Procedure MQC_ScalarDivide
        Module Procedure MQC_IntegerScalarDivide
        Module Procedure MQC_ScalarIntegerDivide
        Module Procedure MQC_RealScalarDivide
        Module Procedure MQC_ScalarRealDivide
        Module Procedure MQC_ComplexScalarDivide
        Module Procedure MQC_ScalarComplexDivide
        Module Procedure MQC_VectorScalarDivide
        Module Procedure MQC_MatrixScalarDivide
        Module Procedure MQC_R4TensorScalarDivide
      End Interface
!
!>    \brief <b> Exponentials a variable to the power of another</b>
      Interface Operator (**)
        Module Procedure MQC_ScalarExponent
        Module Procedure MQC_ScalarIntegerExponent
        Module Procedure MQC_ScalarRealExponent
        Module Procedure MQC_ScalarComplexExponent
      End Interface
!
!>    \brief <b> Determines if two variables are not equal</b>
      Interface Operator (.ne.)
        Module Procedure MQC_ScalarNE
        Module Procedure MQC_ScalarNEInteger
        Module Procedure MQC_IntegerNEScalar
        Module Procedure MQC_ScalarNEReal
        Module Procedure MQC_RealNEScalar
        Module Procedure MQC_ScalarNEComplex
        Module Procedure MQC_ComplexNEScalar
      End Interface
!
!>    \brief <b> Determines if two variables are equal</b>
      Interface Operator (.eq.)
        Module Procedure MQC_ScalarEQ
        Module Procedure MQC_ScalarEQInteger
        Module Procedure MQC_IntegerEQScalar
        Module Procedure MQC_ScalarEQReal
        Module Procedure MQC_RealEQScalar
        Module Procedure MQC_ScalarEQComplex
        Module Procedure MQC_ComplexEQScalar
      End Interface
!
!>    \brief <b> Determines if a variable is less than another</b>
      Interface Operator (.lt.)
        Module Procedure MQC_ScalarLT
        Module Procedure MQC_ScalarLTInteger
        Module Procedure MQC_IntegerLTScalar
        Module Procedure MQC_ScalarLTReal
        Module Procedure MQC_RealLTScalar
      End Interface
!
!>    \brief <b> Determines if a variable is greater than another</b>
      Interface Operator (.gt.)
        Module Procedure MQC_ScalarGT
        Module Procedure MQC_ScalarGTInteger
        Module Procedure MQC_IntegerGTScalar
        Module Procedure MQC_ScalarGTReal
        Module Procedure MQC_RealGTScalar
      End Interface
!
!>    \brief <b> Determines if a variable is less than or equal to another</b>
      Interface Operator (.le.)
        Module Procedure MQC_ScalarLE
        Module Procedure MQC_ScalarLEReal
        Module Procedure MQC_RealLEScalar
        Module Procedure MQC_ScalarLEInteger
        Module Procedure MQC_IntegerLEScalar
      End Interface
!
!>    \brief <b> Determines if a variable is greater than or equal to another</b>
      Interface Operator (.ge.)
        Module Procedure MQC_ScalarGE
        Module Procedure MQC_ScalarGEReal
        Module Procedure MQC_RealGEScalar
        Module Procedure MQC_ScalarGEInteger
        Module Procedure MQC_IntegerGEScalar
      End Interface
!
!     Vector operators...
!
!     Documentation in scalar operator section
      Interface Assignment (=)
        Module Procedure MQC_Set_Vector2Vector
        Module Procedure MQC_Set_Vector2IntegerArray, MQC_Set_Vector2RealArray, MQC_Set_Vector2ComplexArray
        Module Procedure MQC_Set_Array2Vector_Integer, MQC_Set_Array2Vector_Real, MQC_Set_Array2Vector_Complex 
      End Interface
!
!>    \brief <b> Computes the inner product of two arrays</b>
      Interface Operator (.dot.)
        Module Procedure MQC_VectorVectorDotProduct
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (*)
        Module Procedure MQC_RealVectorProduct
        Module Procedure MQC_VectorRealProduct
        Module Procedure MQC_IntegerVectorProduct
        Module Procedure MQC_VectorIntegerProduct
        Module Procedure MQC_ComplexVectorProduct
        Module Procedure MQC_VectorComplexProduct
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (**)
        Module Procedure MQC_Vector_Power_func 
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (/)
        Module Procedure MQC_VectorRealDivide
        Module Procedure MQC_VectorIntegerDivide
        Module Procedure MQC_VectorComplexDivide
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (+)
        Module Procedure MQC_VectorVectorSum
        Module Procedure MQC_ScalarVectorSum
        Module Procedure MQC_VectorScalarSum
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (-)
        Module Procedure MQC_VectorVectorDifference
        Module Procedure MQC_ScalarVectorDifference
      End Interface
!
!>    \brief <b> Computes the element-wise product of two arrays</b>
      Interface Operator (.ewp.)
        Module Procedure MQC_ElementVectorProduct
        Module Procedure MQC_ElementMatrixProduct
      End Interface
!
!>    \brief <b> Computes the element-wise quotient of two arrays</b>
      Interface Operator (.ewd.)
        Module Procedure MQC_ElementMatrixDivide
      End Interface
!
!>    \brief <b> Computes the cross product of two vectors</b>
      Interface Operator (.x.)
        Module Procedure MQC_CrossProduct
      End Interface
!
!>    \brief <b> Computes the outer product of two vectors</b>
      Interface Operator (.outer.)
        Module Procedure MQC_Outer
      End Interface
!
!     Matrix operators...
!
!     Documentation in scalar operator section
      Interface Assignment (=)
        Module Procedure MQC_Set_Matrix2Matrix
        Module Procedure MQC_Set_Matrix2IntegerArray
        Module Procedure MQC_Set_Matrix2RealArray
        Module Procedure MQC_Set_Matrix2ComplexArray
        Module Procedure MQC_Set_IntegerArray2Matrix
        Module Procedure MQC_Set_RealArray2Matrix
        Module Procedure MQC_Set_ComplexArray2Matrix
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (+)
        Module Procedure MQC_MatrixMatrixSum
      End Interface
!     Pgfortran does not currently support declare reduction
!      !$OMP DECLARE REDUCTION(+: mqc_matrix: omp_out = omp_out + omp_in) initializer(omp_priv = omp_orig)
!
!     Documentation in scalar operator section
      Interface Operator (-)
        Module Procedure MQC_MatrixMatrixSubtract
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (*)
!        Module Procedure MQC_MatrixMatrixProduct
        Module Procedure MQC_ElementMatrixProduct
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (**)
        Module Procedure MQC_ElementMatrixPower
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (.dot.)
        Module Procedure MQC_VectorMatrixDotProduct
        Module Procedure MQC_MatrixVectorDotProduct
        Module Procedure MQC_MatrixMatrixDotProduct
      End Interface
!
      Interface Operator (.outer.)
        Module Procedure MQC_Matrix_Matrix_Outer
      End Interface
!
      Interface Operator (.crossouter.)
        Module Procedure MQC_Matrix_Matrix_Cross_Outer
      End Interface
!
!     Rank 4 tensor operators...
!
!     Documentation in scalar operator section
      Interface Assignment (=)
        Module Procedure MQC_Set_IntegerArray2tensor
        Module Procedure MQC_Set_RealArray2tensor
        Module Procedure MQC_Set_ComplexArray2tensor
        Module Procedure MQC_Set_Tensor2IntegerArray
        Module Procedure MQC_Set_Tensor2RealArray
        Module Procedure MQC_Set_Tensor2ComplexArray
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (+)
        Module Procedure MQC_R4Tensor_R4Tensor_Sum
      End Interface
!
!     Documentation in scalar operator section
      Interface Operator (-)
        Module Procedure MQC_R4Tensor_R4Tensor_Difference
      End Interface
!
!>    \brief <b> Determines if two variables are equal</b>
      Interface Operator (.eq.)
        Module Procedure MQC_ScalarEQVector
        Module Procedure MQC_VectorEQScalar
        Module Procedure MQC_IntegerEQVector
        Module Procedure MQC_VectorEQInteger
      End Interface
!
!>    \brief <b> Determines if vector elements are greater or equal</b>
      Interface Operator (.ge.)
        Module Procedure MQC_ScalarGEVector
        Module Procedure MQC_VectorGEScalar
        Module Procedure MQC_IntegerGEVector
        Module Procedure MQC_VectorGEInteger
      End Interface
!
!>    \brief <b> Determines if vector elements are less than or equal</b>
      Interface Operator (.le.)
        Module Procedure MQC_ScalarLEVector
        Module Procedure MQC_VectorLEScalar
        Module Procedure MQC_IntegerLEVector
        Module Procedure MQC_VectorLEInteger
      End Interface
!
!
!----------------------------------------------------------------
!                                                               |
!     SUBROUTINES AND FUNCTIONS                                 |
!                                                               |
!----------------------------------------------------------------
!
!
      CONTAINS
!
!
!     PROCEDURE MQC_Algebra_SetDEBUG
!
      subroutine MQC_Algebra_SetDEBUG(setDebugValue)
!
!     This subroutine is called to set a Module-Wide DEBUG flag to .TRUE. or
!     .FALSE.
!
!     H. P. Hratchian, 2023.
!
!
      implicit none
      logical,intent(IN)::setDebugValue
!
      MQC_Algebra_DEBUG = setDebugValue
!
      return
      end subroutine MQC_Algebra_SetDEBUG
!
!
!     PROCEDURE Factorial
!
!>    \brief <b> Factorial returns the factorial of an integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    Factorial is a function that returns the factorial of an integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] N
!>    \verbatim
!>        N is Integer(kind=int64)
!>        The argument of the factorial function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      function factorial(n)
!
!     Variable Declarations...
      Implicit None
      Integer(kind=int64),Intent(In)::N
      Integer(kind=int64)::I,Ans,Factorial
!
      ans = 1
      Do I = 1, N
        Ans = Ans * I
      EndDo
!
      Factorial = Ans
!
      End Function Factorial
!
!
!     PROCEDURE Bin_Coeff
!
!>    \brief <b> Bin_Coeff returns the binomial coefficient of (n,k)</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    Bin_Coeff is a function that returns the binomial coefficient given input
!>    integer N and input integer K corresponding to N choose K.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] NIn
!>    \verbatim
!>        N is Class(*)
!>        The number of objects.
!>    \endverbatim
!>
!>    \param[in] KIn
!>    \verbatim
!>        K is Class(*)
!>        The number of permutations.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function Bin_Coeff(NIn,KIn)
!
!     Variable Declarations...
      Implicit None
      Class(*),Intent(In)::NIn,KIn
      Integer(kind=int64)::I,J,N,K,Ans,Bin_Coeff
!
      Select Type (NIn)
      Type is (integer)
        N = NIn
      type is (mqc_scalar)
        N = NIn
      Class Default
        Call MQC_Error('NIn type is not integer or MQC scalar')
      End Select

      Select Type (KIn)
      Type is (integer)
        K = KIn
      type is (mqc_scalar)
        K = KIn
      Class Default
        Call MQC_Error('KIn type is not integer or MQC scalar')
      End Select

      If(K.lt.0.or.K.gt.N) then
        Ans = 0
      ElseIf(K.eq.0.or.K.eq.N) then
        Ans = 1
      Else
        J = Min(K, N-K)
        Ans = 1
        Do I = 0, J-1
          Ans = Ans * (N - I) / (I + 1)
        EndDo
      EndIf
!
      Bin_Coeff = Ans
!
      End Function Bin_Coeff
!
!----------------------------------------------------------------
!                                                               |
!     SCALAR PROCEDURES                                         |
!                                                               |
!----------------------------------------------------------------
!
!     PROCEDURE MQC_Allocate_Scalar
!
!>    \brief <b> MQC_Allocate_Scalar is used to allocate a scalar type variable
!>    of the MQC_Scalar class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Allocate_Scalar is a subroutine used to allocate a scalar type variable
!>    of the MQC_Scalar class. The following options are available:
!>
!>    1. Data_Type = 'Real' declares the MQC_Scalar variable to be of real type. 
!>    2. Data_Type = 'Integer' declares the MQC_Scalar variable to be of integer type.
!>    3. Data_Type = 'Complex' declares the MQC_Scalar variable to be of complex type.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The name of the MQC_Scalar variable.
!>    \endverbatim
!>
!>    \param[in] Data_Type
!>    \verbatim
!>        Data_Type is Character(Len=*)
!>        = 'Real':    the MQC_Scalar is real
!>        = 'Integer': the MQC_Scalar is integer
!>        = 'Complex': the MQC_Scalar is complex.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Allocate_Scalar(Scalar,Data_type)
!
!     Variable Declarations.
      Implicit None
      Character(Len=*),Intent(In)::Data_Type
      Type(MQC_Scalar),Intent(InOut)::Scalar
!
      Call MQC_Deallocate_Scalar(Scalar)
      If(Data_Type.eq.'Real' .or. Data_Type.eq.'real') then
        Scalar%Data_type = 'Real'
        Allocate(Scalar%ScaR)
      ElseIf(Data_Type.eq.'Integer' .or. Data_Type.eq.'integer' .or. Data_Type.eq.'Int' .or. Data_Type.eq.'int') then
        Scalar%Data_type = 'Integer'
        Allocate(Scalar%ScaI)
      ElseIf(Data_Type.eq.'Complex' .or. Data_Type.eq.'complex') then
        Scalar%Data_type = 'Complex'
        Allocate(Scalar%ScaC)
      Else
        Call MQC_Error_A('ScalarIn type unspecified in MQC_Allocate_Scalar', 6, &
             'Data_Type', Data_Type )
      EndIf
!
      Return
      End Subroutine MQC_Allocate_Scalar
!
!
!     PROCEDURE MQC_Deallocate_Scalar
!
!>    \brief <b> MQC_Deallocate_Scalar is used to deallocate a scalar type variable
!>    of the MQC_Scalar class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Deallocate_Scalar is a subroutine used to deallocate a scalar type variable
!>    of the MQC_Scalar class. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The name of the MQC_Scalar variable to deallocate.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Deallocate_Scalar(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(InOut)::Scalar
!
      If(Allocated(Scalar%ScaI)) Deallocate(Scalar%ScaI)
      If(Allocated(Scalar%ScaR)) Deallocate(Scalar%ScaR)
      If(Allocated(Scalar%ScaC)) Deallocate(Scalar%ScaC)
      If(.not.Allocated(Scalar%ScaR).and..not.Allocated(Scalar%ScaI).and..not.Allocated(Scalar%ScaC)) then
        Scalar%Data_Type = ''
      EndIf
!
      Return
      End Subroutine MQC_Deallocate_Scalar
!
!
!     PROCEDURE MQC_Scalar_IsAllocated
!
!>    \brief <b> MQC_Scalar_IsAllocated is used to determine the allocation status
!>    of an MQC_Scalar</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Scalar_IsAllocated is a subroutine used to determine the allocation status
!>    of an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The name of the MQC_Scalar variable to check allocation status.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Scalar_IsAllocated(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(InOut)::Scalar
      Logical::MQC_Scalar_IsAllocated
!
      MQC_Scalar_IsAllocated = .False.
      If(Allocated(Scalar%ScaI)) MQC_Scalar_IsAllocated = .True.
      If(Allocated(Scalar%ScaR)) MQC_Scalar_IsAllocated = .True.
      If(Allocated(Scalar%ScaC)) MQC_Scalar_IsAllocated = .True.
!
      Return
      End Function MQC_Scalar_IsAllocated
!
!
!     PROCEDURE MQC_Input_Integer_Scalar
!
!>    \brief <b> MQC_Input_Integer_Scalar is a subroutine is used to set an intrinsic integer to
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Input_Integer_Scalar is a subroutine is used to set an intrinsic integer to an MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ScalarOut
!>    \verbatim
!>        ScalarOut is Type(MQC_Scalar)
!>        The name of the output variable.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Integer(kind=int64) 
!>        The value of the input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Input_Integer_Scalar(ScalarOut,ScalarIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(InOut)::ScalarOut
      Integer(kind=int64),Intent(In)::ScalarIn
!
      Call MQC_Allocate_Scalar(ScalarOut,'Integer')
      ScalarOut%scai = ScalarIn
!
      Return
      End Subroutine MQC_Input_Integer_Scalar
!
!
!     PROCEDURE MQC_Input_Real_Scalar
!
!>    \brief <b> MQC_Input_Real_Scalar is a subroutine is used to set an intrinsic real to
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Input_Integer_Scalar is a subroutine is used to set an intrinsic real to an MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ScalarOut
!>    \verbatim
!>        ScalarOut is Type(MQC_Scalar)
!>        The name of the output variable.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Real(kind=real64) 
!>        The value of the input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Input_Real_Scalar(ScalarOut,ScalarIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(InOut)::ScalarOut
      Real(kind=real64),Intent(In)::ScalarIn
!
      Call MQC_Allocate_Scalar(ScalarOut,'Real')
      ScalarOut%scar = ScalarIn
!
      Return
      End Subroutine MQC_Input_Real_Scalar
!
!
!     PROCEDURE MQC_Input_Complex_Scalar
!
!>    \brief <b> MQC_Input_Complex_Scalar is a subroutine is used to set an intrinsic complex to
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Input_Complex_Scalar is a subroutine is used to set an intrinsic complex to an MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ScalarOut
!>    \verbatim
!>        ScalarOut is Type(MQC_Scalar)
!>        The name of the output variable.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Complex(kind=real64) 
!>        The value of the input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Input_Complex_Scalar(ScalarOut,ScalarIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(InOut)::ScalarOut
      Complex(Kind=real64),Intent(In)::ScalarIn
!
      Call MQC_Allocate_Scalar(ScalarOut,'Complex')
      ScalarOut%scac = ScalarIn
!
      Return
      End Subroutine MQC_Input_Complex_Scalar
!
!
!     PROCEDURE MQC_Output_MQCScalar_Scalar
!
!>    \brief <b> MQC_Output MQCScalar_Scalar is a subroutine used to output an MQC_scalar equal to 
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Output_MQCScalar_Scalar is a subroutine used to output an MQC_scalar equal to an MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ScalarOut
!>    \verbatim
!>        ScalarOut is Type(MQC_Scalar)
!>        The name of the output variable.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar) 
!>        The value of the input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Output_MQCScalar_Scalar(ScalarOut,ScalarIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(InOut)::ScalarOut
      Type(MQC_Scalar),Intent(In)::ScalarIn
!
      Call MQC_Deallocate_Scalar(ScalarOut)
      If(ScalarIn%Data_type.eq.'Integer') then
        Allocate(ScalarOut%ScaI)
        ScalarOut%ScaI = ScalarIn%ScaI
        ScalarOut%Data_type = 'Integer'
      ElseIf(ScalarIn%Data_type.eq.'Real') then
        Allocate(ScalarOut%ScaR)
        ScalarOut%ScaR = ScalarIn%ScaR
        ScalarOut%Data_type = 'Real'
      ElseIf(ScalarIn%Data_type.eq.'Complex') then
        Allocate(ScalarOut%ScaC)
        ScalarOut%ScaC = ScalarIn%ScaC
        ScalarOut%Data_type = 'Complex'
      Else
        Call MQC_Error_A('ScalarIn type not assigned in MQC_Scalar2Scalar', 6, &
             'ScalarIn%Data_type', ScalarIn%Data_type )
      EndIf
!
      Return
      End Subroutine MQC_Output_MQCScalar_Scalar
!
!
!     PROCEDURE MQC_Output_Integer_Scalar
!
!>    \brief <b> MQC_Output_Integer_Scalar is a subroutine used to output an intrinsic integer equal to 
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Output_Integer_Scalar is a subroutine used to output an intrinsic integer equal to an MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ScalarOut
!>    \verbatim
!>        ScalarOut is Integer(kind=int64) 
!>        The name of the output variable.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar) 
!>        The value of the input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Output_Integer_Scalar(ScalarOut,ScalarIn)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(InOut)::ScalarOut
      Type(MQC_Scalar),Intent(In)::ScalarIn
!
      If(ScalarIn%Data_type.eq.'Integer') then
        ScalarOut = ScalarIn%scai
      ElseIf(ScalarIn%Data_type.eq.'Real') then
        ScalarOut = Int(ScalarIn%scar)
      ElseIf(ScalarIn%Data_type.eq.'Complex') then
        ScalarOut = Int(ScalarIn%scac)
      Else
        Call MQC_Error_A('ScalarIn type unspecified in MQC_Output_Scalar', 6, &
             'ScalarIn%Data_type', ScalarIn%Data_type )
      EndIf
!
      Return
      End Subroutine MQC_Output_Integer_Scalar
!
!
!     PROCEDURE MQC_Output_Real_Scalar
!
!>    \brief <b> MQC_Output_Real_Scalar is a subroutine used to output an intrinsic real equal to 
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Output_Complex_Scalar is a subroutine used to output an intrinsic real equal to an MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ScalarOut
!>    \verbatim
!>        ScalarOut is Real(kind=real64) 
!>        The name of the output variable.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar) 
!>        The value of the input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Output_Real_Scalar(ScalarOut,ScalarIn)
!
!     Variable Declarations.
      Implicit None
      Real(kind=real64),Intent(InOut)::ScalarOut
      Type(MQC_Scalar),Intent(In)::ScalarIn
!
      If(ScalarIn%Data_type.eq.'Real') then
        ScalarOut = ScalarIn%scar
      ElseIf(ScalarIn%Data_type.eq.'Integer') then
        ScalarOut = Dble(ScalarIn%scai)
      ElseIf(ScalarIn%Data_type.eq.'Complex') then
        ScalarOut = Real(ScalarIn%scac)
      Else
        Call MQC_Error_A('ScalarIn type unspecified in MQC_Output_Scalar', 6, &
             'ScalarIn%Data_type', ScalarIn%Data_type )
      EndIf
!
      Return
      End Subroutine MQC_Output_Real_Scalar
!
!
!     PROCEDURE MQC_Output_Complex_Scalar
!
!>    \brief <b> MQC_Output_Complex_Scalar is a subroutine used to output an intrinsic complex equal to 
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Output_Complex_Scalar is a subroutine used to output an intrinsic complex equal to an MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ScalarOut
!>    \verbatim
!>        ScalarOut is Complex(kind=real64) 
!>        The name of the output variable.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar) 
!>        The value of the input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Output_Complex_Scalar(ScalarOut,ScalarIn)
!
!     Variable Declarations.
      Implicit None
      Complex(Kind=real64),Intent(InOut)::ScalarOut
      Type(MQC_Scalar),Intent(In)::ScalarIn
!
      If(ScalarIn%Data_type.eq.'Real') then
        ScalarOut = cmplx(ScalarIn%scar,0.0)
      ElseIf(ScalarIn%Data_type.eq.'Integer') then
        ScalarOut = cmplx(ScalarIn%scai,0)
      ElseIf(ScalarIn%Data_type.eq.'Complex') then
        ScalarOut = ScalarIn%scac
      Else
        Call MQC_Error_A('ScalarIn type unspecified in MQC_Output_Scalar', 6, &
             'ScalarIn%Data_type', ScalarIn%Data_type )
      EndIf
!
      Return
      End Subroutine MQC_Output_Complex_Scalar
!
!
!     PROCEDURE MQC_Print_Scalar_Algebra1
!
!>    \brief <b> MQC_Print_Scalar_Algebra1 is a subroutine used to print
!>    an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Print_Scalar_Algebra1 is a subroutine used to print an MQC_Scalar. Blank_At_Top
!>    and Blank_At_Bottom are optional logical arguments to print blank lines before or
!>    after output.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The variable to be printed.
!>    \endverbatim
!>
!>    \param[in] IOut
!>    \verbatim
!>        IOut is Integer(kind=int64) 
!>        The Fortran file number to print to. 
!>    \endverbatim
!>
!>    \param[in] Header
!>    \verbatim
!>        Header is Character(Len=*)
!>        The title to print along with Scalar.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Top
!>    \verbatim
!>        Blank_At_Top is Logical,Optional
!>        = .True.:  print blank line above output
!>        = .False.: do not print blank line above output.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Bottom
!>    \verbatim
!>        Blank_At_Bottom is Logical,Optional
!>        = .True.:  print blank line below output
!>        = .False.: do not print blank line below output.
!>    \endverbatim
!>
!>    \param[in] FormatStr
!>    \verbatim
!>        FormatStr is Character(Len=*),Optional
!>        Formatting statement for printing.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Print_Scalar_Algebra1(Scalar,IOut,Header,Blank_At_Top, &
        Blank_At_Bottom,FormatStr)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::IOut
      Class(MQC_Scalar),Intent(In)::Scalar
      Character(Len=*),Intent(In)::Header
      Logical,Intent(In),Optional::Blank_At_Top,Blank_At_Bottom
      Character(Len=*),Intent(In),Optional::FormatStr
      Character(Len=256)::FormatLine
!
 1001 Format(1x,A,1x,'=',1x,I14)
 1002 Format(1x,A,1x,'=',1x,F14.6)
 1003 Format(1x,A,1x,'=',1x,F14.6,SP,F14.6,"i")
 1020 Format( " " )
!
      If(PRESENT(Blank_At_Top)) then
        If(Blank_At_Top) Write(IOut,1020)
      EndIf

      If(Scalar%Data_type.eq.'Integer') then
        If(present(FormatStr)) then
          FormatLine = '(1x,A,1x,"=",1x,'//trim(FormatStr)//')'
          Write(IOut,trim(FormatLine)) TRIM(Header), Scalar%ScaI
        else
          Write(IOut,1001) TRIM(Header), Scalar%ScaI
        endIf
      ElseIf(Scalar%Data_type.eq.'Real') then
        If(present(FormatStr)) then
          FormatLine = '(1x,A,1x,"=",1x,'//trim(FormatStr)//')'
          Write(IOut,trim(FormatLine)) TRIM(Header), Scalar%ScaR
        else
          Write(IOut,1002) TRIM(Header), Scalar%ScaR
        endIf
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(present(FormatStr)) then
          FormatLine = '(1x,A,1x,"=",1x,'//trim(FormatStr)//',SP,'//trim(FormatStr)//',"i")'
          Write(IOut,trim(FormatLine)) TRIM(Header), Scalar%ScaC
        else
          Write(IOut,1003) TRIM(Header), Scalar%ScaC
        endIf
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Print_Scalar_Algebra1', 6, &
             'Scalar%Data_type', Scalar%Data_type )
      EndIf

      If(PRESENT(Blank_At_Bottom)) then
        If(Blank_At_Bottom) Write(IOut,1020)
      EndIf
!
      Return
      End Subroutine MQC_Print_Scalar_Algebra1
!
!
!     PROCEDURE MQC_Scalar_Cmplx
!
!>    \brief <b> MQC_Scalar_Cmplx is a function used to set a complex MQC_Scalar type
!>    variable from two other MQC_scalars</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Cmplx is a function used to set a complex MQC_Scalar type variable 
!>    from two other MQC_Scalar variables.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The real part of MQC_Scalar_Cmplx.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The imaginary part of MQC_Scalar_Cmplx.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_Cmplx(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Cmplx
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
      If(Scalar1%Data_type.eq.'Real') then
        If(Scalar2%Data_type.eq.'Real') then
          MQC_Scalar_Cmplx = Cmplx(Scalar1%ScaR,Scalar2%ScaR)
        ElseIf(Scalar2%Data_type.eq.'Integer') then
#ifdef PGI
          MQC_Scalar_Cmplx = Cmplx(Scalar1%ScaR,dFloat(Scalar2%ScaI))
#else
          MQC_Scalar_Cmplx = Cmplx(Scalar1%ScaR,Float(Scalar2%ScaI))
#endif
        ElseIf(Scalar2%Data_Type.eq.'Complex') then
          Call MQC_Error_A('Complex MQC Scalar type cannot be set as real/imaginary part in MQC_Scalar_Cmplx', 6, &
             'Scalar1%Data_Type', Scalar1%Data_Type, 'Scalar2%Data_Type', Scalar2%Data_Type)
        Else
          Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Cmplx', 6, &
             'Scalar1%Data_Type', Scalar1%Data_Type, 'Scalar2%Data_Type', Scalar2%Data_Type)
        EndIf
      ElseIf(Scalar1%Data_Type.eq.'Integer') then
        If(Scalar2%Data_type.eq.'Real') then
#ifdef PGI
          MQC_Scalar_Cmplx = Cmplx(dFloat(Scalar1%ScaI),Scalar2%ScaR)
#else
          MQC_Scalar_Cmplx = Cmplx(Float(Scalar1%ScaI),Scalar2%ScaR)
#endif
        ElseIf(Scalar2%Data_type.eq.'Integer') then
#ifdef PGI
          MQC_Scalar_Cmplx = Cmplx(dFloat(Scalar1%ScaI),dFloat(Scalar2%ScaI))
#else
          MQC_Scalar_Cmplx = Cmplx(Float(Scalar1%ScaI),Float(Scalar2%ScaI))
#endif
        ElseIf(Scalar2%Data_Type.eq.'Complex') then
          Call MQC_Error_A('Complex MQC Scalar type cannot be set as real/imaginary part in MQC_Scalar_Cmplx', 6, &
             'Scalar1%Data_Type', Scalar1%Data_Type, 'Scalar2%Data_Type', Scalar2%Data_Type)
        Else
          Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Cmplx', 6, &
             'Scalar1%Data_Type', Scalar1%Data_Type, 'Scalar2%Data_Type', Scalar2%Data_Type)
        EndIf
      ElseIf(Scalar1%Data_Type.eq.'Complex'.or.Scalar2%Data_Type.eq.'Complex') then
        Call MQC_Error_A('Complex MQC Scalar type cannot be set as real/imaginary part in MQC_Scalar_Cmplx', 6, &
             'Scalar1%Data_Type', Scalar1%Data_Type, 'Scalar2%Data_Type', Scalar2%Data_Type)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Cmplx', 6, &
             'Scalar1%Data_Type', Scalar1%Data_Type, 'Scalar2%Data_Type', Scalar2%Data_Type)
      EndIf
!
      Return
      End Function MQC_Scalar_Cmplx
!
!
!     PROCEDURE MQC_Scalar_Sqrt
!
!>    \brief <b> MQC_Scalar_Sqrt is a function used to return the square root of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Sqrt is a function used to return the square root of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Scalar_Sqrt(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Sqrt
      Class(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_Sqrt = Sqrt(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_Sqrt = Sqrt(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_Sqrt = Sqrt(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_Sqrt = Sqrt(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Sqrt', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Sqrt
!
!
!     PROCEDURE MQC_Scalar_Exp 
!
!>    \brief <b> MQC_Scalar_Exp is a function used to return the exponential of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Exp is a function used to return the exponential of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_Scalar_Exp(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Exp
      Class(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_Exp = Exp(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_Exp = Exp(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_Exp = Exp(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_Exp = Exp(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Exp', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Exp
!
!
!     PROCEDURE MQC_Scalar_Sin
!
!>    \brief <b> MQC_Scalar_Sin is a function used to return the sine of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Sin is a function used to return the sine of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_Sin(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Sin
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_Sin = Sin(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_Sin = Sin(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_Sin = Sin(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_Sin = Sin(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Sin', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Sin
!
!
!     PROCEDURE MQC_Scalar_Cos
!
!>    \brief <b> MQC_Scalar_Cos is a function used to return the cosine of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Cos is a function used to return the cosine of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_Cos(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Cos
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_Cos = Cos(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_Cos = Cos(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_Cos = Cos(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_Cos = Cos(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Cos', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Cos
!
!
!     PROCEDURE MQC_Scalar_Tan
!
!>    \brief <b> MQC_Scalar_Tan is a function used to return the tangent of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Tan is a function used to return the tangent of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_Tan(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Tan
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_Tan = Tan(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_Tan = Tan(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_Tan = Tan(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_Tan = Tan(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Tan', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Tan
!
!
!     PROCEDURE MQC_Scalar_ASin
!
!>    \brief <b> MQC_Scalar_ASin is a function used to return the arcsin of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_ASin is a function used to return the arcsin of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_ASin(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_ASin
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_ASin = ASin(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_ASin = ASin(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_ASin = ASin(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_ASin = ASin(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_ASin', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_ASin
!
!
!     PROCEDURE MQC_Scalar_ACos
!
!>    \brief <b> MQC_Scalar_ACos is a function used to return the arccosine of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_ACos is a function used to return the arccosine of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_ACos(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_ACos
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_ACos = ACos(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_ACos = ACos(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_ACos = ACos(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_ACos = ACos(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_ACos', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_ACos
!
!
!     PROCEDURE MQC_Scalar_ATan
!
!>    \brief <b> MQC_Scalar_ATan is a function used to return the arctangent of 
!>    an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_ATan is a function used to return the arctangent of an MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_ATan(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_ATan
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_ATan = ATan(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_ATan = ATan(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_ATan = ATan(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_ATan = ATan(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_ATan', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_ATan
!
!
!     PROCEDURE MQC_Scalar_ATan2
!
!>    \brief <b> MQC_Scalar_ATan2 is a function used to return the arctangent of 
!>    an MQC_scalar accounting for quadrant of Argand diagram</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_ATan2 is a function used to return the arctangent of an MQC_scalar
!>    accounting for quadrant of Argand diagram.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_ATan2(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_ATan2
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_ATan2 = ATan2(0.0,Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_ATan2 = ATan2(0.0,dFloat(Scalar%ScaI))
#else
        MQC_Scalar_ATan2 = ATan2(0.0,Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_ATan2 = ATan2(aimag(Scalar%ScaC),real(Scalar%ScaC))
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_ATan2', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_ATan2
!
!
!     PROCEDURE MQC_Scalar_Sinh
!
!>    \brief <b> MQC_Scalar_Sinh is a function used to return the hyperbolic 
!>    sine of an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Sinh is a function used to return the hyperbolic sine of an 
!>    MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2023
!
      Function MQC_Scalar_Sinh(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Sinh
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_Sinh = Sinh(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_Sinh = Sinh(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_Sinh = Sinh(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_Sinh = Sinh(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Sinh', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Sinh
!
!
!     PROCEDURE MQC_Scalar_Cosh
!
!>    \brief <b> MQC_Scalar_Cosh is a function used to return the hyperbolic
!>    cosine of an MQC_scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Cosh is a function used to return the hyperbolic sine of an 
!>    MQC_scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The argument of the function.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2023
!
      Function MQC_Scalar_Cosh(Scalar)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_Scalar_Cosh
      Type(MQC_Scalar),Intent(In)::Scalar
!
      If(Scalar%Data_type.eq.'Real') then
        MQC_Scalar_Cosh = Cosh(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
        MQC_Scalar_Cosh = Cosh(dFloat(Scalar%ScaI))
#else
        MQC_Scalar_Cosh = Cosh(Float(Scalar%ScaI))
#endif
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        MQC_Scalar_Cosh = Cosh(Scalar%ScaC)
      Else
        Call MQC_Error_A('Scalar type unspecified in MQC_Scalar_Cosh', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Cosh
!
!
!     PROCEDURE MQC_Scalar_HaveReal
!
!>    \brief <b> MQC_Scalar_HaveReal is a function that returns TRUE or FALSE 
!>    indicating whether an MQC_scalar is of type real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_HaveReal is a function that returns TRUE or FALSE indicating 
!>    whether an MQC_scalar is of type real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Scalar_HaveReal(Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Scalar_HaveReal
      Type(MQC_Scalar),Intent(In)::Scalar
!
      MQC_Scalar_HaveReal = Allocated(Scalar%ScaR)
!
      Return
      End Function MQC_Scalar_HaveReal
!
!
!     PROCEDURE MQC_Scalar_HaveInteger
!
!>    \brief <b> MQC_Scalar_HaveInteger is a function that returns TRUE or FALSE 
!>    indicating whether an MQC_scalar is of type integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_HaveInteger is a function that returns TRUE or FALSE indicating 
!>    whether an MQC_scalar is of type integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Scalar_HaveInteger(Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Scalar_HaveInteger
      Type(MQC_Scalar),Intent(In)::Scalar
!
      MQC_Scalar_HaveInteger = Allocated(Scalar%ScaI)
!
      Return
      End Function MQC_Scalar_HaveInteger
!
!
!     PROCEDURE MQC_Scalar_HaveComplex
!
!>    \brief <b> MQC_Scalar_HaveComplex is a function that returns TRUE or FALSE 
!>    indicating whether an MQC_scalar is of type complex</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_HaveComplex is a function that returns TRUE or FALSE indicating 
!>    whether an MQC_scalar is of type complex.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Scalar_HaveComplex(Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Scalar_HaveComplex
      Type(MQC_Scalar),Intent(In)::Scalar
!
      MQC_Scalar_HaveComplex = Allocated(Scalar%ScaC)
!
      Return
      End Function MQC_Scalar_HaveComplex
!
!
!     PROCEDURE MQC_Scalar_Get_Intrinsic_Real
!
!>    \brief <b> MQC_Scalar_Get_Intrinsic_Real is a function that returns the
!>    MQC_scalar value as an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Get_Intrinsic_Real is a function that returns the MQC_scalar 
!>    value as an intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Scalar_Get_Intrinsic_Real(Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64)::Output
!
      If(Scalar%Data_Type.eq.'Integer') then
        Output = Real(Scalar%ScaI)
      ElseIf(Scalar%Data_Type.eq.'Real') then
        Output = Scalar%ScaR
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        Output = Real(Scalar%ScaC)
      Else
        call mqc_error_A('Data type unrecognised.', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Get_Intrinsic_Real
!
!
!     PROCEDURE MQC_Scalar_Get_Intrinsic_Integer
!
!>    \brief <b> MQC_Scalar_Get_Intrinsic_Integer is a function that returns the
!>    MQC_scalar value as an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Get_Intrinsic_Integer is a function that returns the MQC_scalar 
!>    value as an intrinsic integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Scalar_Get_Intrinsic_Integer(Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64)::Output
!
      If(Scalar%Data_Type.eq.'Integer') then
        Output = Scalar%ScaI
      ElseIf(Scalar%Data_Type.eq.'Real') then
        Output = int(Scalar%ScaR)
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        Output = int(Scalar%ScaC)
      Else
        call mqc_error_A('Data type unrecognised.', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Get_Intrinsic_Integer
!
!
!     PROCEDURE MQC_Scalar_Get_Intrinsic_Complex
!
!>    \brief <b> MQC_Scalar_Get_Intrinsic_Complex is a function that returns the
!>    MQC_scalar value as an intrinsic complex</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Get_Intrinsic_Complex is a function that returns the MQC_scalar 
!>    value as an intrinsic complex.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Scalar_Get_Intrinsic_Complex(Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Scalar),Intent(In)::Scalar
      Complex(Kind=real64)::Output
!
      If(Scalar%Data_Type.eq.'Integer') then
        Output = cmplx(Scalar%ScaI,0)
      ElseIf(Scalar%Data_Type.eq.'Real') then
        Output = cmplx(Scalar%ScaR,0.0)
      ElseIf(Scalar%Data_Type.eq.'Complex') then
        Output = Scalar%ScaC
      Else
        call mqc_error_A('Data type unrecognised.', 6, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf
!
      Return
      End Function MQC_Scalar_Get_Intrinsic_Complex
!
!
!     PROCEDURE MQC_Scalar_Get_ABS_Value
!
!>    \brief <b> MQC_Scalar_Get_ABS_Value is a function that returns the
!>    absolute value of MQC_scalar variable</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Get_ABS_Value is a function that returns the absolute value 
!>    of MQC_scalar variable.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author A. Mahler     
!>    \date 2018
!
      Function MQC_Scalar_Get_ABS_Value(Scalar) Result(Output)
!
!     Variable Declarations
      Implicit None
      Class(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Scalar)::Output

      if(Scalar%Data_Type.eq.'Integer') then
        output = real(abs(Scalar%ScaI))
      elseif(Scalar%Data_Type.eq.'Real') then
        output = abs(Scalar%ScaR)
      elseif(Scalar%Data_Type.eq.'Complex') then
        output = abs(Scalar%ScaC)
      else
        call mqc_error_A('Data type unrecognized.', 6, &
          'Scalar%Data_Type', Scalar%Data_Type)
      endif
!
      return
      END FUNCTION MQC_Scalar_Get_ABS_Value
!
!
!     PROCEDURE MQC_Scalar_Get_Phase
!
!>    \brief <b> MQC_Scalar_Get_Phase is a function that returns the
!>    phase angle in radian of MQC_scalar variable</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Scalar_Get_Phase is a function that returns the phase angle (p)
!>    in radian of MQC_scalar variable. Such as:
!>    Scalar=exp(-ip)*abs(Scalar)=abs(Scalar)(cos(p)-i sin(p))
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!>
!>    \param[in] Thresh_Inp
!>    \verbatim
!>        Thresh_Inp is Type(MQC_Scalar)
!>        The threshold for determining the phase.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author M.M.F. Moraes
!>    \date 2025
!
      Function MQC_Scalar_Get_Phase(Scalar,thresh_inp) Result(Output)
!
!     Variable Declarations
      Implicit None
      Class(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Scalar),optional,Intent(In)::thresh_inp
      Type(MQC_Scalar)::Output
      real::thresh

      if(present(thresh_inp)) then
       thresh=thresh_inp%rval()
      else
        thresh=1.0E-8
      end if
      if (abs(Scalar).lt.thresh) then 
        output = 0.0
      else
        output = acos(Scalar%rval()/abs(Scalar))
      end if
      return
!
      END FUNCTION MQC_Scalar_Get_Phase
!
!
!     PROCEDURE MQC_Scalar_Log
!
!>    \brief <b> MQC_Scalar_Log is a function that returns the
!>    natural log of MQC_scalar variable</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_GLog is a function that returns the natural log
!>    of MQC_scalar variable.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The MQC_Scalar to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson     
!>    \date 2021
!
      Function MQC_Scalar_Log(Scalar) Result(Output)
!
!     Variable Declarations
      Implicit None
      Class(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Scalar)::Output

      if(Scalar%Data_Type.eq.'Integer') then
        output = log(real(Scalar%ScaI))
      elseif(Scalar%Data_Type.eq.'Real') then
        output = log(Scalar%ScaR)
      elseif(Scalar%Data_Type.eq.'Complex') then
        output = log(Scalar%ScaC)
      else
        call mqc_error_A('Data type unrecognized in MQC_Scalar_Log', 6, &
          'Scalar%Data_Type', Scalar%Data_Type)
      endif
!
      return
      END FUNCTION MQC_Scalar_Log
!
!
!     PROCEDURE MQC_Scalar_Get_Random_Value
!
!>    \brief <b> MQC_Scalar_Get_Random_Value is a function that returns a
!>    random real value from a specified distribution</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Get_Random_Value is a function that returns a random real 
!>    value from an optionally specified distribution. Note that the range of
!>    values varies by distribution. In addition, a seed can be specified for 
!>    consistent greneration of the same number. Default options are uniform 
!>    distribution with random seed. The following options are available:
!>    
!>    1. Distribution = 'uniform' uses a uniform distribution between 0 and 1. 
!>    2. Distribution = 'gaussian' uses a normal distribution with zero mean and
!>                      unit variance obtained using the Box-Muller transformation
!>    3. Distribution = 'exp' uses an exponential distribution (lambda=1.0) 
!>                      returning positive integers. 
!>    4. Distribution = 'exp01' uses an exponential distribution (lambda=8.0)that 
!>                      gives values in the range 0 and 1. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Scalar
!>    \verbatim
!>        Scalar is Class(MQC_Scalar)
!>        The MQC_Scalar to be filled. 
!>    \endverbatim
!>
!>    \param[in] Seed
!>    \verbatim
!>        Seed is integer,dimension(:),optional 
!>        Integer array containing seed. Note in gfortran
!>        only the first two elements affect the value of
!>        the random number.
!>    \endverbatim
!>
!>    \param[in] Distribution
!>    \verbatim
!>        Distribution is character(len=*),intent(in),optional 
!>        Distribution of the function from which random number
!>        is selected.
!>        = 'uniform':  uniform between 0 and 1
!>        = 'gaussian': normal deviation with zero mean and unit 
!>                      variance
!>        = 'exp':      exponential decay y=\exp(-x)
!>        = 'exp01':    exponential decay between 0 and 1 obtained
!>                      using mod(y,1.0) of y=\exp(-8x).
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Dong     
!>    \author L. M. Thompson    
!>    \date 2019
!
      Subroutine MQC_Scalar_Get_Random_Value(Scalar,Seed,Distribution) 
!
!     Variable Declarations
      Implicit None
      Class(MQC_Scalar)::Scalar
      character(len=*),intent(in),optional::distribution
      character(len=64)::my_distribution
      integer,dimension(:),optional::seed
      integer,dimension(:),allocatable::my_seed
      integer::clock,n,i
      real::r,r2
!
      if(present(distribution)) then
        call string_change_case(distribution,'l',my_distribution)
      else
        my_distribution = 'uniform'
      endIf
!
      call random_seed(size=n) 
      allocate(my_seed(n))
      if(present(seed)) then
        my_seed(:) = seed(:)
        call random_seed(put=my_seed)
      else
        call random_seed(get=my_seed)
      endIf
!
      select case (my_distribution)
      case('uniform')
        call random_number(r)
        scalar = r
      case('gaussian')
        do while(.true.)
          call random_number(r)
          call random_number(r2)
          r = 2*r-1
          r2 = 2*r2-1
          if(r**2+r2**2.ne.0.and.r**2+r2**2.lt.1) exit
        endDo
        scalar = r*sqrt(-2*log(r**2+r2**2)/(r**2+r2**2))
      case('exp')
        call random_number(r)
        scalar = -log(r)
      case('exp01')
        call random_number(r)
        r = -(1/8.0)*log(r)
        scalar = mod(r,1.0)
      case default
        call mqc_error_A('Unrecognised distribution flag in MQC_Scalar_Get_Random_Value', 6,  &
          'my_distribution',my_distribution)
      end select 
!
      return
      end subroutine MQC_Scalar_Get_Random_Value
!
!
!     PROCEDURE MQC_ScalarAdd
!
!>    \brief <b> MQC_ScalarAdd is a function that sums two MQC_Scalar objects</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarAdd is a function that sums two MQC_Scalar objects.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar to be summed.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar to be summed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarAdd(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarAdd
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
 1050 Format( 2A )
      Call MQC_Deallocate_Scalar(MQC_ScalarAdd)
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Real')
        MQC_ScalarAdd%ScaR = Scalar1%ScaR + Scalar2%ScaR
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Real')
#ifdef PGI
        MQC_ScalarAdd%ScaR = Scalar1%ScaR + dFloat(Scalar2%ScaI)
#else
        MQC_ScalarAdd%ScaR = Scalar1%ScaR + Float(Scalar2%ScaI)
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Real')
#ifdef PGI
        MQC_ScalarAdd%ScaR = dFloat(Scalar1%ScaI) + Scalar2%ScaR
#else
        MQC_ScalarAdd%ScaR = Float(Scalar1%ScaI) + Scalar2%ScaR
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Integer')
        MQC_ScalarAdd%ScaI = Scalar1%ScaI + Scalar2%ScaI
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Complex')
        MQC_ScalarAdd%ScaC = Scalar1%ScaC + Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Complex')
        MQC_ScalarAdd%ScaC = cmplx(Scalar1%ScaR,0.0) + Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Complex')
        MQC_ScalarAdd%ScaC = Scalar1%ScaC + cmplx(Scalar2%ScaR,0.0)
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Complex')
        MQC_ScalarAdd%ScaC = cmplx(Scalar1%ScaI,0) + Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarAdd,'Complex')
        MQC_ScalarAdd%ScaC = Scalar1%ScaC + cmplx(Scalar2%ScaI,0)
      Else
        write(*,1050)' Scalar type of #1 = ',TRIM(Scalar1%Data_type)
        write(*,1050)' Scalar type of #2 = ',TRIM(Scalar2%Data_type)
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarAdd', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarAdd
!
!
!     PROCEDURE MQC_ScalarSubtract
!
!>    \brief <b> MQC_ScalarSubtract is a function that subtracts two MQC_Scalar objects</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarSubtract is a function that subtracts two MQC_Scalar objects.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar from which Scalar2 will be subtracted.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar which will be subtracted from Scalar1.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarSubtract(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarSubtract
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
      Call MQC_Deallocate_Scalar(MQC_ScalarSubtract)
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Real')
        MQC_ScalarSubtract%ScaR = Scalar1%ScaR - Scalar2%ScaR
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Real')
#ifdef PGI
        MQC_ScalarSubtract%ScaR = Scalar1%ScaR - dFloat(Scalar2%ScaI)
#else
        MQC_ScalarSubtract%ScaR = Scalar1%ScaR - Float(Scalar2%ScaI)
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Real')
#ifdef PGI
        MQC_ScalarSubtract%ScaR = dFloat(Scalar1%ScaI) - Scalar2%ScaR
#else
        MQC_ScalarSubtract%ScaR = Float(Scalar1%ScaI) - Scalar2%ScaR
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Integer')
        MQC_ScalarSubtract%ScaI = Scalar1%ScaI - Scalar2%ScaI
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Complex')
        MQC_ScalarSubtract%ScaC = Scalar1%ScaC - Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Complex')
        MQC_ScalarSubtract%ScaC = cmplx(Scalar1%ScaR,0.0) - Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Complex')
        MQC_ScalarSubtract%ScaC = Scalar1%ScaC - cmplx(Scalar2%ScaR,0.0)
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Complex')
        MQC_ScalarSubtract%ScaC = cmplx(Scalar1%ScaI,0) - Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarSubtract,'Complex')
        MQC_ScalarSubtract%ScaC = Scalar1%ScaC - cmplx(Scalar2%ScaI,0)
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarSubtract', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarSubtract
!
!
!     PROCEDURE MQC_ScalarMultiply
!
!>    \brief <b> MQC_ScalarMultiply is a function that multiplies two MQC_Scalar objects</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarMultiply is a function that multiplies two MQC_Scalar objects.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar to be multiplied.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar to be multiplied.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarMultiply(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarMultiply
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
      Call MQC_Deallocate_Scalar(MQC_ScalarMultiply)
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Real')
        MQC_ScalarMultiply%ScaR = Scalar1%ScaR * Scalar2%ScaR
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Real')
#ifdef PGI
        MQC_ScalarMultiply%ScaR = Scalar1%ScaR * dFloat(Scalar2%ScaI)
#else
        MQC_ScalarMultiply%ScaR = Scalar1%ScaR * Float(Scalar2%ScaI)
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Real')
#ifdef PGI
        MQC_ScalarMultiply%ScaR = dFloat(Scalar1%ScaI) * Scalar2%ScaR
#else
        MQC_ScalarMultiply%ScaR = Float(Scalar1%ScaI) * Scalar2%ScaR
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Integer')
        MQC_ScalarMultiply%ScaI = Scalar1%ScaI * Scalar2%ScaI
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Complex')
        MQC_ScalarMultiply%ScaC = Scalar1%ScaC * Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Complex')
        MQC_ScalarMultiply%ScaC = cmplx(Scalar1%ScaR,0.0) * Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Complex')
        MQC_ScalarMultiply%ScaC = Scalar1%ScaC * cmplx(Scalar2%ScaR,0.0)
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Complex')
        MQC_ScalarMultiply%ScaC = cmplx(Scalar1%ScaI,0) * Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarMultiply,'Complex')
        MQC_ScalarMultiply%ScaC = Scalar1%ScaC * cmplx(Scalar2%ScaI,0)
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarMultiply', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarMultiply
!
!
!     PROCEDURE MQC_ScalarDivide
!
!>    \brief <b> MQC_ScalarDivide is a function that divides two MQC_Scalar objects</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarDivide is a function that divides MQC_Scalar objects.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The numerator.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarDivide(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarDivide
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
      Call MQC_Deallocate_Scalar(MQC_ScalarDivide)
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Real')
        MQC_ScalarDivide%ScaR = Scalar1%ScaR / Scalar2%ScaR
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Real')
#ifdef PGI
        MQC_ScalarDivide%ScaR = Scalar1%ScaR / dFloat(Scalar2%ScaI)
#else
        MQC_ScalarDivide%ScaR = Scalar1%ScaR / Float(Scalar2%ScaI)
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Real')
#ifdef PGI
        MQC_ScalarDivide%ScaR = dFloat(Scalar1%ScaI) / Scalar2%ScaR
#else
        MQC_ScalarDivide%ScaR = Float(Scalar1%ScaI) / Scalar2%ScaR
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Integer')
        MQC_ScalarDivide%ScaI = Scalar1%ScaI / Scalar2%ScaI
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Complex')
        MQC_ScalarDivide%ScaC = Scalar1%ScaC / Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Complex')
        MQC_ScalarDivide%ScaC = cmplx(Scalar1%ScaR,0.0) / Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Complex')
        MQC_ScalarDivide%ScaC = Scalar1%ScaC / cmplx(Scalar2%ScaR,0.0)
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Complex')
        MQC_ScalarDivide%ScaC = cmplx(Scalar1%ScaI,0) / Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarDivide,'Complex')
        MQC_ScalarDivide%ScaC = Scalar1%ScaC + cmplx(Scalar2%ScaI,0)
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarDivide', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarDivide
!
!
!     PROCEDURE MQC_ScalarExponent
!
!>    \brief <b> MQC_ScalarExponent is a function that raises one MQC_Scalar to the
!>    power of another MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarExponent is a function that raises one MQC_Scalar to the power of 
!>    another MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The base value.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The power value.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarExponent(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarExponent
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
      Call MQC_Deallocate_Scalar(MQC_ScalarExponent)
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Real')
        MQC_ScalarExponent%ScaR = Scalar1%ScaR ** Scalar2%ScaR
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Real')
#ifdef PGI
        MQC_ScalarExponent%ScaR = Scalar1%ScaR ** dFloat(Scalar2%ScaI)
#else
        MQC_ScalarExponent%ScaR = Scalar1%ScaR ** Float(Scalar2%ScaI)
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Real')
#ifdef PGI
        MQC_ScalarExponent%ScaR = dFloat(Scalar1%ScaI) ** Scalar2%ScaR
#else
        MQC_ScalarExponent%ScaR = Float(Scalar1%ScaI) ** Scalar2%ScaR
#endif
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Integer')
        MQC_ScalarExponent%ScaI = Scalar1%ScaI ** Scalar2%ScaI
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Complex')
        MQC_ScalarExponent%ScaC = Scalar1%ScaC ** Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Complex')
        MQC_ScalarExponent%ScaC = cmplx(Scalar1%ScaR,0.0) ** Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Complex')
        MQC_ScalarExponent%ScaC = Scalar1%ScaC ** cmplx(Scalar2%ScaR,0.0)
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Complex')
        MQC_ScalarExponent%ScaC = cmplx(Scalar1%ScaI,0) ** Scalar2%ScaC
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarExponent,'Complex')
        MQC_ScalarExponent%ScaC = Scalar1%ScaC ** cmplx(Scalar2%ScaI,0)
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarExponent', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarExponent
!
!
!     PROCEDURE MQC_ScalarIntegerExponent
!
!>    \brief <b> MQC_ScalarIntegerExponent is a function that raises an MQC_Scalar to the
!>    power of an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarIntegerExponent is a function that raises an MQC_Scalar to the power of an 
!>    intrinsic integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The base value.
!>    \endverbatim
!>
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The power value.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarIntegerExponent(Scalar,IntIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarIntegerExponent
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::intIn
!
      Call MQC_Deallocate_Scalar(MQC_ScalarIntegerExponent)
      If(Scalar%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarIntegerExponent,'Real')
#ifdef PGI
        MQC_ScalarIntegerExponent%ScaR = Scalar%ScaR ** dFloat(IntIn)
#else
        MQC_ScalarIntegerExponent%ScaR = Scalar%ScaR ** Float(IntIn)
#endif
      ElseIf(Scalar%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarIntegerExponent,'Integer')
        MQC_ScalarIntegerExponent%ScaI = Scalar%ScaI ** IntIn
      ElseIf(Scalar%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarIntegerExponent,'Complex')
        MQC_ScalarIntegerExponent%ScaC = Scalar%ScaC ** cmplx(IntIn,0)
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarIntegerExponent', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarIntegerExponent
!
!
!     PROCEDURE MQC_ScalarRealExponent
!
!>    \brief <b> MQC_ScalarRealExponent is a function that raises an MQC_Scalar to the
!>    power of an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarRealExponent is a function that raises an MQC_Scalar to the power of an 
!>    intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The base value.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The power value.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarRealExponent(Scalar,RealIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarRealExponent
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
!
      Call MQC_Deallocate_Scalar(MQC_ScalarRealExponent)
      If(Scalar%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarRealExponent,'Real')
        MQC_ScalarRealExponent%ScaR = Scalar%ScaR ** RealIn
      ElseIf(Scalar%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarRealExponent,'Real')
#ifdef PGI
        MQC_ScalarRealExponent%ScaR = dFloat(Scalar%ScaI) ** RealIn
#else
        MQC_ScalarRealExponent%ScaR = Float(Scalar%ScaI) ** RealIn
#endif
      ElseIf(Scalar%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarRealExponent,'Complex')
        MQC_ScalarRealExponent%ScaC = Scalar%ScaC ** cmplx(RealIn,0.0)
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarRealExponent', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarRealExponent
!
!
!     PROCEDURE MQC_ScalarComplexExponent
!
!>    \brief <b> MQC_ScalarComplexExponent is a function that raises an MQC_Scalar to the
!>    power of an intrinsic complex</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarComplexExponent is a function that raises an MQC_Scalar to the power of an 
!>    intrinsic complex.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The base value.
!>    \endverbatim
!>
!>    \param[in] CompIn
!>    \verbatim
!>        CompIn is Complex(kind=real64)
!>        The power value.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarComplexExponent(Scalar,CompIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::MQC_ScalarComplexExponent
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::CompIn
!
      Call MQC_Deallocate_Scalar(MQC_ScalarComplexExponent)
      If(Scalar%Data_type.eq.'Complex') then
        Call MQC_Allocate_Scalar(MQC_ScalarComplexExponent,'Complex')
        MQC_ScalarComplexExponent%ScaC = Scalar%ScaC ** CompIn
      ElseIf(Scalar%Data_type.eq.'Real') then
        Call MQC_Allocate_Scalar(MQC_ScalarComplexExponent,'Complex')
        MQC_ScalarComplexExponent%ScaC = cmplx(Scalar%ScaR,0.0) ** CompIn
      ElseIf(Scalar%Data_type.eq.'Integer') then
        Call MQC_Allocate_Scalar(MQC_ScalarComplexExponent,'Complex')
        MQC_ScalarComplexExponent%ScaC = cmplx(Scalar%ScaI,0) ** CompIn
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarComplexExponent', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarComplexExponent
!
!
!     PROCEDURE MQC_ScalarNE
!
!>    \brief <b> MQC_ScalarNE is a function that returns TRUE if two MQC_Scalar
!>    variables are not equal</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarNE is a function that returns TRUE if two MQC_Scalar variables 
!>    are not equal.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarNE(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarNE
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scar.eq.Scalar2%scar) MQC_ScalarNE = .False.
        If(Scalar1%scar.ne.Scalar2%scar) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scar.eq.Scalar2%scai) MQC_ScalarNE = .False.
        If(Scalar1%scar.ne.Scalar2%scai) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scai.eq.Scalar2%scar) MQC_ScalarNE = .False.
        If(Scalar1%scai.ne.Scalar2%scar) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scai.eq.Scalar2%scai) MQC_ScalarNE = .False.
        If(Scalar1%scai.ne.Scalar2%scai) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scac.eq.Scalar2%scac) MQC_ScalarNE = .False.
        If(Scalar1%scac.ne.Scalar2%scac) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scar.eq.Scalar2%scac) MQC_ScalarNE = .False.
        If(Scalar1%scar.ne.Scalar2%scac) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scac.eq.Scalar2%scar) MQC_ScalarNE = .False.
        If(Scalar1%scac.ne.Scalar2%scar) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scai.eq.Scalar2%scac) MQC_ScalarNE = .False.
        If(Scalar1%scai.ne.Scalar2%scac) MQC_ScalarNE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scac.eq.Scalar2%scai) MQC_ScalarNE = .False.
        If(Scalar1%scac.ne.Scalar2%scai) MQC_ScalarNE = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarNE', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarNE
!
!
!     PROCEDURE MQC_IntegerNEScalar
!
!>    \brief <b> MQC_IntegerNEScalar is a function that returns TRUE if an intrinsic 
!>    integer is not equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerNEScalar is a function that returns TRUE if an intrinsic integer is 
!>    not equal to a MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerNEScalar(IntIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_IntegerNEScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
!
      MQC_IntegerNEScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(IntIn.ne.Scalar%scar) MQC_IntegerNEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(IntIn.ne.Scalar%scai) MQC_IntegerNEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(IntIn.ne.Scalar%scac) MQC_IntegerNEScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_IntegerNEScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_IntegerNEScalar
!
!
!     PROCEDURE MQC_ScalarNEInteger
!
!>    \brief <b> MQC_ScalarNEInteger is a function that returns TRUE if a MQC_Scalar is
!>    not equal to an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarNEInteger is a function that returns TRUE if a MQC_Scalar is not equal 
!>    to an intrinsic integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] intIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarNEInteger(Scalar,IntIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarNEInteger
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
!
      MQC_ScalarNEInteger = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.ne.IntIn) MQC_ScalarNEInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.ne.IntIn) MQC_ScalarNEInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(Scalar%scac.ne.IntIn) MQC_ScalarNEInteger = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarNEInteger', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarNEInteger
!
!
!     PROCEDURE MQC_RealNEScalar
!
!>    \brief <b> MQC_RealNEScalar is a function that returns TRUE if an intrinsic real
!>    is not equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealNEScalar is a function that returns TRUE if an intrinsic real is not
!>    equal to a MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealNEScalar(RealIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_RealNEScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
!
      MQC_RealNEScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(RealIn.ne.Scalar%scar) MQC_RealNEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(RealIn.ne.Scalar%scai) MQC_RealNEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(RealIn.ne.Scalar%scac) MQC_RealNEScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_RealNEScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_RealNEScalar
!
!
!     PROCEDURE MQC_ScalarNEReal
!
!>    \brief <b> MQC_ScalarNEReal is a function that returns TRUE if a MQC_Scalar is
!>    not equal to an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarNEReal is a function that returns TRUE if a MQC_Scalar is not equal 
!>    to an intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarNEReal(Scalar,RealIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarNEReal
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
!
      MQC_ScalarNEReal = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.ne.RealIn) MQC_ScalarNEReal = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.ne.RealIn) MQC_ScalarNEReal = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(Scalar%scac.ne.RealIn) MQC_ScalarNEReal = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarNEReal', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarNEReal
!
!
!     PROCEDURE MQC_ComplexNEScalar
!
!>    \brief <b> MQC_ComplexNEScalar is a function that returns TRUE if an intrinsic complex
!>    is not equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexNEScalar is a function that returns TRUE if an intrinsic complex is not
!>    equal to a MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Copmplex(kind=real64)
!>        The intrinsic complex that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ComplexNEScalar(ComplexIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ComplexNEScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
!
      MQC_ComplexNEScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(ComplexIn.ne.Scalar%scar) MQC_ComplexNEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(ComplexIn.ne.Scalar%scai) MQC_ComplexNEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(ComplexIn.ne.Scalar%scac) MQC_ComplexNEScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ComplexNEScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ComplexNEScalar
!
!
!     PROCEDURE MQC_ScalarNEComplex
!
!>    \brief <b> MQC_ScalarNEComplex is a function that returns TRUE if a MQC_Scalar is
!>    not equal to an intrinsic complex</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarNEComplex is a function that returns TRUE if a MQC_Scalar is not equal 
!>    to an intrinsic complex.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Complex(kind=real64)
!>        The intrinsic complex that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarNEComplex(Scalar,ComplexIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarNEComplex
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
!
      MQC_ScalarNEComplex = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.ne.ComplexIn) MQC_ScalarNEComplex = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.ne.ComplexIn) MQC_ScalarNEComplex = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(Scalar%scac.ne.ComplexIn) MQC_ScalarNEComplex = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarNEComplex', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarNEComplex
!
!
!     PROCEDURE MQC_ScalarEQ
!
!>    \brief <b> MQC_ScalarEQ is a function that returns TRUE if two MQC_Scalar
!>    variables are equal</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarEQ is a function that returns TRUE if two MQC_Scalar variables 
!>    are equal.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarEQ(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarEQ
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
!
      MQC_ScalarEQ = .False.
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scar.eq.Scalar2%scar) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scar.eq.Scalar2%scai) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scai.eq.Scalar2%scar) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scai.eq.Scalar2%scai) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scac.eq.Scalar2%scac) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scar.eq.Scalar2%scac) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scac.eq.Scalar2%scar) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scai.eq.Scalar2%scac) MQC_ScalarEQ = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scac.eq.Scalar2%scai) MQC_ScalarEQ = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarEQ', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarEQ
!
!
!     PROCEDURE MQC_IntegerEQScalar
!
!>    \brief <b> MQC_IntegerEQScalar is a function that returns TRUE if an intrinsic 
!>    integer is equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerEQScalar is a function that returns TRUE if an intrinsic integer is 
!>    equal to a MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_IntegerEQScalar(IntegerIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_IntegerEQScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Integer(kind=int64)::Zero=0.0d0
!
      MQC_IntegerEQScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(IntegerIn.eq.Scalar%scar) MQC_IntegerEQScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(IntegerIn.eq.Scalar%scai) MQC_IntegerEQScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(IntegerIn.eq.Scalar%scac) MQC_IntegerEQScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_IntegerEQScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_IntegerEQScalar
!
!
!     PROCEDURE MQC_ScalarEQInteger
!
!>    \brief <b> MQC_ScalarEQInteger is a function that returns TRUE if a MQC_Scalar is
!>    equal to an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarEQInteger is a function that returns TRUE if a MQC_Scalar is equal to an 
!>    intrinsic integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_ScalarEQInteger(Scalar,IntegerIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarEQInteger
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Integer(kind=int64)::Zero=0.0d0
!
      MQC_ScalarEQInteger = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.eq.IntegerIn) MQC_ScalarEQInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.eq.IntegerIn) MQC_ScalarEQInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(Scalar%scac.eq.integerIn) MQC_ScalarEQInteger = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarEQInteger', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarEQInteger
!
!
!     PROCEDURE MQC_RealEQScalar
!
!>    \brief <b> MQC_RealEQScalar is a function that returns TRUE if an intrinsic real
!>    is equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealEQScalar is a function that returns TRUE if an intrinsic real is equal to
!>    a MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealEQScalar(RealIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_RealEQScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_RealEQScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(RealIn.eq.Scalar%scar) MQC_RealEQScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(RealIn.eq.Scalar%scai) MQC_RealEQScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(RealIn.eq.Scalar%scac) MQC_RealEQScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_RealEQScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_RealEQScalar
!
!
!     PROCEDURE MQC_ScalarEQReal
!
!>    \brief <b> MQC_ScalarEQReal is a function that returns TRUE if a MQC_Scalar is
!>    equal to an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarEQReal is a function that returns TRUE if a MQC_Scalar is equal to an 
!>    intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarEQReal(Scalar,RealIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarEQReal
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarEQReal = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.eq.RealIn) MQC_ScalarEQReal = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.eq.RealIn) MQC_ScalarEQReal = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(Scalar%scac.eq.RealIn) MQC_ScalarEQReal = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarEQReal', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarEQReal
!
!
!     PROCEDURE MQC_ComplexEQScalar
!
!>    \brief <b> MQC_ComplexEQScalar is a function that returns TRUE if an intrinsic 
!>    complex is equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexEQScalar is a function that returns TRUE if an intrinsic complex is 
!>    equal to a MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Complex(kind=real64)
!>        The intrinsic complex that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_ComplexEQScalar(ComplexIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ComplexEQScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Complex(kind=real64)::Zero=0.0d0
!
      MQC_ComplexEQScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(ComplexIn.eq.Scalar%scar) MQC_ComplexEQScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(ComplexIn.eq.Scalar%scai) MQC_ComplexEQScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(ComplexIn.eq.Scalar%scac) MQC_ComplexEQScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ComplexEQScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ComplexEQScalar
!
!
!     PROCEDURE MQC_ScalarEQComplex
!
!>    \brief <b> MQC_ScalarEQComplex is a function that returns TRUE if a MQC_Scalar is
!>    equal to an intrinsic complex</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarEQComplex is a function that returns TRUE if a MQC_Scalar is equal to an 
!>    intrinsic complex.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Complex(kind=real64)
!>        The intrinsic complex that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_ScalarEQComplex(Scalar,ComplexIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarEQComplex
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Complex(kind=real64)::Zero=0.0d0
!
      MQC_ScalarEQComplex = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.eq.ComplexIn) MQC_ScalarEQComplex = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.eq.ComplexIn) MQC_ScalarEQComplex = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(Scalar%scac.eq.ComplexIn) MQC_ScalarEQComplex = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarEQComplex', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarEQComplex
!
!
!     PROCEDURE MQC_ScalarLT
!
!>    \brief <b> MQC_ScalarLT is a function that returns TRUE if the left MQC_Scalar
!>    is less than the right MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarLT is a function that returns TRUE if the left MQC_Scalar is less than
!>    the right MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the left real part 
!>    is less than the right real part and FALSE if the left real part is greater than 
!>    the right real part. If the left real part is equal to the right real part, the 
!>    function returns TRUE if the left imaginary part is less than the right imaginary 
!>    part and FALSE otherwise. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarLT(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarLT
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
      Real::Zero=0.0d0
!
      MQC_ScalarLT = .False.
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scar.lt.Scalar2%scar) MQC_ScalarLT = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scar.lt.Scalar2%scai) MQC_ScalarLT = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scar.eq.real(Scalar2%scac)) then
          If(Zero.lt.aimag(Scalar2%scac)) MQC_ScalarLT = .True.
        ElseIf(Scalar1%scar.lt.real(Scalar2%scac)) then
          MQC_ScalarLT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scai.lt.Scalar2%scar) MQC_ScalarLT = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scai.lt.Scalar2%scai) MQC_ScalarLT = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scai.eq.real(Scalar2%scac)) then
          If(Zero.lt.aimag(Scalar2%scac)) MQC_ScalarLT = .True.
        ElseIf(Scalar1%scai.lt.real(Scalar2%scac)) then
          MQC_ScalarLT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        If(real(Scalar1%scac).eq.Scalar2%scar) then
          If(aimag(Scalar1%scac).lt.Zero) MQC_ScalarLT = .True.
        ElseIf(real(Scalar1%scac).lt.Scalar2%scar) then
          MQC_ScalarLT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        If(real(Scalar1%scac).eq.Scalar2%scai) then
          If(aimag(Scalar1%scac).lt.Zero) MQC_ScalarLT = .True.
        ElseIf(real(Scalar1%scac).lt.Scalar2%scai) then
          MQC_ScalarLT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        If(real(Scalar1%scac).eq.real(Scalar2%scac)) then 
          If(aimag(Scalar1%scac).lt.aimag(Scalar2%scac)) MQC_ScalarLT = .True.
        ElseIf(real(Scalar1%scac).lt.real(Scalar2%scac)) then
          MQC_ScalarLT = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarLT', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarLT
!
!
!     PROCEDURE MQC_IntegerLTScalar
!
!>    \brief <b> MQC_IntegerLTScalar is a function that returns TRUE if an intrinsic 
!>    integer is less than a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_integerLTScalar is a function that returns TRUE if an intrinsic integer is 
!>    less than a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic 
!>    integer is less than the real part of the MQC_Scalar and FALSE if the intrinsic 
!>    integer is greater than the real part of the MQC_Scalar. If the intrinsic 
!>    integer is equal to the real part of the MQC_Scalar, the function returns TRUE 
!>    if the imaginary part of MQC_Scalar is greater than zero and FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] integerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_IntegerLTScalar(IntegerIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_IntegerLTScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Integer(kind=int64)::Zero=0.0d0
!
      MQC_IntegerLTScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(IntegerIn.lt.Scalar%scar) MQC_IntegerLTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(IntegerIn.lt.Scalar%scai) MQC_IntegerLTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(IntegerIn.eq.real(Scalar%scac)) then
          If(Zero.lt.aimag(Scalar%scac)) MQC_IntegerLTScalar = .True.
        ElseIf(IntegerIn.lt.real(Scalar%scac)) then
          MQC_IntegerLTScalar = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_IntegerLTScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_IntegerLTScalar
!
!
!     PROCEDURE MQC_ScalarLTInteger
!
!>    \brief <b> MQC_ScalarLTInteger is a function that returns TRUE if a MQC_Scalar is less
!>     than an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarLTInteger is a function that returns TRUE if a MQC_Scalar is less than an 
!>    intrinsic integer.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part of the 
!>    MQC_Scalar is less than the intrinsic integer and FALSE if the real part of the MQC_Scalar
!>    is greater than the intrinsic integer. If the real part of the MQC_Scalar is equal to the
!>    intrinsic integer, the function returns TRUE if the imaginary part of MQC_Scalar is less 
!>    than zero and FALSE otherwise. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_ScalarLTInteger(Scalar,integerIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarLTInteger
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Integer(kind=int64)::Zero=0.0d0
!
      MQC_ScalarLTInteger = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.lt.IntegerIn) MQC_ScalarLTInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.lt.IntegerIn) MQC_ScalarLTInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).eq.IntegerIn) then
          If(aimag(Scalar%scac).lt.Zero) MQC_ScalarLTInteger = .True.
        ElseIf(real(Scalar%scac).lt.integerIn) then
          MQC_ScalarLTInteger = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarLTInteger', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarLTInteger
!
!
!     PROCEDURE MQC_RealLTScalar
!
!>    \brief <b> MQC_RealLTScalar is a function that returns TRUE if an intrinsic real
!>    is less than a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealLTScalar is a function that returns TRUE if an intrinsic real is less than
!>    a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic real 
!>    is less than the real part of the MQC_Scalar and FALSE if the intrinsic real is 
!>    greater than the real part of the MQC_Scalar. If the intrinsic real is equal to the
!>    real part of the MQC_Scalar, the function returns TRUE if the imaginary part of 
!>    MQC_Scalar is greater than zero and FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealLTScalar(RealIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_RealLTScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_RealLTScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(RealIn.lt.Scalar%scar) MQC_RealLTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(RealIn.lt.Scalar%scai) MQC_RealLTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(RealIn.eq.real(Scalar%scac)) then
          If(Zero.lt.aimag(Scalar%scac)) MQC_RealLTScalar = .True.
        ElseIf(realIn.lt.real(Scalar%scac)) then
          MQC_RealLTScalar = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_RealLTScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_RealLTScalar
!
!
!     PROCEDURE MQC_ScalarLTReal
!
!>    \brief <b> MQC_ScalarLTReal is a function that returns TRUE if a MQC_Scalar is less
!>     than an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarLTReal is a function that returns TRUE if a MQC_Scalar is less than an 
!>    intrinsic real.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part of the 
!>    MQC_Scalar is less than the intrinsic real and FALSE if the real part of the MQC_Scalar
!>    is greater than the intrinsic real. If the real part of the MQC_Scalar is equal to the
!>    intrinsic real, the function returns TRUE if the imaginary part of MQC_Scalar is less 
!>    than zero and FALSE otherwise. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarLTReal(Scalar,RealIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarLTReal
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarLTReal = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.lt.RealIn) MQC_ScalarLTReal = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.lt.RealIn) MQC_ScalarLTReal = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).eq.RealIn) then
          If(aimag(Scalar%scac).lt.Zero) MQC_ScalarLTReal = .True.
        ElseIf(real(Scalar%scac).lt.realIn) then
          MQC_ScalarLTReal = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarLTReal', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarLTReal
!
!
!     PROCEDURE MQC_ScalarGT
!
!>    \brief <b> MQC_ScalarGT is a function that returns TRUE if the left MQC_Scalar
!>    is greater than the right MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarGT is a function that returns TRUE if the left MQC_Scalar is greater than
!>    the right MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the left real part 
!>    is greater than the right real part and FALSE if the left real part is less than 
!>    the right real part. If the left real part is equal to the right real part, the 
!>    function returns TRUE if the left imaginary part is greater than the right imaginary 
!>    part and FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarGT(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarGT
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
      Real::Zero=0.0d0
!
      MQC_ScalarGT = .False.
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scar.gt.Scalar2%scar) MQC_ScalarGT = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scar.gt.Scalar2%scai) MQC_ScalarGT = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scar.eq.real(Scalar2%scac)) then
          If(Zero.gt.aimag(Scalar2%scac)) MQC_ScalarGT = .True.
        ElseIf(Scalar1%scar.gt.real(Scalar2%scac)) then
          MQC_ScalarGT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scai.gt.Scalar2%scar) MQC_ScalarGT = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scai.gt.Scalar2%scai) MQC_ScalarGT = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scai.eq.real(Scalar2%scac)) then
          If(Zero.gt.aimag(Scalar2%scac)) MQC_ScalarGT = .True.
        ElseIf(Scalar1%scai.gt.real(Scalar2%scac)) then
          MQC_ScalarGT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        If(real(Scalar1%scac).eq.Scalar2%scar) then
          If(aimag(Scalar1%scac).gt.Zero) MQC_ScalarGT = .True.
        ElseIf(real(Scalar1%scac).gt.Scalar2%scar) then
          MQC_ScalarGT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        If(real(Scalar1%scac).eq.Scalar2%scai) then
          If(aimag(Scalar1%scac).gt.Zero) MQC_ScalarGT = .True.
        ElseIf(real(Scalar1%scac).gt.Scalar2%scai) then
          MQC_ScalarGT = .True.
        EndIf
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        If(real(Scalar1%scac).eq.real(Scalar2%scac)) then 
          If(aimag(Scalar1%scac).gt.aimag(Scalar2%scac)) MQC_ScalarGT = .True.
        ElseIf(real(Scalar1%scac).gt.real(Scalar2%scac)) then
          MQC_ScalarGT = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarGT', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarGT
!
!
!     PROCEDURE MQC_IntegerGTScalar
!
!>    \brief <b> MQC_IntegerGTScalar is a function that returns TRUE if an intrinsic integer
!>    is greater than a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerGTScalar is a function that returns TRUE if an intrinsic integer is greater 
!>    than a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic integer 
!>    is greater than the real part of the MQC_Scalar and FALSE if the intrinsic integer is 
!>    less than the real part of the MQC_Scalar. If the intrinsic integer is equal to the
!>    real part of the MQC_Scalar, the function returns TRUE if the imaginary part of 
!>    MQC_Scalar is less than zero and FALSE otherwise. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerGTScalar(IntIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_IntegerGTScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_IntegerGTScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(IntIn.gt.Scalar%scar) MQC_IntegerGTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(IntIn.gt.Scalar%scai) MQC_IntegerGTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(IntIn.eq.real(Scalar%scac)) then
          If(Zero.gt.aimag(Scalar%scac)) MQC_IntegerGTScalar = .True.
        ElseIf(IntIn.gt.real(Scalar%scac)) then
          MQC_IntegerGTScalar = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_IntegerGTScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_IntegerGTScalar
!
!
!     PROCEDURE MQC_ScalarGTInteger
!
!>    \brief <b> MQC_ScalarGTInteger is a function that returns TRUE if a MQC_Scalar is greater
!>    than an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarGTInteger is a function that returns TRUE if a MQC_Scalar is greater than an 
!>    intrinsic integer.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part of the 
!>    MQC_Scalar is greater than the intrinsic integer and FALSE if the real part of the 
!>    MQC_Scalar is less than the intrinsic integer. If the real part of the MQC_Scalar is 
!>    equal to the intrinsic integer, the function returns TRUE if the imaginary part of 
!>    MQC_Scalar is greater than zero and FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarGTInteger(Scalar,IntIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarGTInteger
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarGTInteger = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.gt.IntIn) MQC_ScalarGTInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.gt.IntIn) MQC_ScalarGTInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).eq.IntIn) then
          If(aimag(Scalar%scac).gt.Zero) MQC_ScalarGTInteger = .True.
        ElseIf(real(Scalar%scac).gt.IntIn) then
          MQC_ScalarGTInteger = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarGTInteger', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarGTInteger
!
!
!     PROCEDURE MQC_RealGTScalar
!
!>    \brief <b> MQC_RealGTScalar is a function that returns TRUE if an intrinsic real
!>    is greater than a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealGTScalar is a function that returns TRUE if an intrinsic real is greater 
!>    than a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic real
!>    is greater than the real part of the MQC_Scalar and FALSE if the intrinsic real is 
!>    less than the real part of the MQC_Scalar. If the intrinsic real is equal to the
!>    real part of the MQC_Scalar, the function returns TRUE if the imaginary part of 
!>    MQC_Scalar is less than zero and FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealGTScalar(RealIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_RealGTScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_RealGTScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(RealIn.gt.Scalar%scar) MQC_RealGTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(RealIn.gt.Scalar%scai) MQC_RealGTScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(RealIn.eq.real(Scalar%scac)) then
          If(Zero.gt.aimag(Scalar%scac)) MQC_RealGTScalar = .True.
        ElseIf(realIn.gt.real(Scalar%scac)) then
          MQC_RealGTScalar = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_RealGTScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_RealGTScalar
!
!
!     PROCEDURE MQC_ScalarGTReal
!
!>    \brief <b> MQC_ScalarGTReal is a function that returns TRUE if a MQC_Scalar is greater
!>    than an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarGTReal is a function that returns TRUE if a MQC_Scalar is greater than an 
!>    intrinsic real.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part of the 
!>    MQC_Scalar is greater than the intrinsic real and FALSE if the real part of the 
!>    MQC_Scalar is less than the intrinsic real. If the real part of the MQC_Scalar is 
!>    equal to the intrinsic real, the function returns TRUE if the imaginary part of 
!>    MQC_Scalar is greater than zero and FALSE otherwise. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=int64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarGTReal(Scalar,RealIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarGTReal
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarGTReal = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.gt.RealIn) MQC_ScalarGTReal = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.gt.RealIn) MQC_ScalarGTReal = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).eq.RealIn) then
          If(aimag(Scalar%scac).gt.Zero) MQC_ScalarGTReal = .True.
        ElseIf(real(Scalar%scac).gt.realIn) then
          MQC_ScalarGTReal = .True.
        EndIf
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarGTReal', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarGTReal
!
!
!     PROCEDURE MQC_ScalarLE
!
!>    \brief <b> MQC_ScalarLE is a function that returns TRUE if the left MQC_Scalar
!>    is less than or equal the right MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarLE is a function that returns TRUE if the left MQC_Scalar is less than or
!>    equal to the right MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the left real part 
!>    is less than or equal to the right real part and FALSE if the left real part is greater 
!>    than the right real part.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarLE(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarLE
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
      Real::Zero=0.0d0
!
      MQC_ScalarLE = .False.
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scar.le.Scalar2%scar) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scar.le.Scalar2%scai) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scar.le.real(Scalar2%scac)) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scai.le.Scalar2%scar) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scai.le.Scalar2%scai) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scai.le.real(Scalar2%scac)) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        If(real(Scalar1%scac).le.Scalar2%scar) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        If(real(Scalar1%scac).le.Scalar2%scai) MQC_ScalarLE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        If(real(Scalar1%scac).le.real(Scalar2%scac)) MQC_ScalarLE = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarLE', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarLE
!
!
!     PROCEDURE MQC_RealLEScalar
!
!>    \brief <b> MQC_RealLEScalar is a function that returns TRUE if an intrinsic real
!>    is less than or equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealLEScalar is a function that returns TRUE if an intrinsic real is less than or  
!>    equal to a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic real
!>    is less than or equal to the real part of the MQC_Scalar and FALSE if the intrinsic 
!>    real is greater than the real part of the MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealLEScalar(RealIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_RealLEScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_RealLEScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(RealIn.le.Scalar%scar) MQC_RealLEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(RealIn.le.Scalar%scai) MQC_RealLEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(RealIn.le.real(Scalar%scac)) MQC_RealLEScalar = .True. 
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_RealLEScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_RealLEScalar
!
!
!     PROCEDURE MQC_ScalarLEReal
!
!>    \brief <b> MQC_ScalarLEReal is a function that returns TRUE if a MQC_Scalar is less
!>    than or equal to an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarLEReal is a function that returns TRUE if a MQC_Scalar is less than or equal to
!>    an intrinsic real.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part of the 
!>    MQC_Scalar is less than or equal to the intrinsic real and FALSE if the real part of the 
!>    MQC_Scalar is greater than the intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=int64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarLEReal(Scalar,RealIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarLEReal
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarLEReal = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.le.RealIn) MQC_ScalarLEReal = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.le.RealIn) MQC_ScalarLEReal = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).le.RealIn) MQC_ScalarLEReal = .True. 
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarLEReal', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarLEReal
!
!
!     PROCEDURE MQC_IntegerLEScalar
!
!>    \brief <b> MQC_IntegerLEScalar is a function that returns TRUE if an intrinsic integer
!>    is less than or equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerLEScalar is a function that returns TRUE if an intrinsic integer is less 
!>    than or equal to a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic integer 
!>    is less than or equal to the real part of the MQC_Scalar and FALSE if the intrinsic 
!>    integer is greater than the real part of the MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerLEScalar(IntIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_IntegerLEScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_IntegerLEScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(IntIn.le.Scalar%scar) MQC_IntegerLEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(IntIn.le.Scalar%scai) MQC_IntegerLEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(IntIn.le.real(Scalar%scac)) MQC_IntegerLEScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_IntegerLEScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_IntegerLEScalar
!
!
!     PROCEDURE MQC_ScalarLEInteger
!
!>    \brief <b> MQC_ScalarLEInteger is a function that returns TRUE if a MQC_Scalar is less
!>    than or equal to an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarLEInteger is a function that returns TRUE if a MQC_Scalar is less than or 
!>    equal to an intrinsic integer.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part of the 
!>    MQC_Scalar is less than or equal to the intrinsic integer and FALSE if the real part 
!>    of the MQC_Scalar is greater than the intrinsic integer. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarLEInteger(Scalar,IntIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarLEInteger
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarLEInteger = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.le.IntIn) MQC_ScalarLEInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.le.IntIn) MQC_ScalarLEInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).le.IntIn) MQC_ScalarLEInteger = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarLEInteger', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarLEInteger
!
!
!     PROCEDURE MQC_ScalarGE
!
!>    \brief <b> MQC_ScalarGE is a function that returns TRUE if the left MQC_Scalar
!>    is greater than or equal the right MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarGE is a function that returns TRUE if the left MQC_Scalar is greater than or
!>    equal to the right MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the left real part is
!>    is greater than or equal to the right real part and FALSE if the left real part is less
!>    than the right real part.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim
!>        Scalar1 is Type(MQC_Scalar)
!>        The first MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The second MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_ScalarGE(Scalar1,Scalar2)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarGE
      Type(MQC_Scalar),Intent(In)::Scalar1,Scalar2
      Real::Zero=0.0d0
!
      MQC_ScalarGE = .False.
      If(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scar.ge.Scalar2%scar) MQC_ScalarGE = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scar.ge.Scalar2%scai) MQC_ScalarGE = .True.
      ElseIf(Scalar1%Data_type.eq.'Real'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scar.ge.real(Scalar2%scac)) MQC_ScalarGE = .True. 
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Real') then
        If(Scalar1%scai.ge.Scalar2%scar) MQC_ScalarGE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Integer') then
        If(Scalar1%scai.ge.Scalar2%scai) MQC_ScalarGE = .True.
      ElseIf(Scalar1%Data_type.eq.'Integer'.and.Scalar2%Data_type.eq.'Complex') then
        If(Scalar1%scai.ge.real(Scalar2%scac)) MQC_ScalarGE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Real') then
        If(real(Scalar1%scac).ge.Scalar2%scar) MQC_ScalarGE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Integer') then
        If(real(Scalar1%scac).ge.Scalar2%scai) MQC_ScalarGE = .True.
      ElseIf(Scalar1%Data_type.eq.'Complex'.and.Scalar2%Data_type.eq.'Complex') then
        If(real(Scalar1%scac).ge.real(Scalar2%scac)) MQC_ScalarGE = .True. 
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarGE', 6, &
             'Scalar1%Data_type', Scalar1%Data_type, &
             'Scalar2%Data_type', Scalar2%Data_type )
      EndIf
!
      Return
      End Function MQC_ScalarGE
!
!
!     PROCEDURE MQC_RealGEScalar
!
!>    \brief <b> MQC_RealGEScalar is a function that returns TRUE if an intrinsic real
!>    is greater than or equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>        
!>    MQC_RealGEScalar is a function that returns TRUE if an intrinsic real is greater 
!>    than or equal to a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic real
!>    is greater than or equal to the real part of the MQC_Scalar and FALSE if the intrinsic 
!>    real is less than the real part of the MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealGEScalar(RealIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_RealGEScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_RealGEScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(RealIn.ge.Scalar%scar) MQC_RealGEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(RealIn.ge.Scalar%scai) MQC_RealGEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(RealIn.ge.real(Scalar%scac)) MQC_RealGEScalar = .True. 
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_RealGEScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_RealGEScalar
!
!
!     PROCEDURE MQC_ScalarGEReal
!
!>    \brief <b> MQC_ScalarGEReal is a function that returns TRUE if a MQC_Scalar is
!>    greater than or equal to an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarGEReal is a function that returns TRUE if a MQC_Scalar is greater 
!>    than or equal to an intrinsic real.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part 
!>    of the MQC_Scalar is less than or equal to the intrinsic real and FALSE if the 
!>    real part of the MQC_Scalar is less than the intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=int64)
!>        The intrinsic real that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarGEReal(Scalar,RealIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarGEReal
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarGEReal = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.ge.RealIn) MQC_ScalarGEReal = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.ge.RealIn) MQC_ScalarGEReal = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).ge.RealIn) MQC_ScalarGEReal = .True. 
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarGEReal', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarGEReal
!
!
!     PROCEDURE MQC_IntegerGEScalar
!
!>    \brief <b> MQC_IntegerGEScalar is a function that returns TRUE if an intrinsic 
!>    integer is greater than or equal to a MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerGEScalar is a function that returns TRUE if an intrinsic integer is 
!>    greater than or equal to a MQC_Scalar. 
!>
!>    When dealing with complex numbers, the function returns TRUE if the intrinsic 
!>    integer is greater than or equal to the real part of the MQC_Scalar and FALSE 
!>    if the intrinsic integer is less than the real part of the MQC_Scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerGEScalar(IntIn,Scalar)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_IntegerGEScalar
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_IntegerGEScalar = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(IntIn.ge.Scalar%scar) MQC_IntegerGEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(IntIn.ge.Scalar%scai) MQC_IntegerGEScalar = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(IntIn.ge.real(Scalar%scac)) MQC_IntegerGEScalar = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_IntegerGEScalar', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_IntegerGEScalar
!
!
!     PROCEDURE MQC_ScalarGEInteger
!
!>    \brief <b> MQC_ScalarGEInteger is a function that returns TRUE if a MQC_Scalar 
!>    is greater than or equal to an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarGEInteger is a function that returns TRUE if a MQC_Scalar is greater 
!>    than or equal to an intrinsic integer.
!>
!>    When dealing with complex numbers, the function returns TRUE if the real part 
!>    of the MQC_Scalar is gretaer than or equal to the intrinsic integer and FALSE 
!>    if the real part of the MQC_Scalar is less than the intrinsic integer. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarGEInteger(Scalar,IntIn)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_ScalarGEInteger
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntIn
      Real(kind=real64)::Zero=0.0d0
!
      MQC_ScalarGEInteger = .False.
      If(Scalar%Data_type.eq.'Real') then
        If(Scalar%scar.ge.IntIn) MQC_ScalarGEInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Integer') then
        If(Scalar%scai.ge.IntIn) MQC_ScalarGEInteger = .True.
      ElseIf(Scalar%Data_type.eq.'Complex') then
        If(real(Scalar%scac).ge.IntIn) MQC_ScalarGEInteger = .True.
      Else
        Call MQC_Error_A('Scalar types unspecified in MQC_ScalarGEInteger', 6, &
             'Scalar%Data_type', Scalar%Data_type)
      EndIf
!
      Return
      End Function MQC_ScalarGEInteger
!
!
!     PROCEDURE MQC_Scalar_Complex_Conjugate
!
!>    \brief <b> MQC_Scalar_Complex_Conjugate is a function that returns the complex conjugate 
!>    of an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Complex_Conjugate is a function that returns the complex conjugate of an 
!>    MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC_Scalar input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2018
!
      Function MQC_Scalar_Complex_Conjugate(ScalarIn) Result(ScalarOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(In)::ScalarIn
      Type(MQC_Scalar)::ScalarOut
!
      If(ScalarIn%Data_Type.eq.'Complex') then
        ScalarOut = conjg(ScalarIn%ScaC)
      Else
        ScalarOut = ScalarIn
      EndIf
!
      Return
      End Function MQC_Scalar_Complex_Conjugate
!
!
!     PROCEDURE MQC_Scalar_Complex_RealPart
!
!>    \brief <b> MQC_Scalar_Complex_RealPart is a function that returns the real part
!>    of an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Complex_RealPart is a function that returns the real part of an
!>    MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC_Scalar input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_Complex_RealPart(ScalarIn) Result(ScalarOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(In)::ScalarIn
      Type(MQC_Scalar)::ScalarOut
      Real::Zero=0.0d0
!
      ScalarOut = Zero
      If(ScalarIn%Data_Type.eq.'Complex') then
        ScalarOut = real(ScalarIn%ScaC)
      Else
        ScalarOut = ScalarIn
      EndIf
!
      Return
      End Function MQC_Scalar_Complex_RealPart
!
!
!     PROCEDURE MQC_Scalar_Complex_ImagPart
!
!>    \brief <b> MQC_Scalar_Complex_ImagPart is a function that returns the inaginary part
!>    of an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Complex_RealPart is a function that returns the imaginary part of an
!>    MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC_Scalar input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Scalar_Complex_ImagPart(ScalarIn) Result(ScalarOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(In)::ScalarIn
      Type(MQC_Scalar)::ScalarOut
      Real(kind=real64)::Zero=0.0d0
!
      ScalarOut = zero
      If(ScalarIn%Data_Type.eq.'Complex') ScalarOut = aimag(ScalarIn%ScaC)
!
      Return
      End Function MQC_Scalar_Complex_ImagPart
!
!
!     PROCEDURE MQC_IntegerScalarMultiply
!
!>    \brief <b> MQC_IntegerScalarMultiply is a function that is used to multiply an intrinsic
!>    integer by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerScalarMultiply is a function that is used to multiply an intrinsic integer by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer variable to multiply.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerScalarMultiply(IntegerIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Temp*Scalar

      Return
      End Function MQC_IntegerScalarMultiply
!
!
!     PROCEDURE MQC_ScalarIntegerMultiply
!
!>    \brief <b> MQC_ScalarIntegerMultiply is a function that is used to multiply an intrinsic
!>    integer by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarIntegerMultiply is a function that is used to multiply an intrinsic integer by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer variable to multiply.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar varibale to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarIntegerMultiply(Scalar,IntegerIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Scalar*Temp

      Return
      End Function MQC_ScalarIntegerMultiply
!
!
!     PROCEDURE MQC_RealScalarMultiply
!
!>    \brief <b> MQC_RealScalarMultiply is a function that is used to multiply an intrinsic
!>    real by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealScalarMultiply is a function that is used to multiply an intrinsic real by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] realIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real variable to multiply.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealScalarMultiply(RealIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Temp*Scalar

      Return
      End Function MQC_RealScalarMultiply
!
!
!     PROCEDURE MQC_ScalarRealMultiply
!
!>    \brief <b> MQC_ScalarRealMultiply is a function that is used to multiply an intrinsic
!>    real by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarRealMultiply is a function that is used to multiply an intrinsic real by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] realIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real variable to multiply.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarRealMultiply(Scalar,RealIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Scalar*Temp

      Return
      End Function MQC_ScalarRealMultiply
!
!
!     PROCEDURE MQC_ComplexScalarMultiply
!
!>    \brief <b> MQC_ComplexScalarMultiply is a function that is used to multiply an intrinsic
!>    complex by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexScalarMultiply is a function that is used to multiply an intrinsic complex by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        Complex is Complex(kind=real64)
!>        The intrinsic complex variable to multiply.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variabel to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ComplexScalarMultiply(ComplexIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Temp*Scalar

      Return
      End Function MQC_ComplexScalarMultiply
!
!
!     PROCEDURE MQC_ScalarComplexMultiply
!
!>    \brief <b> MQC_ScalarComplexMultiply is a function that is used to multiply an intrinsic
!>    complex by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarComplexMultiply is a function that is used to multiply an intrinsic complex by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        Complex is Complex(kind=real64)
!>        The intrinsic complex variable to multiply.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variabel to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarComplexMultiply(Scalar,ComplexIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Scalar*Temp

      Return
      End Function MQC_ScalarComplexMultiply
!
!
!     PROCEDURE MQC_IntegerScalarDivide  
!
!>    \brief <b> MQC_IntegerScalarDivide is a function that is used to divide an intrinsic
!>    integer by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerScalarDivide is a function that is used to divide an intrinsic integer by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer variable numerator.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerScalarDivide(IntegerIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Temp/Scalar

      Return
      End Function MQC_IntegerScalarDivide
!
!
!     PROCEDURE MQC_ScalarIntegerDivide
!
!>    \brief <b> MQC_ScalarIntegerDivide is a function that is used to divide an MQC_Scalar by
!>    an intrinsic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarIntegerDivide is a function that is used to divide an MQC_Scalar by an 
!>    intrinsic integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable numerator.
!>    \endverbatim
!>
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer variable denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarIntegerDivide(Scalar,IntegerIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Scalar/Temp

      Return
      End Function MQC_ScalarIntegerDivide
!
!
!     PROCEDURE MQC_RealScalarDivide
!
!>    \brief <b> MQC_RealScalarDivide is a function that is used to divide an intrinsic
!>    real by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealScalarDivide is a function that is used to divide an intrinsic real by an
!>    MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real variable numerator.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealScalarDivide(RealIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Temp/Scalar

      Return
      End Function MQC_RealScalarDivide
!
!
!     PROCEDURE MQC_ScalarRealDivide
!
!>    \brief <b> MQC_ScalarRealDivide is a function that is used to divide an MQC_Scalar by
!>    an intrinsic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarRealDivide is a function that is used to divide an MQC_Scalar by an 
!>    intrinsic real. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable numerator.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real variable denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarRealDivide(Scalar,RealIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Scalar/Temp

      Return
      End Function MQC_ScalarRealDivide
!
!
!     PROCEDURE MQC_ComplexScalarDivide
!
!>    \brief <b> MQC_ComplexScalarDivide is a function that is used to divide an intrinsic
!>    complex by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexScalarDivide is a function that is used to divide an intrinsic complex by an
!>    MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Complex(kind=real64)
!>        The intrinsic complex variable numerator.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ComplexScalarDivide(ComplexIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Temp/Scalar

      Return
      End Function MQC_ComplexScalarDivide
!
!
!     PROCEDURE MQC_ScalarComplexDivide
!
!>    \brief <b> MQC_ScalarComplexDivide is a function that is used to divide an MQC_Scalar by
!>    an intrinsic complex</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarComplexDivide is a function that is used to divide an MQC_Scalar by an 
!>    intrinsic complex. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable numerator.
!>    \endverbatim
!>
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Complex(kind=real64)
!>        The intrinsic complex variable denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarComplexDivide(Scalar,ComplexIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Scalar/Temp

      Return
      End Function MQC_ScalarComplexDivide
!
!
!     PROCEDURE MQC_IntegerScalarAdd
!
!>    \brief <b> MQC_IntegerScalarAdd is a function that is used to multiply an intrinsic
!>    integer by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerScalarAdd is a function that is used to sum an intrinsic integer by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer variable to sum.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerScalarAdd(IntegerIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Temp+Scalar

      Return
      End Function MQC_IntegerScalarAdd
!
!
!     PROCEDURE MQC_ScalarIntegerAdd
!
!>    \brief <b> MQC_ScalarIntegerAdd is a function that is used to sum an intrinsic
!>    integer by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarIntegerSum is a function that is used to sum an intrinsic integer by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer variable to sum.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar varibale to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarIntegerAdd(Scalar,IntegerIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Scalar+Temp

      Return
      End Function MQC_ScalarIntegerAdd
!
!
!     PROCEDURE MQC_RealScalarAdd
!
!>    \brief <b> MQC_RealScalarAdd is a function that is used to sum an intrinsic
!>    real by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealScalarAdd is a function that is used to sum an intrinsic real by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] realIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real variable to sum.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealScalarAdd(RealIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Temp+Scalar

      Return
      End Function MQC_RealScalarAdd
!
!
!     PROCEDURE MQC_ScalarRealAdd
!
!>    \brief <b> MQC_ScalarRealAdd is a function that is used to sum an intrinsic
!>    real by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarRealSum is a function that is used to sum an intrinsic real by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] realIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real variable to sum.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarRealAdd(Scalar,RealIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Scalar+Temp

      Return
      End Function MQC_ScalarRealAdd
!
!
!     PROCEDURE MQC_ComplexScalarAdd
!
!>    \brief <b> MQC_ComplexScalarAdd is a function that is used to sum an intrinsic
!>    complex by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexScalarAdd is a function that is used to sum an intrinsic complex by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        Complex is Complex(kind=real64)
!>        The intrinsic complex variable to sum.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variabel to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ComplexScalarAdd(ComplexIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Temp+Scalar

      Return
      End Function MQC_ComplexScalarAdd
!
!
!     PROCEDURE MQC_ScalarComplexAdd
!
!>    \brief <b> MQC_ScalarComplexAdd is a function that is used to sum an intrinsic
!>    complex by an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarComplexAdd is a function that is used to sum an intrinsic complex by
!>    an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        Complex is Complex(kind=real64)
!>        The intrinsic complex variable to sum.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variabel to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarComplexAdd(Scalar,ComplexIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Scalar+Temp

      Return
      End Function MQC_ScalarComplexAdd
!
!
!     PROCEDURE MQC_IntegerScalarSubtract
!
!>    \brief <b> MQC_IntegerScalarSubtract is a function that is used to subtract an MQC_Scalar
!>    from an intrinisic integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerScalarSubtract is a function that is used to subtract an MQC_Scalar from an
!>    intrinisic integer. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer to subtract from.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to subtract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerScalarSubtract(IntegerIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Temp-Scalar

      Return
      End Function MQC_IntegerScalarSubtract
!
!
!     PROCEDURE MQC_ScalarIntegerSubtract
!
!>    \brief <b> MQC_ScalarIntegerSubtract is a function that is used to subtract an intrinsic
!>    integer from an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarIntegerSubtract is a function that is used to subtract an intrinsic integer
!>    from an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to subtract from.
!>    \endverbatim
!>
!>    \param[in] IntegerIn
!>    \verbatim
!>        IntegerIn is Integer(kind=int64)
!>        The intrinsic integer to subtract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarIntegerSubtract(Scalar,IntegerIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64),Intent(In)::IntegerIn
      Type(MQC_Scalar)::Temp

      Temp = IntegerIn
      Output = Scalar-Temp

      Return
      End Function MQC_ScalarIntegerSubtract
!
!
!     PROCEDURE MQC_RealScalarSubtract
!
!>    \brief <b> MQC_RealScalarSubtract is a function that is used to subtract an MQC_Scalar
!>    from an intrinisic real</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealScalarSubtract is a function that is used to subtract an MQC_Scalar from an
!>    intrinisic real. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real to subtract from.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to subtract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealScalarSubtract(RealIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Temp-Scalar

      Return
      End Function MQC_RealScalarSubtract
!
!
!     PROCEDURE MQC_ScalarRealSubtract
!
!>    \brief <b> MQC_ScalarRealSubtract is a function that is used to subtract an intrinsic
!>    real from an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarRealSubtract is a function that is used to subtract an intrinsic real from an
!>    MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to subtract from.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real to subtract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarRealSubtract(Scalar,RealIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Scalar)::Temp

      Temp = RealIn
      Output = Scalar-Temp

      Return
      End Function MQC_ScalarRealSubtract
!
!
!     PROCEDURE MQC_ComplexScalarSubtract
!
!>    \brief <b> MQC_ComplexScalarSubtract is a function that is used to subtract an MQC_Scalar
!>    from an intrinisic complex</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexScalarSubtract is a function that is used to subtract an MQC_Scalar from an
!>    intrinisic complex. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Complex(kind=real64)
!>        The intrinsic complex to subtract from.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to subtract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ComplexScalarSubtract(ComplexIn,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Temp-Scalar

      Return
      End Function MQC_ComplexScalarSubtract
!
!
!     PROCEDURE MQC_ScalarComplexSubtract
!
!>    \brief <b> MQC_ScalarComplexSubtract is a function that is used to subtract an intrinsic
!>    complex from an MQC_Scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarComplexSubtract is a function that is used to subtract an intrinsic complex
!>    from an MQC_Scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim 
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar variable to subtract from.
!>    \endverbatim
!>
!>    \param[in] ComplexIn
!>    \verbatim
!>        ComplexIn is Complex(kind=real64)
!>        The intrinsic complex to subtract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ScalarComplexSubtract(Scalar,ComplexIn) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Type(MQC_Scalar),Intent(In)::Scalar
      Complex(kind=real64),Intent(In)::ComplexIn
      Type(MQC_Scalar)::Temp

      Temp = ComplexIn
      Output = Scalar-Temp

      Return
      End Function MQC_ScalarComplexSubtract
!
!
!     PROCEDURE MQC_Scalar_Sign
!
!>    \brief <b> MQC_Scalar_Sign returns the absolute value of the first argument
!>    times the sign of the second argument</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Scalar_Sign returns the absolute value of the first argument times the sign 
!>    of the second argument.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar1
!>    \verbatim 
!>        Scalar1 is Type(MQC_Scalar)
!>        The MQC_Scalar to take the absolute value from.
!>    \endverbatim
!>
!>    \param[in] Scalar2
!>    \verbatim
!>        Scalar2 is Type(MQC_Scalar)
!>        The MQC_Scalar to take the sign from.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_Scalar_Sign(Scalar1,Scalar2) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar)::Output
      Class(*),Intent(In)::Scalar1,Scalar2
      Type(MQC_Scalar)::ScalarA,ScalarB

      Select Type (Scalar1)
      Type Is (Integer)
        ScalarA = Scalar1
      Type Is (Real)
        ScalarA = Scalar1
      Type Is (Complex)
        ScalarA = Scalar1
      Type Is (MQC_Scalar)
        ScalarA = Scalar1
      Class Default
        Call MQC_Error_I('Scalar1 type not defined in MQC_Scalar_Sign',6)
      End Select
      Select Type (Scalar2)
      Type Is (Integer)
        ScalarB = Scalar2
      Type Is (Real)
        ScalarB = Scalar2
      Type Is (Complex)
        ScalarB = Scalar2
      Type Is (MQC_Scalar)
        ScalarB = Scalar2
      Class Default
        Call MQC_Error_I('Scalar2 type not defined in MQC_Scalar_Sign',6)
      End Select

      If(ScalarB.ge.0) then
        Output = abs(ScalarA)
      Else
        Output = (-1)*abs(ScalarA)
      EndIf

      Return
      End Function MQC_Scalar_Sign
!
!     PROCEDURE mqcscalar2character
!
!>    \brief <b> MQCscalar2Character converts an mqc scalar variable into a character 
!>    string</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQCscalar2Character converts an mqc scalar variable into a character string. The
!>    input dummy argument <formatString> is OPTIONAL and can be sent to specify then
!>    desired formatting of the realIn. Note that <formatString> must conform to 
!>    standard fortran requirments.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar) 
!>        The input variable to be converted.
!>    \endverbatim
!>
!>    \param[in] formatString
!>    \verbatim
!>        FormatString is Character(len=*),Optional 
!>        The format statement for the output string.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      function mqcscalar2character(scalarIn,formatString) result(scalarString)
!
      implicit none
      type(mqc_scalar),intent(in)::scalarIn
      character(len=*),intent(in),optional::formatString
      character(len=256)::myFormatString,inputString,scalarString
      class(*),allocatable::tempScalar
      integer::query,tempint
      real(kind=real64)::tempreal
      complex(kind=real64)::tempcomp
!
      if(present(formatString)) then
        myformatstring = '('//trim(formatstring)//')'
        inputString = trim(integer2character(scalarIn%ival()))
        read(inputString,myformatstring,iostat=query) tempint
        if(query.ne.0) then
          if(mqc_have_int(scalarIn).or.mqc_have_real(scalarIn)) then
            inputString = trim(real2character(scalarIn%rval()))
            read(inputString,myformatstring,iostat=query) tempreal
            if(query.ne.0) then
              call mqc_error_a('Badly specified format statement in mqcscalar2character',6,&
                'formatString',formatString)
            else
              scalarString = real2character(scalarIn%rval(),myformatstring)
            endIf
          elseIf(mqc_have_complex(scalarIn)) then
            inputString = trim(real2character(real(scalarIn%cval())))
            read(inputString,myformatstring,iostat=query) tempreal
            if(query.ne.0) then
              call mqc_error_a('Badly specified format statement in mqcscalar2character',6,&
                'formatString',formatString)
            else
              inputString = trim(real2character(aimag(scalarIn%cval())))
              read(inputString,myformatstring,iostat=query) tempreal
              if(query.ne.0) then
                call mqc_error_a('Badly specified format statement in mqcscalar2character',6,&
                  'formatString',formatString)
              else
                scalarString = complex2character(scalarIn%cval(),myformatstring)
              endIf
            endIf
          else
            call mqc_error('Scalar type unrecognized in mqcscalar2character')
          endIf
        else
          scalarString = integer2character(scalarIn%ival(),myformatstring)
        endIf
      else
        if(mqc_have_int(scalarIn)) then
          scalarString = integer2character(scalarIn%ival())
        elseIf(mqc_have_real(scalarIn)) then
          scalarString = real2character(scalarIn%rval())
        elseIf(mqc_have_complex(scalarIn)) then
          scalarString = complex2character(scalarIn%cval())
        else
          call mqc_error_l('ScalarIn argument not assigned',6,'mqc_have_int(scalarIn)',&
            mqc_have_int(scalarIn),'mqc_have_real(scalarIn)',mqc_have_real(scalarIn),&
            'mqc_have_complex(scalarIn)',mqc_have_complex(scalarIn))
        endIf
      endIf
!
      return
      end function mqcscalar2character
!
!----------------------------------------------------------------
!                                                               |
!     VECTOR PROCEDURES                                         |
!                                                               |
!----------------------------------------------------------------
!
!     PROCEDURE MQC_Allocate_Vector
!
!>    \brief <b> MQC_Allocate_Vector is used to allocate a vector type variable
!>    of the MQC_Vector class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Allocate_Vector is a subroutine used to allocate a vector type variable
!>    of the MQC_Vector class. The following options are available:
!>
!>    1. Data_Type = 'Real' declares the MQC_Vector variable to be of real type. 
!>    2. Data_Type = 'Integer' declares the MQC_Vector variable to be of integer type.
!>    3. Data_Type = 'Complex' declares the MQC_Vector variable to be of complex type.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] N 
!>    \verbatim
!>        N is Integer(kind=int64)
!>        The length of the MQC_Vector variable
!>    \endverbatim
!>
!>    \param[in,out] Vector 
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The name of the MQC_Vector variable
!>    \endverbatim
!>
!>    \param[in] Data_Type
!>    \verbatim
!>        Data_Type is Character(Len=*)
!>        = 'Real':    the MQC_Vector is real
!>        = 'Integer': the MQC_Vector is integer
!>        = 'Complex': the MQC_Vector is complex
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Subroutine MQC_Allocate_Vector(N,Vector,Data_Type)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::N
      Character(Len=*),Intent(In)::Data_Type
      Type(MQC_Vector),Intent(InOut)::Vector
!
      Call MQC_Deallocate_Vector(Vector)
      If(Data_Type.eq.'Integer' .or. Data_Type.eq.'integer' .or. Data_Type.eq.'Int' .or. Data_Type.eq.'int') then
        Vector%Data_Type = 'Integer'
        If(Allocated(Vector%veci)) DeAllocate(Vector%veci)
        Allocate(Vector%veci(N))
      ElseIf(Data_Type.eq.'Real' .or. Data_Type.eq.'real') then
        Vector%Data_Type = 'Real'
        If(Allocated(Vector%vecr)) DeAllocate(Vector%vecr)
        Allocate(Vector%vecr(N))
      ElseIf(Data_Type.eq.'Complex' .or. Data_Type.eq.'complex') then
        Vector%Data_Type = 'Complex'
        If(Allocated(Vector%vecc)) DeAllocate(Vector%vecc)
        Allocate(Vector%vecc(N))
      else
        call MQC_Error('Unknown Data_Type sent to MQC_Allocate_Vector.')
      EndIf
      Vector%Length = N
      Vector%Column = .True.
!
      Return
      End Subroutine MQC_Allocate_Vector
!
!
!     PROCEDURE MQC_Deallocate_Vector
!
!>    \brief <b> MQC_Deallocate_Vector is used to deallocate a vector type variable
!>    of the MQC_Vector class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Deallocate_Vector is a subroutine used to deallocate a vector type variable
!>    of the MQC_Vector class. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The name of the MQC_Vector variable to deallocate.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Subroutine MQC_Deallocate_Vector(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(InOut)::Vector
!
      If(Allocated(Vector%veci)) DeAllocate(Vector%veci)
      If(Allocated(Vector%vecr)) DeAllocate(Vector%vecr)
      If(Allocated(Vector%vecc)) DeAllocate(Vector%vecc)
      Vector%Data_Type = ''
      Vector%Length = 0
      Vector%Column = .True.
!
      Return
      End Subroutine MQC_Deallocate_Vector
!
!
!     PROCEDURE MQC_Length_Vector
!
!>    \brief <b> MQC_Length_Vector is used to return the length of an MQC vector</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Length_Vector is used to return the length of an MQC vector. If the vector
!>    vector is NOT allocated, the length is returned as 0. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The name of the MQC_Vector variable whose length will be returned. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Function MQC_Length_Vector(Vector) Result(ValueOut)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Vector)::Vector
      Integer(kind=int64)::ValueOut
!
      ValueOut = Vector%Length
!
      Return
      End Function MQC_Length_Vector
!
!
!     PROCEDURE MQC_Vector_HaveReal
!
!>    \brief <b> MQC_Vector_HaveReal is a function that returns TRUE or FALSE 
!>    indicating whether the MQC vector has an allocated real vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_HaveReal is a function that returns TRUE or FALSE indicating 
!>    whether the MQC vector has an allocated real vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Function MQC_Vector_HaveReal(Vector)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Vector_HaveReal
      Type(MQC_Vector),Intent(In)::Vector
!
      MQC_Vector_HaveReal = Allocated(Vector%vecr)
!
      Return
      End Function MQC_Vector_HaveReal
!
!
!     PROCEDURE MQC_Vector_HaveInteger
!
!>    \brief <b> MQC_Vector_HaveInteger is a function that returns TRUE or FALSE 
!>    indicating whether the MQC vector has an allocated integer vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_HaveInteger is a function that returns TRUE or FALSE indicating 
!>    whether the MQC vector has an allocated integer vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Function MQC_Vector_HaveInteger(Vector)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Vector_HaveInteger
      Type(MQC_Vector),Intent(In)::Vector
!
      MQC_Vector_HaveInteger = Allocated(Vector%veci)
!
      Return
      End Function MQC_Vector_HaveInteger
!
!
!     PROCEDURE MQC_Vector_HaveComplex
!
!>    \brief <b> MQC_Vector_HaveComplex is a function that returns TRUE or FALSE 
!>    indicating whether the MQC vector has an allocated complex vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_HaveComplex is a function that returns TRUE or FALSE indicating 
!>    whether the MQC vector has an allocated complex vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2017
!
      Function MQC_Vector_HaveComplex(Vector)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Vector_HaveComplex
      Type(MQC_Vector),Intent(In)::Vector
!
      MQC_Vector_HaveComplex = Allocated(Vector%vecc)
!
      Return
      End Function MQC_Vector_HaveComplex
!
!
!     PROCEDURE MQC_Vector_IsColumn
!
!>    \brief <b> MQC_Vector_IsColumn is a function that returns TRUE if the MQC 
!>    vector is a column vector and FALSE if the MQC vector is a row vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_IsColumn is a function that returns TRUE if the MQC vector is a
!>    column vector and FALSE if the MQC vector is a row vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2016
!
      Function MQC_Vector_IsColumn(Vector)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Vector_IsColumn
      Type(MQC_Vector),Intent(In)::Vector
!
      MQC_Vector_IsColumn = Vector%Column
!
      Return
      End Function MQC_Vector_IsColumn
!
!
!     PROCEDURE MQC_Vector_Copy_Int2Real
!
!>    \brief <b> MQC_Vector_Copy_Int2Real is a subroutine that copies an integer 
!>    MQC_Vector into its real vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Copy_Int2Real is a subroutine that copies an integer MQC_Vector 
!>    into its real vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Subroutine MQC_Vector_Copy_Int2Real(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::Vector
      Real(kind=real64),Dimension(:),Allocatable::temp
!     
      temp = Vector%veci
      Call MQC_Allocate_Vector(MQC_Length_Vector(Vector),Vector,  &
        'Real')
      Vector%vecr = temp
      if(allocated(temp)) deallocate(temp)
!
      Return
      End Subroutine MQC_Vector_Copy_Int2Real
!
!
!     PROCEDURE MQC_Vector_Copy_Int2Complex
!
!>    \brief <b> MQC_Vector_Copy_Int2Complex is a subroutine that copies an integer 
!>    MQC_Vector into its complex vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Copy_Int2Complex is a subroutine that copies an integer MQC_Vector 
!>    into its complex vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Copy_Int2Complex(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::Vector
      Complex(kind=real64),Dimension(:),Allocatable::temp
!
      temp = cmplx(Vector%veci,0)
      Call MQC_Allocate_Vector(MQC_Length_Vector(Vector),Vector,  &
        'Complex')
      Vector%vecc = temp
      if(allocated(temp)) deallocate(temp)
!
      Return
      End Subroutine MQC_Vector_Copy_Int2Complex
!
!
!     PROCEDURE MQC_Vector_Copy_Real2Int
!
!>    \brief <b> MQC_Vector_Copy_Real2Int is a subroutine that copies a real 
!>    MQC_Vector into its integer vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Copy_Real2Int is a subroutine that copies a real MQC_Vector into its
!>    integer vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Vector_Copy_Real2Int(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::Vector
      Integer(kind=int64),Dimension(:),Allocatable::temp
!
      temp = Vector%vecr
      Call MQC_Allocate_Vector(MQC_Length_Vector(Vector),Vector,  &
        'Integer')
      Vector%veci = temp
      if(allocated(temp)) deallocate(temp)
!
      Return
      End Subroutine MQC_Vector_Copy_Real2Int
!
!
!     PROCEDURE MQC_Vector_Copy_Real2Complex
!
!>    \brief <b> MQC_Vector_Copy_Real2Complex is a subroutine that copies a 
!>    real MQC_Vector into its complex vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Copy_Real2Complex is a subroutine that copies a real MQC_Vector
!>    into its complex vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Copy_Real2Complex(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::Vector
      Complex(kind=real64),Dimension(:),Allocatable::temp


      temp = cmplx(Vector%vecr,0.0)
      Call MQC_Allocate_Vector(MQC_Length_Vector(Vector),Vector,  &
        'Complex')
      Vector%vecc = temp
      if(allocated(temp)) deallocate(temp)
!
      Return
      End Subroutine MQC_Vector_Copy_Real2Complex
!
!
!     PROCEDURE MQC_Vector_Copy_Complex2Int
!
!>    \brief <b> MQC_Vector_Copy_Complex2Int is a subroutine that copies a 
!>    complex MQC_Vector into its integer vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Copy_Complex2Int is a subroutine that copies a complex MQC_Vector
!>    into its integer vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Copy_Complex2Int(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::Vector
      Integer(kind=int64),Dimension(:),Allocatable::temp
!
      temp = real(Vector%vecc)
      Call MQC_Allocate_Vector(MQC_Length_Vector(Vector),Vector,  &
        'Integer')
      Vector%veci = temp
      if(allocated(temp)) deallocate(temp)
!
      Return
      End Subroutine MQC_Vector_Copy_Complex2Int
!
!
!     PROCEDURE MQC_Vector_Copy_Complex2Real
!
!>    \brief <b> MQC_Vector_Copy_Complex2Real is a subroutine that copies a 
!>    complex MQC_Vector into its real vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Copy_Complex2Real is a subroutine that copies a complex MQC_Vector
!>    into its real vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Copy_Complex2Real(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::Vector
      Real(kind=real64),Dimension(:),Allocatable::temp
!
      temp = real(Vector%vecc)
      Call MQC_Allocate_Vector(MQC_Length_Vector(Vector),Vector,  &
        'Real')
      Vector%vecr = temp
      if(allocated(temp)) deallocate(temp)
!
      Return
      End Subroutine MQC_Vector_Copy_Complex2Real
!
!
!     PROCEDURE MQC_Vector_Scalar_At_Scalar
!
!>    \brief <b> MQC_Vector_Scalar_At_Scalar is a function that returns the ith 
!>    element of a MQC vector as an MQC scalar using an MQC Scalar index</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Scalar_At_Scalar is a function that returns the ith element of a MQC 
!>    vector as an MQC scalar using an MQC Scalar index. If the location of the 
!>    element is negative the it is counted from the end of MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vec
!>    \verbatim
!>        Vec is Class(MQC_Vector)
!>        The MQC_Vector to extract the Ith element.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Type(MQC_Scalar)
!>        The location of the element in Vec to return. If I is 
!>        negative it is counted from the last element of Vec.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_Vector_Scalar_At_Scalar(Vec,I) Result(Element)
!
      Implicit None
      Class(MQC_Vector)::Vec
      Type(MQC_Scalar),Intent(In)::I
      Type(MQC_Scalar)::Element
      Integer(kind=int64)::IndI

      IndI = I
      Element = MQC_Vector_Scalar_At_Int(Vec,IndI) 

      End Function MQC_Vector_Scalar_At_Scalar
!
!
!     PROCEDURE MQC_Vector_Scalar_At_Int
!
!>    \brief <b> MQC_Vector_Scalar_At_Int is a function that returns the ith element 
!>    of a MQC vector as an MQC scalar using an integer index</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Scalar_At_Int is a function that returns the ith element of a MQC 
!>    vector as an MQC scalar using an integer index. If the location of the element 
!>    is negative the it is counted from the end of MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vec
!>    \verbatim
!>        Vec is Class(MQC_Vector)
!>        The MQC_Vector to extract the Ith element.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer
!>        The location of the element in Vec to return. If I is 
!>        negative it is counted from the last element of Vec.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng 
!>    \date 2017
!
      Function MQC_Vector_Scalar_At_Int(Vec,I) Result(Element)
!
      Implicit None
      Class(MQC_Vector)::Vec
      Integer,Intent(In)::I
      Type(MQC_Scalar)::Element
      Integer(kind=int64)::IndI

      IndI = I

      If(IndI.lt.0) IndI = Vec%Length + IndI + 1
      If (IndI.gt.Vec%Length.or.IndI.eq.0) Call MQC_Error_I('Index out of bounds in MQC_Vector_Scalar_At', 6, &
           'Vec%Length', Vec%Length, &
           'IndI', IndI )
      If (Vec%Data_Type.eq.'Integer') then
        Element = (Vec%VecI(IndI))
      ElseIf (Vec%Data_Type.eq.'Real') then
        Element = (Vec%VecR(IndI))
      ElseIf (Vec%Data_Type.eq.'Complex') then
        Element = (Vec%VecC(IndI))
      Else
        Call MQC_Error_A('Vector type not defined in MQC_Vector_Scalar_At', 6, &
             'Vec%Data_Type', Vec%Data_Type )
      EndIf

      End Function
!
!
!     PROCEDURE MQC_Vector_Vector_At
!
!>    \brief <b> MQC_Vector_Vector_At is a function that returns the vector at
!>    the specified subvector of MQC_Vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Vector_At is a function that returns the vector at the specified 
!>    subvector of MQC_Vector. Negative values of I or J indicate that counting 
!>    proceeds from the last element rather than the first as with positive numbers.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vec
!>    \verbatim
!>        Vec is Class(MQC_Vector)
!>        The MQC_Vector from which the subvector will be extracted.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer(kind=int64)
!>        The location of the first subvector element in Vec. If I 
!>        is negative it is counted from the last element of Vec.
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Integer(kind=int64),Optional
!>        The location of the last subvector element in Vec. If J 
!>        is negative it is counted from the last element of Vec.
!>        If J is not specified, it defaults to the last element
!>        of the vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_Vector_At(Vec,I,J) Result(Vector)
!
      Implicit None
      Class(MQC_Vector)::Vec
      Type(MQC_Vector)::Vector
      Integer(kind=int64),Intent(In)::I
      Integer(kind=int64),Optional,Intent(In)::J
      Integer(kind=int64)::Length,IndI,IndJ

      IndI = I
      If(Present(J)) then
        IndJ = J
      Else
        IndJ = Vec%Length
      EndIf
      If (IndI.lt.0) IndI = Vec%Length + IndI + 1
      If (IndJ.lt.0) IndJ = Vec%Length + IndJ + 1
      If (IndI.eq.0) then
        IndI = 1
        If(Present(J)) Call MQC_Error_L('Vector length badly defined in MQC_Vector_Vector_At', 6, &
             'Present(J)', Present(J) )
        IndJ = Vec%Length
      EndIf

      Length = IndJ-IndI+1
      If (Length.le.0.or.Length.gt.Vec%Length) Call MQC_Error_I('Vector length badly &
     &   defined in MQC_Vector_Vector_At', 6, &
     'Length', Length, &
     'Vec%Length', Vec%Length )
      If (IndI.le.0.or.IndI.gt.(Vec%Length-Length+1)) Call MQC_Error_I('Index I out of bounds &
     &   in MQC_Vector_Vector_At', 6, &
     'IndI', IndI, &
     'Vec%Length', Vec%Length, &
     'Length', Length )
      If (IndJ.lt.Length.or.IndJ.gt.Vec%Length) Call MQC_Error_I('Index J out of bounds &
     &   in MQC_Vector_Vector_At', 6, &
     'IndJ', IndJ, &
     'Length', Length, &
     'Vec%Length', Vec%Length )
      If (Vec%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Vector(Length,Vector,'Integer')
        Vector%VecI = (Vec%VecI(IndI:IndJ))
      ElseIf (Vec%Data_Type.eq.'Real') then
        Call MQC_Allocate_Vector(Length,Vector,'Real')
        Vector%VecR = (Vec%VecR(IndI:IndJ))
      ElseIf (Vec%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Vector(Length,Vector,'Complex')
        Vector%VecC = (Vec%VecC(IndI:IndJ))
      Else
        Call MQC_Error_A('Vector type not defined in MQC_Vector_Vector_At', 6, &
             'Vec%Data_Type', Vec%Data_Type )
      EndIf
      Vector%Column = Vec%Column

      End Function

!
!
!     PROCEDURE MQC_Vector_Integer_Get_Array
!
!>    \brief <b> MQC_Vector_Integer_Get_Array is a function that returns the VecI variable
!>    of a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Integer_Get_Array is a function that returns the VecI variable of a MQC 
!>    vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vec
!>    \verbatim
!>        Vec is Class(MQC_Vector)
!>        The MQC_Vector to extract the VecI variable.
!>    \endverbatim
!>
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2025
!
      Function MQC_Vector_Integer_Get_Array(Vec) Result(ArrayOut)
!
      Implicit None 
      Class(MQC_Vector)::Vec
      Integer(kind=int64),Dimension(:),Allocatable::ArrayOut

      if (Vec%Data_Type.eq.'Integer') then
        ArrayOut = Vec%VecI
      else
        Call MQC_Error_A('Vector is not an Integer Data_Type in MQC_Vector_Integer_Get_Array', 6, &
             'Vec%Data_Type', Vec%Data_Type )
      EndIf
      End Function MQC_Vector_Integer_Get_Array
!
!
!     PROCEDURE MQC_Vector_Real_Get_Array
!
!>    \brief <b> MQC_Vector_Real_Get_Array is a function that returns the VecR variable
!>    of a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Real_Get_Array is a function that returns the VecR variable of a MQC 
!>    vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vec
!>    \verbatim
!>        Vec is Class(MQC_Vector)
!>        The MQC_Vector to extract the VecR variable.
!>    \endverbatim
!>
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2025
!
      Function MQC_Vector_Real_Get_Array(Vec) Result(ArrayOut)
!
      Implicit None
      Class(MQC_Vector)::Vec
      Real(kind=real64),Dimension(:),Allocatable::ArrayOut

      if (Vec%Data_Type.eq.'Real') then
        ArrayOut = Vec%VecR
      else
        Call MQC_Error_A('Vector is not a Real Data_Type in MQC_Vector_Real_Get_Array', 6, &
             'Vec%Data_Type', Vec%Data_Type )
      EndIf
      End Function MQC_Vector_Real_Get_Array
!
!
!     PROCEDURE MQC_Vector_Complex_Get_Array
!
!>    \brief <b> MQC_Vector_Complex_Get_Array is a function that returns the VecC variable
!>    of a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Complex_Get_Array is a function that returns the VecC variable of a MQC 
!>    vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vec
!>    \verbatim
!>        Vec is Class(MQC_Vector)
!>        The MQC_Vector to extract the VecC variable.
!>    \endverbatim
!>
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2025
!
      Function MQC_Vector_Complex_Get_Array(Vec) Result(ArrayOut)
!
      Implicit None
      Class(MQC_Vector)::Vec
      Complex(kind=real64),Dimension(:),Allocatable::ArrayOut

      if (Vec%Data_Type.eq.'Complex') then
        ArrayOut = Vec%VecC
      else
        Call MQC_Error_A('Vector is not a Complex Data_Type in MQC_Vector_Complex_Get_Array', 6, &
             'Vec%Data_Type', Vec%Data_Type )
      EndIf
      End Function MQC_Vector_Complex_Get_Array
 
!
!
!     PROCEDURE MQC_Set_Vector2IntegerArray
!
!>    \brief <b> MQC_Set_Vector2IntegerArray is a subroutine that outputs an MQC
!>    vector to a rank 1 intrinsic integer array</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Vector2IntegerArray is a subroutine that outputs an MQC vector to
!>    a rank 1 intrinsic integer array. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Integer(kind=int64),Dimension(:)
!>        The rank 1 intrinsic array which will receive the contents
!>        of MQC_Vector.
!>    \endverbatim
!>
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC_Vector whose data will be output into the intrinsc
!>        array.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian 
!>    \date 2016
!
      Subroutine MQC_Set_Vector2IntegerArray(ArrayOut,VectorIn)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Allocatable,Intent(InOut)::ArrayOut(:)
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64)::LenVectorIn
!
      LenVectorIn = MQC_Length_Vector(VectorIn)
      If(.not.Allocated(ArrayOut)) then
        Allocate(ArrayOut(LenVectorIn))
      ElseIf(LenVectorIn.ne.Size(ArrayOut))  then
        Deallocate(ArrayOut)
        Allocate(ArrayOut(LenVectorIn))
      EndIf

      If(LenVectorIn.gt.0) then
        If(VectorIn%Data_Type.eq.'Integer') then
          ArrayOut = VectorIn%veci
        Elseif(VectorIn%Data_Type.eq.'Real') then
          ArrayOut = VectorIn%vecr
        Elseif(VectorIn%Data_Type.eq.'Complex') then
          ArrayOut = Real(VectorIn%vecc)
        Else
          Call MQC_Error_A('VectorIn type not defined in MQC_Vector2IntegerArray', 6, &
               'VectorIn%Data_Type', VectorIn%Data_Type )
        EndIf
      EndIf
!
      Return
      End Subroutine MQC_Set_Vector2IntegerArray
!
!
!     PROCEDURE MQC_Set_Vector2RealArray
!
!>    \brief <b> MQC_Set_Vector2RealArray is a subroutine that outputs an MQC
!>    vector to a rank 1 intrinsic real array</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Vector2RealArray is a subroutine that outputs an MQC vector to
!>    a rank 1 intrinsic real array. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Real(kind=real64),Dimension(:)
!>        The rank 1 intrinsic array which will receive the contents
!>        of MQC_Vector.
!>    \endverbatim
!>
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC_Vector whose data will be output into the intrinsic
!>        array.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Subroutine MQC_Set_Vector2RealArray(ArrayOut,VectorIn)
!
!     Variable Declarations.
      Implicit None
      Real(kind=real64),Allocatable,Intent(InOut)::ArrayOut(:)
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64)::LenVectorIn
!
      LenVectorIn = MQC_Length_Vector(VectorIn)
      If(.not.Allocated(ArrayOut)) then
        Allocate(ArrayOut(LenVectorIn))
      ElseIf(LenVectorIn.ne.Size(ArrayOut))  then
        Deallocate(ArrayOut)
        Allocate(ArrayOut(LenVectorIn))
      EndIf

      If(LenVectorIn.gt.0) then
        If(VectorIn%Data_Type.eq.'Integer') then
          ArrayOut = VectorIn%veci
        Elseif(VectorIn%Data_Type.eq.'Real') then
          ArrayOut = VectorIn%vecr
        Elseif(VectorIn%Data_Type.eq.'Complex') then
          ArrayOut = real(VectorIn%vecc)
        Else
          Call MQC_Error_A('VectorIn type not defined in MQC_Vector2RealArray', 6, &
               'VectorIn%Data_Type', VectorIn%Data_Type )
        EndIf
      EndIf
!
      Return
      End Subroutine MQC_Set_Vector2RealArray
!
!
!     PROCEDURE MQC_Set_Vector2ComplexArray
!
!>    \brief <b> MQC_Set_Vector2ComplexArray is a subroutine that outputs an MQC
!>    vector to a rank 1 intrinsic complex array</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Vector2ComplexArray is a subroutine that outputs an MQC vector to
!>    a rank 1 intrinsic complex array. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Complex(kind=real64),Dimension(:)
!>        The rank 1 intrinsic array which will receive the contents
!>        of MQC_Vector.
!>    \endverbatim
!>
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC_Vector whose data will be output into the intrinsic
!>        array.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2017
!
      Subroutine MQC_Set_Vector2ComplexArray(ArrayOut,VectorIn)
!
!     Variable Declarations.
      Implicit None
      Complex(Kind=real64),Allocatable,Intent(InOut)::ArrayOut(:)
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64)::LenVectorIn
!
      LenVectorIn = MQC_Length_Vector(VectorIn)
      If(.not.Allocated(ArrayOut)) then
        Allocate(ArrayOut(LenVectorIn))
      ElseIf(LenVectorIn.ne.Size(ArrayOut))  then
        Deallocate(ArrayOut)
        Allocate(ArrayOut(LenVectorIn))
      EndIf

      If(LenVectorIn.gt.0) then
        If(VectorIn%Data_Type.eq.'Integer') then
          ArrayOut = VectorIn%veci
        Elseif(VectorIn%Data_Type.eq.'Real') then
          ArrayOut = VectorIn%vecr
        Elseif(VectorIn%Data_Type.eq.'Complex') then
          ArrayOut = VectorIn%vecc
        Else
          Call MQC_Error_A('VectorIn type not defined in MQC_Vector2ComplexArray', 6, &
               'VectorIn%Data_Type', VectorIn%Data_Type )
        EndIf
      EndIf
!
      Return
      End Subroutine MQC_Set_Vector2ComplexArray
!
!
!     PROCEDURE MQC_Set_Array2Vector_Integer
!
!>    \brief <b> MQC_Set_Array2Vector_Integer is a subroutine that sets a rank 1 
!>    intrinsic integer array equal to a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Array2Vector_Integer is a subroutine that sets a rank 1 intrinsic 
!>    integer array equal to a MQC vector
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] VectorOut
!>    \verbatim
!>        VectorOut is Type(MQC_Vector)
!>        The MQC vector that will be set equal to the rank 1 
!>        intrinsic array 
!>    \endverbatim
!>
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayOut is Integer(kind=int64),Dimension(:)
!>        The rank 1 intrinsic array whose data will be input 
!>        into the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Subroutine MQC_Set_Array2Vector_Integer(VectorOut,ArrayIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(InOut)::VectorOut
      Integer(kind=int64),Dimension(:),Allocatable::temp
      Integer(kind=int64),Dimension(:),Intent(In)::ArrayIn
!
      allocate(temp(size(ArrayIn)))
      temp = ArrayIn
      Call MQC_Deallocate_Vector(VectorOut)
      Call MQC_Allocate_Vector(Size(ArrayIn),VectorOut,'Integer')
      VectorOut%veci = temp
      deallocate(temp)
!
      Return
      End Subroutine MQC_Set_Array2Vector_Integer
!
!
!     PROCEDURE MQC_Set_Array2Vector_Real
!
!>    \brief <b> MQC_Set_Array2Vector_Real is a subroutine that sets a rank 1 vector
!>    intrinsic real array equal to a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Array2Vector_Real is a subroutine that sets a rank 1 vector intrinsic
!>    real array equal to a MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] VectorOut
!>    \verbatim
!>        VectorOut is Type(MQC_Vector)
!>        The MQC vector that will be set equal to the rank 1 
!>        intrinsic array 
!>    \endverbatim
!>
!>    \param[in] ArrayIn 
!>    \verbatim
!>        ArrayOut is Real(kind=real64),Dimension(:)
!>        The rank 1 intrinsic array whose data will be input 
!>        into the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Subroutine MQC_Set_Array2Vector_Real(VectorOut,ArrayIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(InOut)::VectorOut
      Real(kind=real64),Dimension(:),Intent(In)::ArrayIn
!
      Call MQC_Deallocate_Vector(VectorOut)
      Call MQC_Allocate_Vector(Size(ArrayIn),VectorOut,'Real')
      VectorOut%vecr = ArrayIn
!
      Return
      End Subroutine MQC_Set_Array2Vector_Real
!
!
!     PROCEDURE MQC_Set_Array2Vector_Complex
!
!>    \brief <b> MQC_Set_Array2Vector_Complex is a subroutine that sets a rank 1 
!>    vector intrinsic complex array equal to a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Array2Vector_Complex is a subroutine that sets a rank 1 vector intrinsic
!>    complex array equal to a MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] VectorOut
!>    \verbatim
!>        VectorOut is Type(MQC_Vector)
!>        The MQC vector that will be set equal to the rank 1 
!>        intrinsic array 
!>    \endverbatim
!>
!>    \param[in] ArrayIn 
!>    \verbatim
!>        ArrayOut is Complex(kind=real64),Dimension(:)
!>        The rank 1 intrinsic array whose data will be input 
!>        into the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2017
!
      Subroutine MQC_Set_Array2Vector_Complex(VectorOut,ArrayIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(InOut)::VectorOut
      Complex(Kind=real64),Dimension(:),Intent(In)::ArrayIn
!
      Call MQC_Deallocate_Vector(VectorOut)
      Call MQC_Allocate_Vector(Size(ArrayIn),VectorOut,'Complex')
      VectorOut%vecc = ArrayIn
!
      Return
      End Subroutine MQC_Set_Array2Vector_Complex
!
!
!     PROCEDURE MQC_Set_Array2Vector_Integer_Func
!
!>    \brief <b> MQC_Set_Array2Vector_Integer_Func is a function that sets a 
!>    rank 1 intrinsic integer array equal to a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Array2Vector_Integer_Func is a function that sets a rank 1  
!>    intrinsic integer array equal to a MQC vector
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayOut is Integer(kind=int64),Dimension(:)
!>        The rank 1 intrinsic array whose data will be input 
!>        into the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2025
!
      Function MQC_Set_Array2Vector_Integer_Func(ArrayIn) Result(VectorOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::VectorOut
      Integer(kind=int64),Dimension(:),Intent(In)::ArrayIn
!
      VectorOut = ArrayIn
!
      Return
      End Function MQC_Set_Array2Vector_Integer_Func
!
!
!     PROCEDURE MQC_Set_Array2Vector_Real_Func
!
!>    \brief <b> MQC_Set_Array2Vector_Real_Func is a function that sets a 
!>    rank 1 intrinsic real array equal to a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Array2Vector_Real_Func is a function that sets a rank 1  
!>    intrinsic real array equal to a MQC vector
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayOut is Real(kind=real64),Dimension(:)
!>        The rank 1 intrinsic array whose data will be input 
!>        into the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2025
!
      Function MQC_Set_Array2Vector_Real_Func(ArrayIn) Result(VectorOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::VectorOut
      Real(kind=real64),Dimension(:),Intent(In)::ArrayIn
!
      VectorOut = ArrayIn
!
      Return
      End Function MQC_Set_Array2Vector_Real_Func
!
!
!     PROCEDURE MQC_Set_Array2Vector_Complex_Func
!
!>    \brief <b> MQC_Set_Array2Vector_Complex_Func is a function that sets a 
!>    rank 1 intrinsic complex array equal to a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Array2Vector_Complex_Func is a function that sets a rank 1  
!>    intrinsic complex array equal to a MQC vector
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayOut is Complex(kind=real64),Dimension(:)
!>        The rank 1 intrinsic array whose data will be input 
!>        into the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2025
!
      Function MQC_Set_Array2Vector_Complex_Func(ArrayIn) Result(VectorOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::VectorOut
      Complex(kind=real64),Dimension(:),Intent(In)::ArrayIn
!
      VectorOut = ArrayIn
!
      Return
      End Function MQC_Set_Array2Vector_Complex_Func
!
!
!     PROCEDURE MQC_Set_Vector2Vector
!
!>    \brief <b> MQC_Set_Vector2Vector is a subroutine that sets a MQC vector equal 
!>    to another MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Set_Vector2Vector is a subroutine that sets a MQC vector equal to another 
!>    MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] VectorOut
!>    \verbatim
!>        VectorOut is Type(MQC_Vector)
!>        The MQC vector that will be set equal to VectorIn.
!>    \endverbatim
!>
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC vector whose contents will be copied to 
!>        VectorOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \author L. M. Thompson 
!>    \date 2016
!
      Subroutine MQC_Set_Vector2Vector(VectorOut,VectorIn)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Vector),Intent(InOut)::VectorOut
      Class(MQC_Vector),Intent(In)::VectorIn
!
      Call MQC_Deallocate_Vector(VectorOut)
      If(MQC_Vector_HaveReal(VectorIn)) then
        If(MQC_Length_Vector(VectorOut).eq.0 .or. &
          MQC_Length_Vector(VectorOut).ne.MQC_Length_Vector(VectorIn))  &
          Call MQC_Allocate_Vector(MQC_Length_Vector(VectorIn),VectorOut,'Real')
        VectorOut%vecr = VectorIn%vecr
      EndIf
      If(MQC_Vector_HaveInteger(VectorIn)) then
        If(MQC_Length_Vector(VectorOut).eq.0 .or. &
          MQC_Length_Vector(VectorOut).ne.MQC_Length_Vector(VectorIn)) &
          Call MQC_Allocate_Vector(MQC_Length_Vector(VectorIn),VectorOut,'Integer')
        VectorOut%veci = VectorIn%veci
      EndIf
      If(MQC_Vector_HaveComplex(VectorIn)) then
        If(MQC_Length_Vector(VectorOut).eq.0 .or. &
          MQC_Length_Vector(VectorOut).ne.MQC_Length_Vector(VectorIn)) &
          Call MQC_Allocate_Vector(MQC_Length_Vector(VectorIn),VectorOut,'Complex')
        VectorOut%vecc = VectorIn%vecc
      EndIf
!
      VectorOut%Column = VectorIn%Column
!
      Return
      End Subroutine MQC_Set_Vector2Vector
!
!
!     PROCEDURE MQC_VectorVectorSum
!
!>    \brief <b> MQC_VectorVectorSum is a function that adds two MQC vectors and
!>    stores them in another MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorVectorSum is a function that adds two MQC vectors and stores them in
!>    another MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector1In
!>    \verbatim
!>        Vector1In is Type(MQC_Vector)
!>        The first MQC vector that will be summed.
!>    \endverbatim
!>
!>    \param[in] Vector2In
!>    \verbatim
!>        Vector2In is Type(MQC_Vector)
!>        The second MQC vector that will be summed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2016
!
      Function MQC_VectorVectorSum(Vector1In,Vector2In)
!
      Implicit None
      Type(MQC_Vector)::MQC_VectorVectorSum
      Type(MQC_Vector),Intent(In)::Vector1In, Vector2In
      Integer(kind=int64) :: Vector1Len, Vector2Len, VectorOutLen

      Vector1Len = MQC_Length_Vector(Vector1In)
      Vector2Len = MQC_Length_Vector(Vector2In)

      If (Vector1Len.ne.Vector2Len) then
        Call MQC_Error_I('Vector lengths unequal in MQC_VectorVectorSum', 6, &
             'Vector1Len', Vector1Len, &
             'Vector2Len', Vector2Len )
      EndIf

      If (Vector1In%column.neqv.Vector2In%column) then
        Call MQC_Error_L('Vector orientations are different in MQC_VectorVectorSum', 6, &
             'Vector1In%column', Vector1In%column, &
             'Vector2In%column', Vector2In%column )
      EndIf

      If(Vector1In%Data_type.eq.'Real') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Real')
          MQC_VectorVectorSum%vecr = Vector1In%vecr + Vector2In%vecr
          MQC_VectorVectorSum%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Real')
          MQC_VectorVectorSum%vecr = Vector1In%vecr + Vector2In%veci
          MQC_VectorVectorSum%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Complex')
          MQC_VectorVectorSum%vecc = Vector1In%vecr + Vector2In%vecc
          MQC_VectorVectorSum%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_VectorVectorSum', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Integer') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Real')
          MQC_VectorVectorSum%vecr = Vector1In%veci + Vector2In%vecr
          MQC_VectorVectorSum%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Integer')
          MQC_VectorVectorSum%veci = Vector1In%veci + Vector2In%veci
          MQC_VectorVectorSum%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Complex')
          MQC_VectorVectorSum%vecc = Vector1In%veci + Vector2In%vecc
          MQC_VectorVectorSum%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_VectorVectorSum', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Complex') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Complex')
          MQC_VectorVectorSum%vecc = Vector1In%vecc + Vector2In%vecr
          MQC_VectorVectorSum%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Complex')
          MQC_VectorVectorSum%vecc = Vector1In%vecc + Vector2In%veci
          MQC_VectorVectorSum%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorSum,'Complex')
          MQC_VectorVectorSum%vecc = Vector1In%vecc + Vector2In%vecc
          MQC_VectorVectorSum%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_VectorVectorSum', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      Else
        Call MQC_Error_A('Vector1In type unspecified in MQC_VectorVectorSum', 6, &
             'Vector1In%Data_type', Vector1In%Data_type )
      EndIf

      Return
      End Function MQC_VectorVectorSum
!
!
!     PROCEDURE MQC_VectorVectorDifference
!
!>    \brief <b> MQC_VectorVectorDifference is a function that subtracts two MQC 
!>    vectors and stores them in another MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorVectorDifference is a function that subtracts two MQC vectors and 
!>    stores them in another MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector1In
!>    \verbatim
!>        Vector1In is Type(MQC_Vector)
!>        The first MQC vector from which the second will be 
!>        subtracted.
!>    \endverbatim
!>
!>    \param[in] Vector2In
!>    \verbatim
!>        Vector2In is Type(MQC_Vector)
!>        The second MQC vector that will be subtracted from the
!>        first.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2016
!
      Function MQC_VectorVectorDifference(Vector1In,Vector2In)
!
      Implicit None
      Type(MQC_Vector)::MQC_VectorVectorDifference
      Type(MQC_Vector),Intent(In)::Vector1In, Vector2In
      Integer(kind=int64) :: Vector1Len, Vector2Len, VectorOutLen

      Vector1Len = MQC_Length_Vector(Vector1In)
      Vector2Len = MQC_Length_Vector(Vector2In)

      If (Vector1Len.ne.Vector2Len) then
        Call MQC_Error_I('Vector lengths unequal in MQC_VectorVectorDifference', 6, &
             'Vector1Len', Vector1Len, &
             'Vector2Len', Vector2Len )
      EndIf

      If (Vector1In%column.neqv.Vector2In%column) then
        Call MQC_Error_L('Vector orientations are different in MQC_VectorVectorDifference', 6, &
             'Vector1In%column', Vector1In%column, &
             'Vector2In%column', Vector2In%column )
      EndIf

      If(Vector1In%Data_type.eq.'Real') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Real')
          MQC_VectorVectorDifference%vecr = Vector1In%vecr - Vector2In%vecr
          MQC_VectorVectorDifference%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Real')
          MQC_VectorVectorDifference%vecr = Vector1In%vecr - Vector2In%veci
          MQC_VectorVectorDifference%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Complex')
          MQC_VectorVectorDifference%vecc = Vector1In%vecr - Vector2In%vecc
          MQC_VectorVectorDifference%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_VectorVectorDifference', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Integer') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Real')
          MQC_VectorVectorDifference%vecr = Vector1In%veci - Vector2In%vecr
          MQC_VectorVectorDifference%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Integer')
          MQC_VectorVectorDifference%veci = Vector1In%veci - Vector2In%veci
          MQC_VectorVectorDifference%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Complex')
          MQC_VectorVectorDifference%vecc = Vector1In%veci - Vector2In%vecc
          MQC_VectorVectorDifference%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_VectorVectorDifference', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Complex') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Complex')
          MQC_VectorVectorDifference%vecc = Vector1In%vecc - Vector2In%vecr
          MQC_VectorVectorDifference%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Complex')
          MQC_VectorVectorDifference%vecc = Vector1In%vecc - Vector2In%veci
          MQC_VectorVectorDifference%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_VectorVectorDifference,'Complex')
          MQC_VectorVectorDifference%vecc = Vector1In%vecc - Vector2In%vecc
          MQC_VectorVectorDifference%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_VectorVectorDifference', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      Else
        Call MQC_Error_A('Vector1In type unspecified in MQC_VectorVectorDifference', 6, &
             'Vector1In%Data_type', Vector1In%Data_type )
      EndIf

      Return
      End Function MQC_VectorVectorDifference
!
!
!     PROCEDURE MQC_ScalarVectorSum
!
!>    \brief <b> MQC_ScalarVectorSum is a function that adds an MQC scalar to all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorVectorSum is a function that adds an MQC scalar to all elements of 
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC scalar to add to the MQC vector.
!>    \endverbatim
!>
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC vector with elements to sum with ScalarIn.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2016
!
      Function MQC_ScalarVectorSum(ScalarIn,VectorIn)
!
      Implicit None
      Type(MQC_Vector)::MQC_ScalarVectorSum
      Type(MQC_Scalar),Intent(In)::ScalarIn
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64) :: VectorLen

      VectorLen = MQC_Length_Vector(VectorIn)

      If(VectorIn%Data_type.eq.'Real') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Real')
          MQC_ScalarVectorSum%vecr = VectorIn%vecr + ScalarIn%scar
          MQC_ScalarVectorSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Real')
          MQC_ScalarVectorSum%vecr = VectorIn%vecr + ScalarIn%scai
          MQC_ScalarVectorSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Complex')
          MQC_ScalarVectorSum%vecc = VectorIn%vecr + ScalarIn%scac
          MQC_ScalarVectorSum%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_ScalarVectorSum', 6,&
               'ScalarIn%Data_type', ScalarIn%Data_type )
        EndIf
      ElseIf(VectorIn%Data_type.eq.'Integer') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Real')
          MQC_ScalarVectorSum%vecr = VectorIn%veci + ScalarIn%scar
          MQC_ScalarVectorSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Integer')
          MQC_ScalarVectorSum%veci = VectorIn%veci + ScalarIn%scai
          MQC_ScalarVectorSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Complex')
          MQC_ScalarVectorSum%vecc = VectorIn%veci + ScalarIn%scac
          MQC_ScalarVectorSum%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_ScalarVectorSum', 6, &
               'ScalarIn%Data_type', ScalarIn%Data_type )
        EndIf
      ElseIf(VectorIn%Data_type.eq.'Complex') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Complex')
          MQC_ScalarVectorSum%vecc = VectorIn%vecc + ScalarIn%scar
          MQC_ScalarVectorSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Complex')
          MQC_ScalarVectorSum%vecc = VectorIn%vecc + ScalarIn%scai
          MQC_ScalarVectorSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorSum,'Complex')
          MQC_ScalarVectorSum%vecc = VectorIn%vecc + ScalarIn%scac
          MQC_ScalarVectorSum%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_ScalarVectorSum', 6, &
               'ScalarIn%Data_type', ScalarIn%Data_type )
        EndIf
      Else
        Call MQC_Error_A('VectorIn type unspecified in MQC_ScalarVectorSum', 6, &
             'VectorIn%Data_type', VectorIn%Data_type )
      EndIf

      Return
      End Function MQC_ScalarVectorSum
!
!
!     PROCEDURE MQC_VectorScalarSum
!
!>    \brief <b> MQC_VectorScalarSum is a function that adds an MQC scalar to all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorScalarSum is a function that adds an MQC scalar to all elements of 
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC vector with elements to sum with ScalarIn.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC scalar to add to the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2022
!
      Function MQC_VectorScalarSum(VectorIn,ScalarIn)
!
      Implicit None
      Type(MQC_Vector)::MQC_VectorScalarSum
      Type(MQC_Vector),Intent(In)::VectorIn
      Type(MQC_Scalar),Intent(In)::ScalarIn
      Integer(kind=int64) :: VectorLen

      VectorLen = MQC_Length_Vector(VectorIn)

      If(VectorIn%Data_type.eq.'Real') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Real')
          MQC_VectorScalarSum%vecr = VectorIn%vecr + ScalarIn%scar
          MQC_VectorScalarSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Real')
          MQC_VectorScalarSum%vecr = VectorIn%vecr + ScalarIn%scai
          MQC_VectorScalarSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Complex')
          MQC_VectorScalarSum%vecc = VectorIn%vecr + ScalarIn%scac
          MQC_VectorScalarSum%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_VectorScalarSum', 6,&
               'ScalarIn%Data_type', ScalarIn%Data_type )
        EndIf
      ElseIf(VectorIn%Data_type.eq.'Integer') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Real')
          MQC_VectorScalarSum%vecr = VectorIn%veci + ScalarIn%scar
          MQC_VectorScalarSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Integer')
          MQC_VectorScalarSum%veci = VectorIn%veci + ScalarIn%scai
          MQC_VectorScalarSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Complex')
          MQC_VectorScalarSum%vecc = VectorIn%veci + ScalarIn%scac
          MQC_VectorScalarSum%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_VectorScalarSum', 6, &
               'ScalarIn%Data_type', ScalarIn%Data_type )
        EndIf
      ElseIf(VectorIn%Data_type.eq.'Complex') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Complex')
          MQC_VectorScalarSum%vecc = VectorIn%vecc + ScalarIn%scar
          MQC_VectorScalarSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Complex')
          MQC_VectorScalarSum%vecc = VectorIn%vecc + ScalarIn%scai
          MQC_VectorScalarSum%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_VectorScalarSum,'Complex')
          MQC_VectorScalarSum%vecc = VectorIn%vecc + ScalarIn%scac
          MQC_VectorScalarSum%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_VectorScalarSum', 6, &
               'ScalarIn%Data_type', ScalarIn%Data_type )
        EndIf
      Else
        Call MQC_Error_A('VectorIn type unspecified in MQC_VectorScalarSum', 6, &
             'VectorIn%Data_type', VectorIn%Data_type )
      EndIf

      Return
      End Function MQC_VectorScalarSum
!
!
!     PROCEDURE MQC_ScalarVectorDifference
!
!>    \brief <b> MQC_ScalarVectorDifference is a function that subtracts an MQC 
!>    scalar from all elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarVectorDifference is a function that subtracts an MQC scalar from 
!>    all elements of an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC scalar to be subtracted from elements of the
!>        the MQC vector.
!>    \endverbatim
!>
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC vector with elements from which ScalarIn will
!>        be subtracted.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2016
!
      Function MQC_ScalarVectorDifference(ScalarIn,VectorIn)
!
      Implicit None
      Type(MQC_Vector)::MQC_ScalarVectorDifference
      Type(MQC_Scalar),Intent(In)::ScalarIn
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64) :: VectorLen

      VectorLen = MQC_Length_Vector(VectorIn)

      If(VectorIn%Data_type.eq.'Real') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Real')
          MQC_ScalarVectorDifference%vecr = VectorIn%vecr - ScalarIn%scar
          MQC_ScalarVectorDifference%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Real')
          MQC_ScalarVectorDifference%vecr = VectorIn%vecr - ScalarIn%scai
          MQC_ScalarVectorDifference%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Complex')
          MQC_ScalarVectorDifference%vecc = VectorIn%vecr - ScalarIn%scac
          MQC_ScalarVectorDifference%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_ScalarVectorDifference', 6, &
               'ScalarIn%Data_type', ScalarIn%Data_type, &
               'VectorIn%Data_type', VectorIn%Data_type )
        EndIf
      ElseIf(VectorIn%Data_type.eq.'Integer') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Real')
          MQC_ScalarVectorDifference%vecr = VectorIn%veci - ScalarIn%scar
          MQC_ScalarVectorDifference%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Integer')
          MQC_ScalarVectorDifference%veci = VectorIn%veci - ScalarIn%scai
          MQC_ScalarVectorDifference%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Complex')
          MQC_ScalarVectorDifference%vecc = VectorIn%veci - ScalarIn%scac
          MQC_ScalarVectorDifference%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_ScalarVectorDifference', 6, &
               'ScalarIn%Data_type', ScalarIn%Data_type, &
               'VectorIn%Data_type', VectorIn%Data_type )
        EndIf
      ElseIf(VectorIn%Data_type.eq.'Complex') then
        If(ScalarIn%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Complex')
          MQC_ScalarVectorDifference%vecc = VectorIn%vecc - ScalarIn%scar
          MQC_ScalarVectorDifference%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Complex')
          MQC_ScalarVectorDifference%vecc = VectorIn%vecc - ScalarIn%scai
          MQC_ScalarVectorDifference%column = VectorIn%column
        ElseIf(ScalarIn%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(VectorLen,MQC_ScalarVectorDifference,'Complex')
          MQC_ScalarVectorDifference%vecc = VectorIn%vecc - ScalarIn%scac
          MQC_ScalarVectorDifference%column = VectorIn%column
        Else
          Call MQC_Error_A('ScalarIn type unspecified in MQC_ScalarVectorDifference', 6, &
               'ScalarIn%Data_type', ScalarIn%Data_type, &
               'VectorIn%Data_type', VectorIn%Data_type )
        EndIf
      Else
        Call MQC_Error_A('VectorIn type unspecified in MQC_ScalarVectorDifference', 6, &
             'VectorIn%Data_type', VectorIn%Data_type )
      EndIf

      Return
      End Function MQC_ScalarVectorDifference
!
!
!     PROCEDURE MQC_ElementVectorProduct
!
!>    \brief <b> MQC_ElementVectorProduct is a function that multiplies two MQC 
!>    vectors elementwise and stores them into another MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ElementVectorProduct is a function that multiplies two MQC vectors 
!>    elementwise and stores them into another MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector1In
!>    \verbatim
!>        Vector1In is Type(MQC_Vector)
!>        The frist MQC vector to multiply elementwise.
!>    \endverbatim
!>
!>    \param[in] Vector2In
!>    \verbatim
!>        Vector2In is Type(MQC_Vector)
!>        The second MQC vector to multiply elementwise.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2016
!
      Function MQC_ElementVectorProduct(Vector1In,Vector2In)
!
      Implicit None
      Type(MQC_Vector)::MQC_ElementVectorProduct
      Type(MQC_Vector),Intent(In)::Vector1In, Vector2In
      Integer(kind=int64) :: Vector1Len, Vector2Len, VectorOutLen, I

      Vector1Len = MQC_Length_Vector(Vector1In)
      Vector2Len = MQC_Length_Vector(Vector2In)

      If (Vector1Len.ne.Vector2Len) then
        Call MQC_Error_I('Vector lengths unequal in MQC_ElementVectorProduct', 6, &
             'Vector1Len', Vector1Len, &
             'Vector2Len', Vector2Len )
      EndIf

      If (Vector1In%column.neqv.Vector2In%column) then
        Call MQC_Error_L('Vector orientations are different in ElementVectorProduct', 6, &
             'Vector1In%column', Vector1In%column, &
             'Vector2In%column', Vector2In%column )
      EndIf

      If(Vector1In%Data_type.eq.'Real') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Real')
          MQC_ElementVectorProduct%vecr = Vector1In%vecr * Vector2In%vecr
          MQC_ElementVectorProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Real')
          MQC_ElementVectorProduct%vecr = Vector1In%vecr * Vector2In%veci
          MQC_ElementVectorProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Complex')
          MQC_ElementVectorProduct%vecc = Vector1In%vecr * Vector2In%vecc
          MQC_ElementVectorProduct%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_ElementVectorProduct', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Integer') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Real')
          MQC_ElementVectorProduct%vecr = Vector1In%veci * Vector2In%vecr
          MQC_ElementVectorProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Integer')
          MQC_ElementVectorProduct%veci = Vector1In%veci * Vector2In%veci
          MQC_ElementVectorProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Complex')
          MQC_ElementVectorProduct%vecc = Vector1In%veci * Vector2In%vecc
          MQC_ElementVectorProduct%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_ElementVectorProduct', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Complex') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Complex')
          MQC_ElementVectorProduct%vecc = Vector1In%vecc * Vector2In%vecr
          MQC_ElementVectorProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Complex')
          MQC_ElementVectorProduct%vecc = Vector1In%vecc * Vector2In%veci
          MQC_ElementVectorProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_ElementVectorProduct,'Complex')
          MQC_ElementVectorProduct%vecc = Vector1In%vecc * Vector2In%vecc
          MQC_ElementVectorProduct%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_ElementVectorProduct', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      Else
        Call MQC_Error_A('Vector1In type unspecified in MQC_ElementVectorProduct', 6, &
             'Vector1In%Data_type', Vector1In%Data_type )
      EndIf

      Return
      End Function MQC_ElementVectorProduct
!
!
!     PROCEDURE MQC_Vector_Transpose
!
!>    \brief <b> MQC_Vector_Transpose is a function that returns the transpose of an
!>    MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Transpose is a function that returns the transpose of an MQC vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC vector to transpose.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2016
!
      Function MQC_Vector_Transpose(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::MQC_Vector_Transpose
      Class(MQC_Vector),Intent(In)::Vector
!
      MQC_Vector_Transpose = Vector
      MQC_Vector_Transpose%Column =  &
        .not.MQC_Vector_Transpose%Column
!
      Return
      End Function MQC_Vector_Transpose
!
!
!     PROCEDURE MQC_Vector_Conjugate_Transpose
!
!>    \brief <b> MQC_Vector_Conjugate_Transpose is a function that returns the 
!>    conjugate transpose of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Conjugate_Transpose is a function that returns the conjugate 
!>    transpose of an MQC vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC vector to conjugate transpose.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_Conjugate_Transpose(Vector)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::MQC_Vector_Conjugate_Transpose
      Class(MQC_Vector),Intent(In)::Vector
!
      MQC_Vector_Conjugate_Transpose = Vector
      If(MQC_Vector_HaveComplex(MQC_Vector_Conjugate_Transpose)) &
        MQC_Vector_Conjugate_Transpose%vecC = conjg(MQC_Vector_Conjugate_Transpose%vecC)
      MQC_Vector_Conjugate_Transpose%Column =  &
        .not.MQC_Vector_Conjugate_Transpose%Column
!
      Return
      End Function MQC_Vector_Conjugate_Transpose
!
!
!     PROCEDURE MQC_VectorVectorDotProduct
!
!>    \brief <b> MQC_VectorVectorDotProduct is a function that returns the 
!>    dot product of two MQC vectors</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorVectorDotProduct is a function that returns the dot product of two 
!>    MQC vectors. The first vector should be a row vector, while the second vector
!>    should be a column vector. The vectors should be of the same length.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector1
!>    \verbatim
!>        Vector1 is Type(MQC_Vector)
!>        The MQC row vector. 
!>    \endverbatim
!>
!>    \param[in] Vector2
!>    \verbatim
!>        Vector2 is Type(MQC_Vector)
!>        The MQC column vector. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_VectorVectorDotProduct(Vector1,Vector2)
!
!     Variable Declarations.
      Implicit None
!      Real,Intent(Out)::MQC_DotProduct
      Type(MQC_Scalar)::MQC_VectorVectorDotProduct
      Type(MQC_Vector),Intent(In)::Vector1,Vector2
!
      If (Vector1%Length.ne.Vector2%Length) then
        Call MQC_Error_I('Vector dimensions are different in MQC_VectorVectorDotProduct', 6, &
             'Vector1%Length', Vector1%Length, &
             'Vector2%Length', Vector2%Length )
      EndIf
      If (Vector1%Column.eqv.Vector2%Column) then
        Call MQC_Error_L('Vector orientations are the same in MQC_VectorVectorDotProduct', 6, &
             'Vector1%Column', Vector1%Column, &
             'Vector2%Column', Vector2%Column )
      EndIf
      if (vector1%column) then
        call mqc_error_L('Vector1 is column type and vector2 is not. &
     &    Use mqc_outer(Vector1,Vector2) for outer product', 6, &
     'vector1%column', vector1%column )
      endif
      If(MQC_Vector_HaveReal(Vector1)) then
        If(MQC_Vector_HaveReal(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(Vector1%vecr,Vector2%vecr)
        ElseIf(MQC_Vector_HaveInteger(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(Vector1%vecr,Vector2%veci)
        ElseIf(MQC_Vector_HaveComplex(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(Vector1%vecr,Vector2%vecc)
        Else
          Call MQC_Error_L('Vector2In type unspecified in MQC_VectorVectorDotProduct', 6, &
               'MQC_Vector_HaveReal(Vector2)', MQC_Vector_HaveReal(Vector2), &
               'MQC_Vector_HaveInteger(Vector2)', MQC_Vector_HaveInteger(Vector2), &
               'MQC_Vector_HaveComplex(Vector2)', MQC_Vector_HaveComplex(Vector2) )
        EndIf
      ElseIf(MQC_Vector_HaveInteger(Vector1)) then
        If(MQC_Vector_HaveReal(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(Vector1%veci,Vector2%vecr)
        ElseIf(MQC_Vector_HaveInteger(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(Vector1%veci,Vector2%veci)
        ElseIf(MQC_Vector_HaveComplex(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(Vector1%veci,Vector2%vecc)
        Else
          Call MQC_Error_L('Vector2In type unspecified in MQC_VectorVectorDotProduct', 6, &
               'MQC_Vector_HaveReal(Vector2)', MQC_Vector_HaveReal(Vector2), &
               'MQC_Vector_HaveInteger(Vector2)', MQC_Vector_HaveInteger(Vector2), &
               'MQC_Vector_HaveComplex(Vector2)', MQC_Vector_HaveComplex(Vector2) )
        EndIf
      ElseIf(MQC_Vector_HaveComplex(Vector1)) then
        If(MQC_Vector_HaveReal(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(conjg(Vector1%vecc),Vector2%vecr)
        ElseIf(MQC_Vector_HaveInteger(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(conjg(Vector1%vecc),Vector2%veci)
        ElseIf(MQC_Vector_HaveComplex(Vector2)) then
          MQC_VectorVectorDotProduct = dot_product(conjg(Vector1%vecc),Vector2%vecc)
        Else
          Call MQC_Error_L('Vector2In type unspecified in MQC_VectorVectorDotProduct', 6, &
               'MQC_Vector_HaveReal(Vector2)', MQC_Vector_HaveReal(Vector2), &
               'MQC_Vector_HaveInteger(Vector2)', MQC_Vector_HaveInteger(Vector2), &
               'MQC_Vector_HaveComplex(Vector2)', MQC_Vector_HaveComplex(Vector2) )
        EndIf
      Else
        Call MQC_Error_L('Vector1In type unspecified in MQC_VectorVectorDotProduct', 6, &
        'MQC_Vector_HaveComplex(Vector1)', MQC_Vector_HaveComplex(Vector1), &
        'MQC_Vector_HaveInteger(Vector1)', MQC_Vector_HaveInteger(Vector1), &
        'MQC_Vector_HaveReal(Vector1)', MQC_Vector_HaveReal(Vector1) )
      EndIf
!
      Return
      End Function MQC_VectorVectorDotProduct

!     PROCEDURE MQC_Outer
!
!>    \brief <b> MQC_Outer is a function that returns the outer product of two MQC 
!>    vectors</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Outer is a function that returns the outer product of two MQC vectors. The
!>    first vector should be a column vector, while the second vector should be a row 
!>    vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VA
!>    \verbatim
!>        VA is Type(MQC_Vector)
!>        The MQC column vector. 
!>    \endverbatim
!>
!>    \param[in] VB
!>    \verbatim
!>        VB is Type(MQC_Vector)
!>        The MQC row vector. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
    Function mqc_outer(VA,VB) result(M)
!
      implicit none
      type(mqc_vector),intent(in)::VA,VB
      type(mqc_matrix)::M
      integer(kind=int64)::i,j
      type(mqc_vector)::VC,VD

      If (VA%Column.eqv.VB%Column) then
        Call MQC_Error_L('Vector orientations are the same in MQC_Outer', 6, &
             'VA%Column', VA%Column, &
             'VB%Column', VB%Column )
      EndIf
      if (VB%column) then
        call mqc_error_l('Vector1 is row type and vector2 is column. &
     &    Use .dot. as a dot product operator for dot product. ', 6, &
     'VB%column', VB%column )
      endif
      if (mqc_have_int(VA) .and. mqc_have_int(VB)) then
        call M%init(VA%length,VB%length,0)
        VC = mqc_cast_real(VA)
        VD = mqc_cast_real(VB)
        call dger(VA%length,VB%length,1.0,VC%vecr,1,VD%vecr,1,M%matr,VA%length)
        M = mqc_cast_integer(M)
      elseif((mqc_have_int(VA).or.mqc_have_real(VA)).and.(mqc_have_int(VB).or.mqc_have_real(VB))) then
        call M%init(VA%length,VB%length)
        if (mqc_have_int(VA)) then
          VC = mqc_cast_real(VA)
          call dger(VA%length,VB%length,1.0,VC%vecr,1,VB%vecr,1,M%matr,VA%length)
        elseif (mqc_have_int(VB)) then
          VC = mqc_cast_real(VB)
          call dger(VA%length,VB%length,1.0,VA%vecr,1,VC%vecr,1,M%matr,VA%length)
        else
          call dger(VA%length,VB%length,1.0,VA%vecr,1,VB%vecr,1,M%matr,VA%length)
        endif
      else
        call M%init(VA%length,VB%length,(0.0,0.0))
        if (mqc_have_int(VA)) then
          VC = mqc_cast_complex(VA)
          call zgerc(VA%length,VB%length,1.0,VC%vecc,1,VB%vecc,1,M%matc,VA%length)
        elseif (mqc_have_int(VB)) then
          VC = mqc_cast_complex(VB)
          call zgerc(VA%length,VB%length,1.0,VA%vecc,1,VC%vecc,1,M%matc,VA%length)
        elseif (mqc_have_real(VA)) then
          VC = mqc_cast_complex(VA)
          call zgerc(VA%length,VB%length,1.0,VC%vecc,1,VB%vecc,1,M%matc,VA%length)
        elseif (mqc_have_real(VB)) then
          VC = mqc_cast_complex(VB)
          call zgerc(VA%length,VB%length,1.0,VA%vecc,1,VC%vecc,1,M%matc,VA%length)
        else
          call zgerc(VA%length,VB%length,1.0,VA%vecc,1,VB%vecc,1,M%matc,VA%length)
        endif
      endif

    return
    end function mqc_outer
!
!
!     PROCEDURE MQC_CrossProduct
!
!>    \brief <b> MQC_CrossProduct is a function that returns the cross product of 
!>    two MQC vectors</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_CrossProduct is a function that returns the cross product of two MQC 
!>    vectors. The vectors should both be of length 3.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector1In
!>    \verbatim
!>        Vector1In is Type(MQC_Vector)
!>        The first MQC vector. 
!>    \endverbatim
!>
!>    \param[in] Vector2In
!>    \verbatim
!>        Vector2In is Type(MQC_Vector)
!>        The second MQC vector. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_CrossProduct(Vector1In,Vector2In)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::MQC_CrossProduct
      Type(MQC_Vector),Intent(In)::Vector1In,Vector2In
      Integer(kind=int64) :: Vector1Len, Vector2Len, VectorOutLen, I

      Vector1Len = MQC_Length_Vector(Vector1In)
      Vector2Len = MQC_Length_Vector(Vector2In)

      If (Vector1Len.ne.3.or.Vector2Len.ne.3) then
        Call MQC_Error_I('Vector not R3 in MQC_CrossProduct', 6, &
             'Vector1Len', Vector1Len, &
             'Vector2Len', Vector2Len )
      EndIf

      If (Vector1Len.ne.Vector2Len) then
        Call MQC_Error_I('Vector lengths unequal in MQC_CrossProduct', 6, &
             'Vector1Len', Vector1Len, &
             'Vector2Len', Vector2Len )
      EndIf

      If (Vector1In%column.neqv.Vector2In%column) then
        Call MQC_Error_L('Vector orientations are different in MQC_CrossProduct', 6, &
             'Vector1In%column', Vector1In%column, &
             'Vector2In%column', Vector2In%column )
      EndIf

      If(Vector1In%Data_type.eq.'Real') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Real')
          MQC_CrossProduct%vecr(1) = Vector1In%vecr(2)*Vector2In%vecr(3) - &
            Vector1In%vecr(3)*Vector2In%vecr(2)
          MQC_CrossProduct%vecr(2) = Vector1In%vecr(3)*Vector2In%vecr(1) - &
            Vector1In%vecr(1)*Vector2In%vecr(3)
          MQC_CrossProduct%vecr(3) = Vector1In%vecr(1)*Vector2In%vecr(2) - &
            Vector1In%vecr(2)*Vector2In%vecr(1)
          MQC_CrossProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Real')
          MQC_CrossProduct%vecr(1) = Vector1In%vecr(2)*Vector2In%veci(3) - &
            Vector1In%vecr(3)*Vector2In%veci(2)
          MQC_CrossProduct%vecr(2) = Vector1In%vecr(3)*Vector2In%veci(1) - &
            Vector1In%vecr(1)*Vector2In%veci(3)
          MQC_CrossProduct%vecr(3) = Vector1In%vecr(1)*Vector2In%veci(2) - &
            Vector1In%vecr(2)*Vector2In%veci(1)
          MQC_CrossProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Complex')
          MQC_CrossProduct%vecc(1) = Vector1In%vecr(2)*Vector2In%vecc(3) - &
            Vector1In%vecr(3)*Vector2In%vecc(2)
          MQC_CrossProduct%vecc(2) = Vector1In%vecr(3)*Vector2In%vecc(1) - &
            Vector1In%vecr(1)*Vector2In%vecc(3)
          MQC_CrossProduct%vecc(3) = Vector1In%vecr(1)*Vector2In%vecc(2) - &
            Vector1In%vecr(2)*Vector2In%vecc(1)
          MQC_CrossProduct%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_CrossProduct', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Integer') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Real')
          MQC_CrossProduct%vecr(1) = Vector1In%veci(2)*Vector2In%vecr(3) - &
            Vector1In%veci(3)*Vector2In%vecr(2)
          MQC_CrossProduct%vecr(2) = Vector1In%veci(3)*Vector2In%vecr(1) - &
            Vector1In%veci(1)*Vector2In%vecr(3)
          MQC_CrossProduct%vecr(3) = Vector1In%veci(1)*Vector2In%vecr(2) - &
            Vector1In%veci(2)*Vector2In%vecr(1)
          MQC_CrossProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Integer')
          MQC_CrossProduct%veci(1) = Vector1In%veci(2)*Vector2In%veci(3) - &
            Vector1In%veci(3)*Vector2In%veci(2)
          MQC_CrossProduct%veci(2) = Vector1In%veci(3)*Vector2In%veci(1) - &
            Vector1In%veci(1)*Vector2In%veci(3)
          MQC_CrossProduct%veci(3) = Vector1In%veci(1)*Vector2In%veci(2) - &
            Vector1In%veci(2)*Vector2In%veci(1)
          MQC_CrossProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Complex')
          MQC_CrossProduct%vecc(1) = Vector1In%veci(2)*Vector2In%vecc(3) - &
            Vector1In%veci(3)*Vector2In%vecc(2)
          MQC_CrossProduct%vecc(2) = Vector1In%veci(3)*Vector2In%vecc(1) - &
            Vector1In%veci(1)*Vector2In%vecc(3)
          MQC_CrossProduct%vecc(3) = Vector1In%veci(1)*Vector2In%vecc(2) - &
            Vector1In%veci(2)*Vector2In%vecc(1)
          MQC_CrossProduct%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_CrossProduct', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      ElseIf(Vector1In%Data_type.eq.'Complex') then
        If(Vector2In%Data_type.eq.'Real') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Complex')
          MQC_CrossProduct%vecc(1) = Vector1In%vecc(2)*Vector2In%vecr(3) - &
            Vector1In%vecc(3)*Vector2In%vecr(2)
          MQC_CrossProduct%vecc(2) = Vector1In%vecc(3)*Vector2In%vecr(1) - &
            Vector1In%vecc(1)*Vector2In%vecr(3)
          MQC_CrossProduct%vecc(3) = Vector1In%vecc(1)*Vector2In%vecr(2) - &
            Vector1In%vecc(2)*Vector2In%vecr(1)
          MQC_CrossProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Integer') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Complex')
          MQC_CrossProduct%vecc(1) = Vector1In%vecc(2)*Vector2In%veci(3) - &
            Vector1In%vecc(3)*Vector2In%veci(2)
          MQC_CrossProduct%vecc(2) = Vector1In%vecc(3)*Vector2In%veci(1) - &
            Vector1In%vecc(1)*Vector2In%veci(3)
          MQC_CrossProduct%vecc(3) = Vector1In%vecc(1)*Vector2In%veci(2) - &
            Vector1In%vecc(2)*Vector2In%veci(1)
          MQC_CrossProduct%column = Vector1In%column
        ElseIf(Vector2In%Data_type.eq.'Complex') then
          Call MQC_Allocate_Vector(Vector1Len,MQC_CrossProduct,'Complex')
          MQC_CrossProduct%vecc(1) = Vector1In%vecc(2)*Vector2In%vecc(3) - &
            Vector1In%vecc(3)*Vector2In%vecc(2)
          MQC_CrossProduct%vecc(2) = Vector1In%vecc(3)*Vector2In%vecc(1) - &
            Vector1In%vecc(1)*Vector2In%vecc(3)
          MQC_CrossProduct%vecc(3) = Vector1In%vecc(1)*Vector2In%vecc(2) - &
            Vector1In%vecc(2)*Vector2In%vecc(1)
          MQC_CrossProduct%column = Vector1In%column
        Else
          Call MQC_Error_A('Vector2In type unspecified in MQC_CrossProduct', 6, &
               'Vector2In%Data_type', Vector2In%Data_type )
        EndIf
      Else
        Call MQC_Error_A('Vector1In type unspecified in MQC_CrossProduct', 6, &
             'Vector1In%Data_type', Vector1In%Data_type )
      EndIf
      Return
      End Function MQC_CrossProduct
!
!
!     PROCEDURE MQC_Print_Vector_Algebra1
!
!>    \brief <b> MQC_Print_Vector_Algebra1 is a subroutine used to print an MQC
!>    vector</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Print_Vector_Algebra1 is a subroutine used to print an MQC vector. 
!>    Blank_At_Top and Blank_At_Bottom are optional logical arguments to print blank
!>    lines before or after output.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The variable to be printed.
!>    \endverbatim
!>
!>    \param[in] IOut
!>    \verbatim
!>        IOut is Integer(kind=int64) 
!>        The Fortran file number to print to. 
!>    \endverbatim
!>
!>    \param[in] Header
!>    \verbatim
!>        Header is Character(Len=*)
!>        The title to print along with Vector.
!>    \endverbatim
!>
!>    \param[in] Verbose
!>    \verbatim
!>        Verbose is Logical,Optional
!>        Adds extra printing to output.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Top
!>    \verbatim
!>        Blank_At_Top is Logical,Optional
!>        = .True.:  print blank line above output
!>        = .False.: do not print blank line above output.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Bottom
!>    \verbatim
!>        Blank_At_Bottom is Logical,Optional
!>        = .True.:  print blank line below output
!>        = .False.: do not print blank line below output.
!>    \endverbatim
!>
!>    \param[in] FormatStr
!>    \verbatim
!>        FormatStr is Character(Len=*),Optional
!>        Formatting statement for printing.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Print_Vector_Algebra1(Vector,IOut,Header,Verbose,Blank_At_Top, &
        Blank_At_Bottom,FormatStr)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::IOut
      Class(MQC_Vector),Intent(In)::Vector
      Character(Len=*),Intent(In)::Header
      Logical,Intent(In),Optional::Blank_At_Top,Blank_At_Bottom,Verbose
      Integer(kind=int64)::I,Length
      Character(Len=*),Intent(In),Optional::FormatStr
      Character(Len=256)::FormatLine
!
 1000 Format(1x,A)
 1001 Format(1x,I7,2x,I14)
 1002 Format(1x,I7,2X,F14.6)
 1003 Format(1x,I7,2X,F14.6,SP,F14.6,"i")
 1020 Format( " " )
 1030 Format( A )
!
      If(PRESENT(Blank_At_Top)) then
        If(Blank_At_Top) Write(IOut,1020)
      EndIf
      Write(IOut,1000) TRIM(Header)

      Length = MQC_Length_Vector(Vector)
      if (Present(Verbose)) then
        if (verbose.and.vector%column) then
          write(IOut,1030) 'The vector being printed is a column vector'
        elseif (verbose) then
          write(IOut,1030) 'The vector being printed is a row vector'
        endif
      endIf
      If(Vector%Data_type.eq.'Integer') then
        Do I = 1,Length
          If(present(FormatStr)) then
            FormatLine = '(1x,I7,2x,'//trim(FormatStr)//')'
            Write(IOut,trim(FormatLine)) I, Vector%veci(I)
          Else
            Write(IOut,1001) I, Vector%veci(I)
          EndIf
        EndDo
      ElseIf(Vector%Data_type.eq.'Real') then
        Do I = 1,Length
          If(present(FormatStr)) then
            FormatLine = '(1x,I7,2x,'//trim(FormatStr)//')'
            Write(IOut,trim(FormatLine)) I, Vector%vecr(I)
          Else
            Write(IOut,1002) I, Vector%vecr(I)
          endIf
        EndDo
      ElseIf(Vector%Data_type.eq.'Complex') then
        Do I = 1,Length
          If(present(FormatStr)) then
            FormatLine = '(1x,I7,2x,'//trim(FormatStr)//',SP,'//trim(FormatStr)//',"i")'
            Write(IOut,trim(FormatLine)) I, Vector%vecc(I)
          Else
            Write(IOut,1003) I, Vector%vecc(I)
          EndIf
        EndDo
      Else
        Call MQC_Error_A('Vector type unspecified in MQC_Print_Vector_Algebra1', 6, &
             'Vector%Data_type', Vector%Data_type )
      EndIf

      If(PRESENT(Blank_At_Bottom)) then
        If(Blank_At_Bottom) Write(IOut,1020)
      EndIf
!
      Return
      End Subroutine MQC_Print_Vector_Algebra1
!
!
!     PROCEDURE MQC_vector_cast_integer
!
!>    \brief <b> MQC_vector_cast_integer is a function that converts an MQC vector to
!>    its integer space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_vector_cast_integer is a function that converts an MQC vector to its 
!>    integer space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VA
!>    \verbatim
!>        VA is Type(MQC_Vector)
!>        The MQC vector to convert.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2019
!
      function MQC_vector_cast_integer(VA) result(VB)
!
      implicit none
      type(mqc_vector),intent(in)::VA
      type(mqc_vector)::VB

      call mqc_allocate_vector(VA%length,VB,'Integer')
      if(mqc_have_real(VA)) then
        VB%veci = VA%vecr
      elseif(mqc_have_complex(VA)) then
        VB%veci = VA%vecc
      endif

      end function MQC_vector_cast_integer
!
!
!     PROCEDURE MQC_vector_cast_real
!
!>    \brief <b> MQC_vector_cast_real is a function that converts an MQC vector to
!>    its real space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_vector_cast_real is a function that converts an MQC vector to its real 
!>    space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VA
!>    \verbatim
!>        VA is Class(MQC_Vector)
!>        The MQC vector to convert.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      function MQC_vector_cast_real(VA) result(VB)
!
      implicit none
      type(mqc_vector),intent(in)::VA
      type(mqc_vector)::VB,temp

      temp = VA%veci
      call mqc_allocate_vector(VA%length,VB,'Real')
      if(mqc_have_int(VA)) then
        VB%vecr = VA%veci
      elseif(mqc_have_complex(VA)) then
        VB%vecr = VA%vecc
      endif

      end function MQC_vector_cast_real
!
!
!     PROCEDURE MQC_vector_cast_complex
!
!>    \brief <b> MQC_vector_cast_complex is a function that converts an MQC vector to
!>    its complex space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_vector_cast_complex is a function that converts an MQC vector to its 
!>    complex space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VA
!>    \verbatim
!>        VA is Class(MQC_Vector)
!>        The MQC vector to convert.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      function MQC_vector_cast_complex(VA) result(VB)
!
      implicit none
      type(mqc_vector),intent(in)::VA
      type(mqc_vector)::VB

      call mqc_allocate_vector(VA%length,VB,'Complex')
      if(mqc_have_int(VA)) then
        VB%vecc = VA%veci
      elseif(mqc_have_real(VA)) then
        VB%vecc = VA%vecr
      endif

      end function MQC_vector_cast_complex
!
!
!     PROCEDURE MQC_Vector_Scalar_Put_Scalar
!
!>    \brief <b> MQC_Vector_Scalar_Put_Scalar is a subroutine that updates the value 
!>    of the ith element of a MQC vector with a value with MQC Scalar indices</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Scalar_Put_Scalar is a subroutine that updates the value of the ith 
!>    element of a MQC vector with a value with MQC Scalar indices. If the location 
!>    of the element is negative then it is counted from the end of MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The MQC_Vector to update at the Ith element.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Class(*)
!>        The value to update Vector at element I.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Type(MQC_Scalar)
!>        The location of the element in Vector to update. If I
!>        is negative it is counted from the last element of 
!>        Vector. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Subroutine MQC_Vector_Scalar_Put_Scalar(Vector,ScalarIn,I)
!
!     Variable Declarations.
!
      Implicit None
      Type(MQC_Scalar),Intent(In)::I
      Class(MQC_Vector),Intent(InOut)::Vector
      Class(*),Intent(In)::ScalarIn
      Integer(kind=int64)::IndI

      IndI = I
      Call MQC_Vector_Scalar_Put_Int(Vector,ScalarIn,IndI)

      End Subroutine MQC_Vector_Scalar_Put_Scalar
!
!
!     PROCEDURE MQC_Vector_Scalar_Put_Int
!
!>    \brief <b> MQC_Vector_Scalar_Put_Int is a subroutine that updates the value of 
!>    the ith element of a MQC vector with a value with integer indices</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Scalar_Put_Int is a subroutine that updates the value of the ith 
!>    element of a MQC vector with a value with integer indices. If the location of 
!>    the element is negative then it is counted from the end of MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The MQC_Vector to update at the Ith element.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Class(*)
!>        The value to update Vector at element I.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer
!>        The location of the element in Vector to update. If I
!>        is negative it is counted from the last element of 
!>        Vector. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Scalar_Put_Int(Vector,ScalarIn,I)
!
!     Variable Declarations.
!
      Implicit None
      Integer,Intent(In)::I
      Class(MQC_Vector),Intent(InOut)::Vector
      Class(*),Intent(In)::ScalarIn
      Type(MQC_Scalar)::Scalar
      Integer(kind=int64)::IndI

      IndI = I

      Select Type (ScalarIn)
      Type Is (Integer)
        Scalar = ScalarIn
      Type Is (Real)
        Scalar = ScalarIn
      Type Is (Complex)
        Scalar = ScalarIn
      Type Is (MQC_Scalar)
        Scalar = ScalarIn
      Class Default
        Call MQC_Error_I('ScalarIn type not defined in MQC_Vector_Scalar_Put',6)
      End Select

      If (IndI.lt.0) IndI = Vector%Length + IndI + 1
      If (IndI.eq.0.or.IndI.gt.Vector%Length) Call MQC_Error_I('Index I badly specified in mqc_vector_scalar_put', 6, &
           'IndI', IndI, &
           'Vector%Length', Vector%Length )

      If (Vector%Data_Type.eq.'Integer') then
        If (Scalar%Data_Type.eq.'Integer') then
          Vector%VecI(IndI) = Scalar%ScaI
        ElseIf (Scalar%Data_Type.eq.'Real') then
          Call MQC_Vector_Copy_Int2Real(Vector)
          Vector%VecR(IndI) = Scalar%ScaR
        ElseIf (Scalar%Data_Type.eq.'Complex') then
          Call MQC_Vector_Copy_Int2Complex(Vector)
          Vector%VecC(IndI) = Scalar%ScaC
        Else
          Call MQC_Error_A('Scalar type not defined in MQC_Vector_Scalar_Put', 6, &
               'Scalar%Data_Type', Scalar%Data_Type )
        EndIf
      ElseIf (Vector%Data_Type.eq.'Real') then
        If (Scalar%Data_Type.eq.'Integer') then
          Vector%VecR(IndI) = Scalar%ScaI
        ElseIf (Scalar%Data_Type.eq.'Real') then
          Vector%VecR(IndI) = Scalar%ScaR
        ElseIf (Scalar%Data_Type.eq.'Complex') then
          Call MQC_Vector_Copy_Real2Complex(Vector)
          Vector%VecC(IndI) = Scalar%ScaC
        Else
          Call MQC_Error_A('Scalar type not defined in MQC_Vector_Scalar_Put', 6, &
               'Scalar%Data_Type', Scalar%Data_Type )
        EndIf
      ElseIf (Vector%Data_Type.eq.'Complex') then
        If (Scalar%Data_Type.eq.'Integer') then
          Vector%VecC(IndI) = Scalar%ScaI
        ElseIf (Scalar%Data_Type.eq.'Real') then
          Vector%VecC(IndI) = Scalar%ScaR
        ElseIf (Scalar%Data_Type.eq.'Complex') then
          Vector%VecC(IndI) = Scalar%ScaC
        Else
          Call MQC_Error_A('Scalar type not defined in MQC_Vector_Scalar_Put', 6, &
               'Scalar%Data_Type', Scalar%Data_Type )
        EndIf
      Else
        Call MQC_Error_A('Vector type not defined in MQC_Vector_Scalar_Put', 6, &
             'Vector%Data_Type', Vector%Data_Type )
      EndIf

      End Subroutine MQC_Vector_Scalar_Put_Int
!
!
!     PROCEDURE MQC_Vector_Scalar_Increment
!
!>    \brief <b> MQC_Vector_Scalar_Increment is a subroutine that increments the 
!>    value of the ith element of a MQC vector by the value of a MQC scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Scalar_Increment is a subroutine that increments the value of the 
!>    ith element of a MQC vector by the value of a MQC scalar. If the location of 
!>    the element is negative then it is counted from the end of MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The MQC_Vector to update at the Ith element.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar to update the Ith element.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer(kind=int64)
!>        The location of the element in Vector to update. If I
!>        is negative it is counted from the last element of 
!>        Vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Scalar_Increment(Vector,Scalar,I)
!
!     Variable Declarations.
!
      Implicit None
      Integer(kind=int64),Intent(In)::I
      Class(MQC_Vector),Intent(InOut)::Vector
      Type(MQC_Scalar),Intent(In)::Scalar
      Integer(kind=int64)::IndI

      IndI = I
      If (IndI.lt.0) IndI = Vector%Length + IndI + 1
      If (IndI.eq.0.or.IndI.gt.Vector%Length) Call MQC_Error_I('Index I badly specified in mqc_vector_scalar_increment.', 6, &
           'IndI', IndI, &
           'Vector%Length', Vector%Length )
      If (Vector%Data_Type.eq.'Integer') then
        If (Scalar%Data_Type.eq.'Integer') then
          Vector%VecI(IndI) = Vector%VecI(IndI) + Scalar%ScaI
        ElseIf (Scalar%Data_Type.eq.'Real') then
          Vector%VecI(IndI) = Vector%VecI(IndI) + int(Scalar%ScaR)
        ElseIf (Scalar%Data_Type.eq.'Complex') then
          Vector%VecI(IndI) = Vector%VecI(IndI) + Real(Scalar%ScaC)
        Else
          Call MQC_Error_A('Scalar type not defined in MQC_Vector_Scalar_Incrememt', 6, &
               'Scalar%Data_Type', Scalar%Data_Type )
        EndIf
      ElseIf (Vector%Data_Type.eq.'Real') then
        If (Scalar%Data_Type.eq.'Integer') then
#ifdef PGI
          Vector%VecR(IndI) = Vector%VecR(IndI) + dfloat(Scalar%ScaI)
#else
          Vector%VecR(IndI) = Vector%VecR(IndI) + float(Scalar%ScaI)
#endif
        ElseIf (Scalar%Data_Type.eq.'Real') then
          Vector%VecR(IndI) = Vector%VecR(IndI) + Scalar%ScaR
        ElseIf (Scalar%Data_Type.eq.'Complex') then
          Vector%VecR(IndI) = Vector%VecR(IndI) + Real(Scalar%ScaC)
        Else
          Call MQC_Error_A('Scalar type not defined in MQC_Vector_Scalar_Increment', 6, &
               'Scalar%Data_Type', Scalar%Data_Type )
        EndIf
      ElseIf (Vector%Data_Type.eq.'Complex') then
        If (Scalar%Data_Type.eq.'Integer') then
          Vector%VecC(IndI) = Vector%VecC(IndI) + cmplx(Scalar%ScaI,0)
        ElseIf (Scalar%Data_Type.eq.'Real') then
          Vector%VecC(IndI) = Vector%VecC(IndI) + cmplx(Scalar%ScaR,0.0)
        ElseIf (Scalar%Data_Type.eq.'Complex') then
          Vector%VecC(IndI) = Vector%VecC(IndI) + Scalar%ScaC
        Else
          Call MQC_Error_A('Scalar type not defined in MQC_Vector_Scalar_Increment', 6, &
               'Scalar%Data_Type', Scalar%Data_Type )
        EndIf
      Else
        Call MQC_Error_A('Vector type not defined in MQC_Vector_Scalar_Increment', 6, &
'Vector%Data_Type', Vector%Data_Type )
      EndIf
!
      End Subroutine MQC_Vector_Scalar_Increment
!
!
!     PROCEDURE MQC_Vector_Vector_Put
!
!>    \brief <b> MQC_Vector_Vector_Put is a subroutine that updates the values of a 
!>    subvector of a MQC vector with the values of a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Vector_Put is a subroutine that updates the values of a subvector 
!>    of a MQC vector starting at element I with the values of a MQC vector. Negative 
!>    I counts from the end of vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The MQC_Vector to update starting at the Ith element.
!>    \endverbatim
!>
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Class(MQC_Vector)
!>        The subvector with values to insert into Vector. 
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer(kind=int64)
!>        The location of the first subvector element in Vector 
!>        to update. If I is negative it is counted from the last
!>        element of Vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Vector_Put(Vector,VectorIn,I)
!
      Implicit None
      Class(MQC_Vector),Intent(InOut)::Vector
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64),Optional,Intent(In)::I
      Integer(kind=int64)::Length,IndI,IndJ

      If(Present(I)) then
        IndI = I
      Else
        IndI = 1
      EndIf
      If (IndI.lt.0) IndI = Vector%Length + IndI + 1
      If (IndI.eq.0) Call MQC_Error_I('Index I badly specified in mqc_vector_vector_put', 6, &
           'IndI', IndI )
      IndJ = IndI + MQC_Length_Vector(VectorIn) - 1

      Length = IndJ-IndI+1
      If (Length.le.0.or.Length.gt.Vector%Length.or.Length.ne.VectorIn%Length) Call MQC_Error_I('Vector length badly &
    &  defined in MQC_Vector_Vector_Put', 6, &
       'Length', Length, &
       'Vector%Length', Vector%Length, &
       'VectorIn%Length', VectorIn%Length )
      If (IndI.le.0.or.IndI.gt.(Vector%Length-Length+1)) Call MQC_Error_I('Index I out of bounds &
    &   in MQC_Vector_Vector_Put', 6, &
        'IndI', IndI, &
        'Vector%Length', Vector%Length, &
        'Length', Length )
      If (IndJ.lt.Length.or.IndJ.gt.Vector%Length) Call MQC_Error_I('Index J out of bounds &
    &   in MQC_Vector_Vector_Put', 6, &
        'IndJ', IndJ, &
        'Length', Length, &
        'Vector%Length', Vector%Length )
      If (Vector%Data_Type.eq.'Integer') then
        If (VectorIn%Data_Type.eq.'Integer') then
          Vector%VecI(IndI:IndJ) = VectorIn%VecI
        ElseIf (VectorIn%Data_Type.eq.'Real') then
          Call MQC_Vector_Copy_Int2Real(Vector)
          Vector%VecR(IndI:IndJ) = VectorIn%VecR
        ElseIf (VectorIn%Data_Type.eq.'Complex') then
          Call MQC_Vector_Copy_Int2Complex(Vector)
          Vector%VecC(IndI:IndJ) = VectorIn%VecC
        Else
          Call MQC_Error_A('VectorIn type not defined in MQC_Vector_Vector_Put', 6, &
               'VectorIn%Data_Type', VectorIn%Data_Type )
        EndIf
      ElseIf (Vector%Data_Type.eq.'Real') then
        If (VectorIn%Data_Type.eq.'Integer') then
          Vector%VecR(IndI:IndJ) = VectorIn%VecI
        ElseIf (VectorIn%Data_Type.eq.'Real') then
          Vector%VecR(IndI:IndJ) = VectorIn%VecR
        ElseIf (VectorIn%Data_Type.eq.'Complex') then
          Call MQC_Vector_Copy_Real2Complex(Vector)
          Vector%VecC(IndI:IndJ) = VectorIn%VecC
        Else
          Call MQC_Error_a('VectorIn type not defined in MQC_Vector_Vector_Put', 6, &
               'VectorIn%Data_Type', VectorIn%Data_Type )
        EndIf
      ElseIf (Vector%Data_Type.eq.'Complex') then
        If (VectorIn%Data_Type.eq.'Integer') then
          Vector%VecC(IndI:IndJ) = VectorIn%VecI
        ElseIf (VectorIn%Data_Type.eq.'Real') then
          Vector%VecC(IndI:IndJ) = VectorIn%VecR
        ElseIf (VectorIn%Data_Type.eq.'Complex') then
          Vector%VecC(IndI:IndJ) = VectorIn%VecC
        Else
          Call MQC_Error_A('VectorIn type not defined in MQC_Vector_Vector_Put', 6, &
               'VectorIn%Data_Type', VectorIn%Data_Type )
        EndIf
      Else
        Call MQC_Error_a('Vector type not defined in MQC_Vector_Vector_Put', 6, &
             'Vector%Data_Type', Vector%Data_Type )
      EndIf

      End Subroutine MQC_Vector_Vector_Put
!
!
!     PROCEDURE MQC_Vector_Initialize
!
!>    \brief <b> MQC_Vector_Initialize is a subroutine that initializes a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Initialize is a subroutine that initializes a MQC vector. Default
!>    element values are 0.0, or otherwise vector can be initialized with optional
!>    argument.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The MQC_Vector to intialize.
!>    \endverbatim
!>
!>    \param[in] Length
!>    \verbatim
!>        Length is Integer(kind=int64)
!>        The length to initialize vector
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        Value to set each element of Vector. If not present,
!>        the value is set to 0.0. Can be of type integer, real,
!>        complex or MQC_Scalar.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Initialize(Vector,Length,Scalar)
!
!     Variable Declarations.
!
      Implicit None
      Real(kind=real64)::Zero=0.0d0
      Integer(kind=int64),Intent(In)::Length
      Class(*),Optional::Scalar
      Class(MQC_Vector),Intent(InOut)::Vector

      If(Present(Scalar)) then
        Select Type (Scalar)
        Type is (Integer)
          Call MQC_Allocate_Vector(Length,Vector,'Integer')
          Vector%VecI = Scalar
        Type is (Real)
          Call MQC_Allocate_Vector(Length,Vector,'Real')
          Vector%VecR = Scalar
        Type is (Complex(Kind=real64))
          Call MQC_Allocate_Vector(Length,Vector,'Complex')
          Vector%VecC = Scalar
        Type is (MQC_Scalar)
          If(MQC_Scalar_HaveInteger(Scalar)) then
            Call MQC_Allocate_Vector(Length,Vector,'Integer')
            Vector%VecI = Scalar%ival()
          ElseIf(MQC_Scalar_HaveReal(Scalar)) then
            Call MQC_Allocate_Vector(Length,Vector,'Real')
            Vector%VecR = Scalar%rval()
          ElseIf(MQC_Scalar_HaveComplex(Scalar)) then
            Call MQC_Allocate_Vector(Length,Vector,'Complex')
            Vector%VecC = Scalar%cval()
          EndIf
        Class Default
          Call MQC_Error_I('Scalar Type not defined in MQC_Vector_Initialize', 6 )
        End Select
      Else
        Call MQC_Allocate_Vector(Length,Vector,'Real')
        Vector%VecR = Zero
      EndIf

      End Subroutine MQC_Vector_Initialize
!
!
!     PROCEDURE MQC_Vector_Set
!
!>    \brief <b> MQC_Vector_Set is a subroutine that sets an MQC vector to a value
!>    without resizing its dimensions</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Set is a subroutine that sets an MQC vector to a value without
!>    resizing its dimensions. Optional argument scalar specifies the value to set
!>    each element of the vector, where the default value is 0.0. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The MQC vector to set values of elements.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        The value to set each element of Vector. The default
!>        is 0.0.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      subroutine MQC_Vector_Set(vector,scalar)
!
!     Variable Declarations.
!
      implicit none
      class(MQC_Vector),intent(inOut)::vector
      class(*),optional::scalar
      integer(kind=int64)::length
      real(kind=real64)::zero=0.0d0
!
      length = size(vector) 
      if(present(scalar)) then
        select type (scalar)
        type is (integer)
          call mqc_allocate_vector(length,vector,'Integer')
          Vector%VecI = scalar
        type is (real)
          Call mqc_allocate_vector(length,vector,'Real')
            Vector%VecR = scalar
        type is (complex(kind=real64))
            call mqc_allocate_vector(length,vector,'Complex')
            Vector%VecC = scalar
        Type is (MQC_Scalar)
          If(MQC_Scalar_HaveInteger(Scalar)) then
            Call MQC_Allocate_Vector(length,vector,'Integer')
            Vector%VecI = Scalar%ScaI
          ElseIf(MQC_Scalar_HaveReal(Scalar)) then
            Call MQC_Allocate_Vector(length,vector,'Real')
            Vector%VecR = Scalar%ScaR
          ElseIf(MQC_Scalar_HaveComplex(Scalar)) then
            Call MQC_Allocate_Vector(length,Vector,'Complex')
            Vector%VecC = Scalar%ScaC
          Else
            Call MQC_Error_I('Unrecognized MQC scalar Type in MQC_Vector_Set', 6)
          EndIf
        class default
          call mqc_error_i('scalar type not defined in MQC_Vector_Set', 6)
        end select
      else
        if(Vector%Data_Type.eq.'Integer') then 
          vector%vecI = Zero
        elseIf(Vector%Data_Type.eq.'Real') then 
          vector%vecR = Zero
        elseIf(vector%Data_Type.eq.'Complex') then 
          vector%vecC = Zero
        endIf
      endIf

      End Subroutine MQC_Vector_Set
!
!
!     PROCEDURE MQC_ScalarVectorProduct
!
!>    \brief <b> MQC_ScalarVectorProduct is a function that returns the product of a
!>    MQC scalar with a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarVectorProduct is a function that returns the product of a MQC scalar 
!>    with a MQC vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar to multiply. 
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng      
!>    \author A. D. Mahler  
!>    \date 2017, 2019
!
      Function MQC_ScalarVectorProduct(Scalar,Vector) Result(Vector_Res)
!
      implicit none
      type(mqc_scalar),intent(in)::scalar
      type(mqc_vector),intent(in)::vector
      type(mqc_vector)::vector_res
      
      call mqc_deallocate_vector(vector_res)
      if (vector%Data_type.eq.'Integer') then
        if(scalar%Data_type.eq.'Integer') then
          call mqc_allocate_vector(vector%length,vector_res,'Integer')
          vector_res%veci = scalar%scai * vector%veci
        elseIf(scalar%Data_type.eq.'Real') then
          call mqc_allocate_vector(vector%length,vector_res,'Real')
          vector_res%vecr = scalar%scar * vector%veci
        elseIf(scalar%Data_type.eq.'Complex') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = scalar%scac * vector%veci
        else
          call mqc_error_a('unrecognised data type in mqc_vectorscalarproduct', 6, &
               'scalar%Data_type', scalar%Data_type )
        endIf
      elseIf(vector%Data_type.eq.'Real') then
        if(scalar%Data_type.eq.'Integer') then
          call mqc_allocate_vector(vector%length,vector_res,'Real')
          vector_res%vecr = scalar%scai * vector%vecr
        elseIf(scalar%Data_type.eq.'Real') then
          call mqc_allocate_vector(vector%length,vector_res,'Real')
          vector_res%vecr = scalar%scar * vector%vecr
        elseIf(scalar%Data_type.eq.'Complex') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = scalar%scac * vector%vecr
        else
          call mqc_error_a('unrecognised data type in mqc_vectorscalarproduct', 6, &
               'scalar%Data_type', scalar%Data_type )
        endIf
      elseIf(vector%Data_type.eq.'Complex') then
        if(scalar%Data_type.eq.'Integer') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = scalar%scai * vector%vecc
        elseIf(scalar%Data_type.eq.'Real') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = scalar%scar * vector%vecc
        elseIf(scalar%Data_type.eq.'Complex') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = scalar%scac * vector%vecc
        else
          call mqc_error_A('unrecognised data type in mqc_vectorscalarproduct', 6, &
               'scalar%Data_type', scalar%Data_type )
        endIf
      else
        call mqc_error_a('unrecognised data type in mqc_vectorscalarproduct', 6, &
             'vector%Data_type', vector%Data_type )
      endif

      end function mqc_ScalarVectorProduct
!
!     PROCEDURE MQC_VectorScalarProduct
!
!>    \brief <b> MQC_VectorScalarProduct is a function that returns the product of a
!>    MQC vector with a MQC scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorScalarProduct is a function that returns the product of a MQC vector 
!>    with a MQC scalar. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply. 
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng      
!>    \date 2017
!
      function mqc_VectorScalarProduct(vector,scalar) result(vector_res)
!
      implicit none
      type(mqc_scalar),intent(in)::scalar
      type(mqc_vector),intent(in)::vector
      type(mqc_vector)::vector_res

      vector_res = mqc_scalarvectorproduct(scalar,vector)

      end function mqc_VectorScalarProduct
!
!
!     PROCEDURE MQC_VectorScalarDivide
!
!>    \brief <b> MQC_VectorScalarDivide is a function that returns a MQC vector
!>    divided by a MQC scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorScalarDivide is a function that returns a MQC vector divided by a 
!>    MQC scalar.  
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to divide.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar to divide by.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author A. D. Mahler  
!>    \date 2019
!
      Function MQC_VectorScalarDivide(vector,scalar) Result(vector_res)
!
      implicit none
      type(mqc_vector),intent(in)::vector
      type(mqc_scalar),intent(in)::scalar
      type(mqc_vector)::vector_res
      type(mqc_scalar)::zero,neg_one,reciprocal

      zero = 0.0
      neg_one = -1.0

      if(scalar%abs() .le. zero) then 
        call mqc_error_a('Cannot divide by zero:', 6)
      else
        reciprocal = scalar
        reciprocal = reciprocal ** neg_one
      endif

      vector_res = MQC_VectorScalarProduct(vector,reciprocal)

      End Function MQC_VectorScalarDivide
!
!
!     PROCEDURE MQC_RealVectorProduct
!
!>    \brief <b> MQC_RealVectorProduct is a function that returns the product of an  
!>    intrinsic real scalar and a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealVectorProduct is a function that returns the product of an intrinsic 
!>    real scalar and a MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The real intrinsic to multiply.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealVectorProduct(RealIn,Vector) Result(Vector_Res)
!
        implicit none
        real(kind=real64),intent(in)::realIn
        type(mqc_vector),intent(in)::vector
        type(mqc_vector)::vector_res
        
        call mqc_deallocate_vector(vector_res)
        if (vector%Data_type.eq.'Integer') then
          call mqc_allocate_vector(vector%length,vector_res,'Real')
          vector_res%vecr = realIn * vector%veci
        elseIf(vector%Data_type.eq.'Real') then
          call mqc_allocate_vector(vector%length,vector_res,'Real')
          vector_res%vecr = realIn * vector%vecr
        elseIf(vector%Data_type.eq.'Complex') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = realIn * vector%vecc
        else
          call mqc_error_a('unrecognised data type in mqc_realvectorproduct', 6, &
               'vector%Data_type', vector%Data_type )
        endif

      end function mqc_RealVectorProduct
!
!
!     PROCEDURE MQC_VectorRealProduct
!
!>    \brief <b> MQC_VectorRealProduct is a function that returns the product of a  
!>    MQC vector and an intrinsic real scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorRealProduct is a function that returns the product of a MQC vector 
!>    and an intrinsic real scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply.
!>    \endverbatim
!>
!>    \param[in] RealIn
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The real intrinsic to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_VectorRealProduct(vector,realIn) result(vector_res)
!
      implicit none
      real(kind=real64),intent(in)::realIn
      type(mqc_vector),intent(in)::vector
      type(mqc_vector)::vector_res

      vector_res = mqc_realvectorproduct(realIn,vector)

      end function mqc_VectorRealProduct
!
!
!     PROCEDURE MQC_VectorRealDivide
!
!>    \brief <b> MQC_VectorRealDivide is a function that returns a MQC vector
!>    divided by an intrinsic real integer</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorRealDivide is a function that returns a MQC vector divided by an 
!>    intrinsic real scalar.  
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to divide.
!>    \endverbatim
!>
!>    \param[in] RealIn 
!>    \verbatim
!>        RealIn is Real(kind=real64)
!>        The intrinsic real scalar to divide by.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_VectorRealDivide(vector,realIn) Result(vector_res)
!
      implicit none
      type(mqc_vector),intent(in)::vector
      real(kind=real64),intent(in)::realIn
      type(mqc_vector)::vector_res
      real(kind=real64)::reciprocal
      type(mqc_scalar)::zero

      zero = 0.0

      if(abs(realIn).le.zero) then 
        call mqc_error_a('Cannot divide by zero:', 6)
      else
        reciprocal = realIn
        reciprocal = reciprocal ** (-1.0)
      endif

      vector_res = MQC_VectorRealProduct(vector,reciprocal)

      End Function MQC_VectorRealDivide
!
!
!     PROCEDURE MQC_IntegerVectorProduct
!
!>    \brief <b> MQC_IntegerVectorProduct is a function that returns the product of 
!>    an intrinsic integer scalar and a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerVectorProduct is a function that returns the product of an intrinsic 
!>    integer scalar and a MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer to multiply.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerVectorProduct(intIn,Vector) Result(Vector_Res)
!
      implicit none
      integer(kind=int64),intent(in)::intIn
      type(mqc_vector),intent(in)::vector
      type(mqc_vector)::vector_res
      
      call mqc_deallocate_vector(vector_res)
      if (vector%Data_type.eq.'Integer') then
        call mqc_allocate_vector(vector%length,vector_res,'Integer')
        vector_res%veci = intIn * vector%veci
      elseIf(vector%Data_type.eq.'Real') then
        call mqc_allocate_vector(vector%length,vector_res,'Real')
        vector_res%vecr = intIn * vector%vecr
      elseIf(vector%Data_type.eq.'Complex') then
        call mqc_allocate_vector(vector%length,vector_res,'Complex')
        vector_res%vecc = intIn * vector%vecc
      else
        call mqc_error_a('unrecognised data type in mqc_integervectorproduct', 6, &
             'vector%Data_type', vector%Data_type )
      endif

      end function mqc_IntegerVectorProduct
!
!
!     PROCEDURE MQC_VectorIntegerProduct
!
!>    \brief <b> MQC_VectorIntegerProduct is a function that returns the product of a  
!>    MQC vector and an intrinsic integer scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorIntegerProduct is a function that returns the product of a MQC vector 
!>    and an intrinsic integer scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply.
!>    \endverbatim
!>
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The integer intrinsic to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_VectorIntegerProduct(vector,intIn) result(vector_res)
!
      implicit none
      integer(kind=int64),intent(in)::intIn
      type(mqc_vector),intent(in)::vector
      type(mqc_vector)::vector_res

      vector_res = mqc_integervectorproduct(intIn,vector)

      end function mqc_VectorIntegerProduct
!
!
!     PROCEDURE MQC_VectorIntegerDivide
!
!>    \brief <b> MQC_VectorIntegerDivide is a function that returns a MQC vector
!>    divided by an intrinsic integer scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorIntegerDivide is a function that returns a MQC vector divided by an 
!>    intrinsic integer scalar.  
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to divide.
!>    \endverbatim
!>
!>    \param[in] IntIn 
!>    \verbatim
!>        IntIn is Integer(kind=int64)
!>        The intrinsic integer scalar to divide by.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_VectorIntegerDivide(vector,intIn) Result(vector_res)
!
      implicit none
      type(mqc_vector),intent(in)::vector
      integer(kind=int64),intent(in)::intIn
      type(mqc_vector)::vector_res
      integer(kind=int64)::reciprocal
      type(mqc_scalar)::zero

      zero = 0.0

      if(abs(intIn).le.zero) then 
        call mqc_error_a('Cannot divide by zero:', 6)
      else
        reciprocal = intIn
        reciprocal = reciprocal ** (-1)
      endif

      vector_res = MQC_VectorIntegerProduct(vector,reciprocal)

      End Function MQC_VectorIntegerDivide
!
!
!     PROCEDURE MQC_ComplexVectorProduct
!
!>    \brief <b> MQC_ComplexVectorProduct is a function that returns the product of 
!>    an intrinsic complex scalar and a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexVectorProduct is a function that returns the product of an intrinsic 
!>    integer scalar and a MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] CompIn
!>    \verbatim
!>        CompIn is Complex(kind=real64)
!>        The intrinsic complex to multiply.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ComplexVectorProduct(CompIn,Vector) Result(Vector_Res)
!
        implicit none
        complex(kind=real64),intent(in)::compIn
        type(mqc_vector),intent(in)::vector
        type(mqc_vector)::vector_res
        
        call mqc_deallocate_vector(vector_res)
        if (vector%Data_type.eq.'Integer') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = compIn * vector%veci
        elseIf(vector%Data_type.eq.'Real') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = compIn * vector%vecr
        elseIf(vector%Data_type.eq.'Complex') then
          call mqc_allocate_vector(vector%length,vector_res,'Complex')
          vector_res%vecc = compIn * vector%vecc
        else
          call mqc_error_a('unrecognised data type in mqc_realvectorproduct', 6, &
               'vector%Data_type', vector%Data_type )
        endif

      end function mqc_ComplexVectorProduct
!
!
!     PROCEDURE MQC_VectorComplexProduct
!
!>    \brief <b> MQC_VectorComplexProduct is a function that returns the product of a  
!>    MQC vector and an intrinsic complex scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorComplexProduct is a function that returns the product of a MQC vector 
!>    and an intrinsic complex scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to multiply.
!>    \endverbatim
!>
!>    \param[in] CompIn
!>    \verbatim
!>        CompIn is Complex(kind=real64)
!>        The integer complex to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_VectorComplexProduct(vector,compIn) result(vector_res)
!
      implicit none
      complex(kind=real64),intent(in)::compIn
      type(mqc_vector),intent(in)::vector
      type(mqc_vector)::vector_res

      vector_res = mqc_complexvectorproduct(compIn,vector)

      end function mqc_VectorComplexProduct
!
!
!     PROCEDURE MQC_VectorComplexDivide
!
!>    \brief <b> MQC_VectorComplexDivide is a function that returns a MQC vector
!>    divided by an intrinsic complex scalar</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorComplexDivide is a function that returns a MQC vector divided by an 
!>    intrinsic complex scalar.  
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector to divide.
!>    \endverbatim
!>
!>    \param[in] CompIn 
!>    \verbatim
!>        CompIn is Complex(kind=comp64)
!>        The intrinsic complex scalar to divide by.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_VectorComplexDivide(vector,compIn) Result(vector_res)
!
      implicit none
      type(mqc_vector),intent(in)::vector
      complex(kind=real64),intent(in)::compIn
      type(mqc_vector)::vector_res
      complex(kind=real64)::reciprocal
      type(mqc_scalar)::zero

      zero = 0.0

      if(abs(compIn).le.zero) then 
        call mqc_error_a('Cannot divide by zero:', 6)
      else
        reciprocal = compIn
        reciprocal = reciprocal ** (-1.0)
      endif

      vector_res = MQC_VectorComplexProduct(vector,reciprocal)

      End Function MQC_VectorComplexDivide
!
!
!     PROCEDURE MQC_Vector_Norm
!
!>    \brief <b> MQC_Vector_Norm is a function that returns the norm of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Norm is a function that returns the norm of an MQC vector. The 
!>    following options are available:
!>
!>    1. methodIn = 'M' uses the maximum absolute value max(abs(A(i))).
!>    2. methodIn = '1' uses the one norm.
!>    3. methodIn = 'I' uses the infinity norm.
!>    4. methodIn = 'F' uses the Frobenius norm (default).
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!>
!>    \param[in] MethodIn
!>    \verbatim
!>        MethodIn is Character(len=1)
!>        = 'M': max(abs(A(i)))
!>        = '1': one norm
!>        = 'I': infinity norm
!>        = 'F': Frobenius norm.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_Norm(vector,methodIn) result(norm)
!
!     Variable Declarations.
!
      implicit none
      class(MQC_Vector),intent(in)::vector
      character(len=1),optional,intent(in)::methodIn
      character(len=1)::method
      character(len=64)::TypeFlag
      real(kind=real64),dimension(:),allocatable::work
      real(kind=real64)::dlange,zlange
      real(kind=real64),dimension(:),allocatable::temp
      Complex(Kind=real64),dimension(:),allocatable::tempc
      Type(MQC_Scalar)::norm

      if(Present(methodIn)) method = methodIn
      if(.not.Present(methodIn)) method = 'F'
      if(method.eq.'I') allocate(work(max(1,MQC_Length_Vector(vector))))
      TypeFlag = vector%Data_Type
      If(vector%Data_Type.eq.'Integer'.or.vector%Data_Type.eq.'Real') then 
        If(vector%Data_Type.eq.'Integer') Call MQC_Vector_Copy_Int2Real(vector)
        Allocate(temp(MQC_Length_Vector(vector)))
        temp = vector%vecr
        norm = dlange(method,MQC_Length_Vector(vector),1,temp, &
          max(MQC_Length_Vector(vector),1),work)
        if(allocated(work)) deallocate(work)
        if(allocated(temp)) deallocate(temp)
        if(TypeFlag.eq.'Integer') Call MQC_Vector_Copy_Real2Int(vector)
      ElseIf(vector%Data_Type.eq.'Complex') then
        Allocate(tempc(MQC_Length_Vector(vector)))
        tempc = vector%vecc
        norm = zlange(method,MQC_Length_Vector(vector),1,tempc, &
          max(MQC_Length_Vector(vector),1),work)
        if(allocated(work)) deallocate(work)
        if(allocated(tempc)) deallocate(tempc)
      Else
        call mqc_error_a('unrecognised data type in mqc_vector_norm', 6, &
             'vector%Data_Type', vector%Data_Type )
      EndIf

      End Function MQC_Vector_Norm
!
!     PROCEDURE MQC_Vector_isAllocated
!
!>    \brief <b> MQC_Vector_isAllocated is a function that returns TRUE is an MQC
!>    vector is allocated and FALSE if it is not</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_isAllocated is a function that returns TRUE is an MQC vector is 
!>    allocated and FALSE if it is not.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_isAllocated(Vector) Result(isAllocated)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Vector),Intent(InOut)::Vector
      Logical::isAllocated
!
      isAllocated = .False.
      If(Allocated(Vector%VecR)) isAllocated = .True.
      If(Allocated(Vector%VecI)) isAllocated = .True.
      If(Allocated(Vector%VecC)) isAllocated = .True.
!
      Return
      End Function MQC_Vector_isAllocated
!
!
!     PROCEDURE MQC_Vector_Push
!
!>    \brief <b> MQC_Vector_Push is a function that adds a value to the end of a 
!>    MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Push is a function that adds a value to the end of a MQC vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar) 
!>        The value that will be added to the end of Vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Push(Vector,Scalar) 
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(inOut)::vector
      class(*),intent(in)::scalar
      type(mqc_scalar)::my_scalar
      type(mqc_vector)::temp
!
      select type (scalar)
      type is (integer)
        my_scalar = scalar
      type is (real)
        my_scalar = scalar
      type is (complex)
        my_scalar = scalar
      type is (mqc_scalar)
        my_scalar = scalar
      class default
        call mqc_error('Scalar type not defined in mqc_vector_push',6)
      end select
      
      if(mqc_length_vector(vector).eq.0) then
        call vector%init(1,scalar)
      else
        temp = vector
        call mqc_deallocate_vector(vector)
        call vector%init(mqc_length_vector(temp)+1,scalar)
        call vector%vput(temp)
        call vector%put(scalar,-1)
        call mqc_deallocate_vector(temp)
      endIf
!
      return
      end subroutine mqc_vector_push
!
!
!     PROCEDURE MQC_Vector_Unshift
!
!>    \brief <b> MQC_Vector_Unshift is a function that adds a value to the beginning
!>    of a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Unshift is a function that adds a value to the beginning of a MQC 
!>    vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar) 
!>        The value that will be added to the beginning of Vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Vector_Unshift(Vector,Scalar) 
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(inOut)::vector
      class(*),intent(in)::scalar
      type(mqc_scalar)::my_scalar
      type(mqc_vector)::temp
!
      select type (scalar)
      type is (integer)
        my_scalar = scalar
      type is (real)
        my_scalar = scalar
      type is (complex)
        my_scalar = scalar
      type is (mqc_scalar)
        my_scalar = scalar
      class default
        call mqc_error('Scalar type not defined in mqc_vector_push',6)
      end select
      
      if(mqc_length_vector(vector).eq.0) then
        call vector%init(1,scalar)
      else
        temp = vector
        call mqc_deallocate_vector(vector)
        call vector%init(mqc_length_vector(temp)+1,scalar)
        call vector%vput(temp,2)
        call vector%put(scalar,1)
        call mqc_deallocate_vector(temp)
      endIf
!
      return
      end subroutine mqc_vector_unshift
!
!
!     PROCEDURE MQC_Vector_Pop
!
!>    \brief <b> MQC_Vector_Pop is a function that removes a value from the end of
!>    a MQC vector and returns it</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Pop is a function that removes a value from the end of a MQC vector 
!>    and returns it.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_Pop(Vector) result(Output)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(inOut)::vector
      type(mqc_scalar)::output
      type(mqc_vector)::temp
!
      if(mqc_length_vector(vector).eq.0) then
        return
      else
        output = vector%at(-1)
        temp = vector%vat(1,-2)
        call mqc_deallocate_vector(vector)
        vector = temp
        call mqc_deallocate_vector(temp)
      endIf
!
      return
      end function mqc_vector_pop 
!
!
!     PROCEDURE MQC_Vector_Shift
!
!>    \brief <b> MQC_Vector_Shift is a function that removes a value from the 
!>    beginning of a MQC vector and returns it</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Shift is a function that removes a value from the beginning of a MQC 
!>    vector and returns it.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_Shift(Vector) result(Output)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(inOut)::vector
      type(mqc_scalar)::output
      type(mqc_vector)::temp
!
      if(mqc_length_vector(vector).eq.0) then
        return
      else
        output = vector%at(1)
        temp = vector%vat(2,-1)
        call mqc_deallocate_vector(vector)
        vector = temp
        call mqc_deallocate_vector(temp)
      endIf
!
      return
      end function mqc_vector_shift
!
!
!     PROCEDURE MQC_Vector_MaxVal
!
!>    \brief <b> MQC_Vector_MaxVal is a function that returns the largest value in  
!>    an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_MaxVal is a function that returns the largest value in an MQC 
!>    vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_MaxVal(Vector) result(Output)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(in)::vector
      type(mqc_scalar)::output
!
      if(mqc_length_vector(vector).eq.0) then
        return
      else
        if(mqc_have_real(vector)) then
          output = maxval(vector%vecr)
        elseIf(mqc_have_int(vector)) then
          output = maxval(vector%veci)
        elseIf(mqc_have_complex(vector)) then
          output = maxval(real(vector%vecc))
        endIf
      endIf
!
      return
      end function mqc_vector_maxval
!
!
!     PROCEDURE MQC_Vector_MinVal
!
!>    \brief <b> MQC_Vector_MinVal is a function that returns the smallest value in  
!>    an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_MinVal is a function that returns the smallest value in an MQC 
!>    vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Vector_MinVal(Vector) result(Output)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(in)::vector
      type(mqc_scalar)::output
!
      if(mqc_length_vector(vector).eq.0) then
        return
      else
        if(mqc_have_real(vector)) then
          output = minval(vector%vecr)
        elseIf(mqc_have_int(vector)) then
          output = minval(vector%veci)
        elseIf(mqc_have_complex(vector)) then
          output = minval(real(vector%vecc))
        endIf
      endIf
!
      return
      end function mqc_vector_minval
!
!
!     PROCEDURE MQC_Vector_MaxLoc
!
!>    \brief <b> MQC_Vector_MaxLoc is a function that returns the index of the 
!>    largest value in an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_MaxLoc is a function that returns the index of the largest value in 
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Vector_MaxLoc(Vector) result(Output)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(in)::vector
      integer,dimension(:),allocatable::tmpvec
      integer::i,output
!
      if(mqc_length_vector(vector).eq.0) then
        return
      else
        if(mqc_have_real(vector)) then
          tmpvec = maxloc(vector%vecr)
        elseIf(mqc_have_int(vector)) then
          tmpvec = maxloc(vector%veci)
        elseIf(mqc_have_complex(vector)) then
          tmpvec = maxloc(real(vector%vecc))
        endIf
      endIf
      output = tmpvec(1)
!
      return
      end function mqc_vector_maxloc
!
!
!     PROCEDURE MQC_Vector_MinLoc
!
!>    \brief <b> MQC_Vector_MinLoc is a function that returns the index of the 
!>    smallest value in an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_MinLoc is a function that returns the index of the smallest value 
!>    in an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Vector_MinLoc(Vector) result(Output)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(in)::vector
      integer(kind=int64),dimension(1)::tmpvec
      integer(kind=int64)::output
!
      if(mqc_length_vector(vector).eq.0) then
        return
      else
        if(mqc_have_real(vector)) then
          tmpvec = minloc(vector%vecr)
        elseIf(mqc_have_int(vector)) then
          tmpvec = minloc(vector%veci)
        elseIf(mqc_have_complex(vector)) then
          tmpvec = minloc(real(vector%vecc))
        endIf
      endIf
      output = tmpvec(1)
!
      return
      end function mqc_vector_minloc
!
!
!     PROCEDURE MQC_Vector_Argsort
!
!>    \brief <b> MQC_Vector_Argsort is a function that returns the indices of an
!>    an MQC vector sorted from low to high</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Argsort is a function that returns the indices of an MQC vector
!>    sorted from low to high.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Vector_ArgSort(Vector) result(Output)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(in)::vector
      type(mqc_vector)::output,tmpvec
      type(mqc_scalar)::one,ilowsca
      integer(kind=int64)::i,ilow
!
      one = 1.0
      if(mqc_length_vector(vector).eq.0) then
        return
      else
        tmpvec = vector
        call output%init(vector%size(),0)
        do i = 1, vector%size()
          ilow = minloc(tmpvec)
          ilowsca = ilow
          call output%put(ilowsca,i)
          call tmpvec%put(vector%maxval()+one,ilow)
        endDo
      endIf
!
      return
      end function mqc_vector_argsort
!
!
!     PROCEDURE MQC_Vector_Sort
!
!>    \brief <b> MQC_Vector_Sort is a function that returns an MQC vector sorted
!>    from low to high unless optional index order is present</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Sort is a function that returns an MQC vector sorted from low to 
!>    high unless optional argument idx is present which gives the new order of the 
!>    vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!>
!>    \param[in] idx
!>    \verbatim
!>        idx is Type(MQC_Vector),Optional
!>        The new order of indices after sort. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_Vector_Sort(Vector,idx)
!
!     Variable Declarations.
      implicit none
      class(mqc_vector),intent(inOut)::vector
      type(mqc_vector),intent(in),optional::idx
      type(mqc_vector)::my_idx,tmpvectr
      type(mqc_scalar)::iIn
      integer::i
!
      if(present(idx)) then
        my_idx = idx
      else
        my_idx = vector%argsort()
      endIf

      tmpvectr = vector
      do i = 1,vector%size()
        call vector%put(tmpvectr%at(MQC_Scalar_Get_Intrinsic_Integer(my_idx%at(i))),i)
      endDo
!
      return
      end subroutine mqc_vector_sort
!
!
!     PROCEDURE MQC_Vector_Sqrt
!
!>    \brief <b> MQC_Vector_Sqrt is a subroutine that returns the square root of all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Sqrt is a subroutine that returns the square root of all elements of
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      subroutine mqc_vector_sqrt(A)
!
      Implicit None
      class(mqc_vector),intent(inOut)::A
      integer(kind=int64)::i
!
!     Do the work.
!
      do i=1,MQC_Length_Vector(A)
        call A%put(sqrt(A%at(i)),i)
      endDo
!
      end subroutine mqc_vector_sqrt
!
!
!     PROCEDURE MQC_Vector_Exp 
!
!>    \brief <b> MQC_Vector_Exp is a subroutine that returns the exponential of all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Exp is a subroutine that returns the exponential of all elements of
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      subroutine mqc_vector_exp(A)
!
      Implicit None
      class(mqc_vector),intent(inOut)::A
      integer(kind=int64)::i
!
!     Do the work.
!
      do i=1,MQC_Length_Vector(A)
        call A%put(exp(A%at(i)),i)
      endDo
!
      end subroutine mqc_vector_exp
!
!
!     PROCEDURE MQC_Vector_Abs
!
!>    \brief <b> MQC_Vector_Abs is a subroutine that returns the absolute value of all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Abs is a subroutine that returns the absolute value of all elements of 
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      subroutine mqc_vector_abs(A) 
!
      Implicit None
      class(mqc_vector),intent(inOut)::A
      integer(kind=int64)::i
!
!     Do the work.
!
      do i=1,MQC_Length_Vector(A)
        call A%put(abs(A%at(i)),i)
      endDo
!
      end subroutine mqc_vector_abs
!
!
!     PROCEDURE MQC_Vector_Sqrt_Func
!
!>    \brief <b> MQC_Vector_Sqrt_func is a function that returns the square root of all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Sqrt_Func is a function that returns the square root of all elements of
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      function mqc_vector_sqrt_func(A) result(sqrtA)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      type(mqc_vector)::sqrtA
      integer(kind=int64)::i
!
!     Do the work.
!
      sqrtA = A
      do i=1,MQC_Length_Vector(A)
        call sqrtA%put(sqrt(sqrtA%at(i)),i)
      endDo
!
      end function mqc_vector_sqrt_func
!
!
!     PROCEDURE MQC_Vector_Exp_Func 
!
!>    \brief <b> MQC_Vector_Exp_Func is a function that returns the exponential of all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Exp_Func is a function that returns the exponential of all elements of
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      function mqc_vector_exp_func(A) result(expA)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      type(mqc_vector)::expA
      integer(kind=int64)::i
!
!     Do the work.
!
      expA = A
      do i=1,MQC_Length_Vector(A)
        call expA%put(exp(expA%at(i)),i)
      endDo
!
      end function mqc_vector_exp_func
!
!
!     PROCEDURE MQC_Vector_Abs_func
!
!>    \brief <b> MQC_Vector_Abs_func is a function that returns the absolute value of all
!>    elements of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Abs_Func is a function that returns the absolute value of all elements of 
!>    an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      function mqc_vector_abs_func(A) result(output)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      type(mqc_vector)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      call output%init(MQC_Length_Vector(A))
      do i=1,MQC_Length_Vector(A)
        call output%put(abs(A%at(i)),i)
      endDo
!
      end function mqc_vector_abs_func
!
!
!     PROCEDURE MQC_Vector_Power
!
!>    \brief <b> MQC_Vector_Power is a subroutine that returns the value of all
!>    elements of an MQC vector raised to a power</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Power is a subroutine that returns the value of all elements of an 
!>    MQC vector raised to a power. The power can be integer, real, complex or an
!>    MQC scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!>
!>    \param[in] P
!>    \verbatim
!>        P is Class(*)
!>        The power to raise elements of the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      subroutine mqc_vector_power(A,P)
!
      Implicit None
      class(mqc_vector),intent(inOut)::A
      class(*)::P
      integer(kind=int64)::i
      character(len=64)::data_type
      type(mqc_scalar)::scalar
!
!     Do the work.
!
      select type(P)
      type is (integer)
        scalar = P
      type is (real)
        scalar = P
      type is (complex)
        scalar = P
      type is (mqc_scalar)
        scalar = P
      class default
        call mqc_error_I('P type not defined in MQC_Vector_Power',6)
      end select
!
      do i=1,MQC_Length_Vector(A)
        call A%put(A%at(i)**scalar,i)
      endDo
!
      end subroutine mqc_vector_power
!
!
!     PROCEDURE MQC_Vector_Power_Func
!
!>    \brief <b> MQC_Vector_Power_Func is a function that returns the value of all
!>    elements of an MQC vector raised to a power</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Power_Func is a function that returns the value of all elements of 
!>    an MQC vector raised to a power. The power can be integer, real, complex or an
!>    MQC scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!>
!>    \param[in] P
!>    \verbatim
!>        P is Class(*)
!>        The power to raise elements of the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_vector_power_func(A,P) result(AOut)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      class(*),intent(in)::P
      type(mqc_vector)::AOut
      integer(kind=int64)::i
      character(len=64)::data_type
      type(mqc_scalar)::scalar
!
!     Do the work.
!
      data_type = A%data_type

      select type(P)
      type is (integer)
        scalar = P
      type is (real)
        scalar = P
      type is (complex)
        scalar = P
      type is (mqc_scalar)
        scalar = P
      class default
        call mqc_error_I('P type not defined in MQC_Vector_Power',6)
      end select
!
      AOut = A
      do i=1,MQC_Length_Vector(AOut)
        call AOut%put(AOut%at(i)**scalar,i)
      endDo
!
      end function mqc_vector_power_func
!
!
!     PROCEDURE MQC_Vector_Complex_RealPart
!
!>    \brief <b> MQC_Vector_Complex_RealPart is a function that returns a MQC vector
!>    with elements containing the real part of elements of another MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Complex_RealPart is a function that returns a MQC vector with 
!>    elements containing the real part of elements of another MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_vector_complex_realPart(A) result(output)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      type(mqc_vector)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      call output%init(MQC_Length_Vector(A))
      do i=1,MQC_Length_Vector(A)
        call output%put(real(A%at(i)),i)
      endDo
!
      end function mqc_vector_complex_realPart
!
!
!     PROCEDURE MQC_Vector_Complex_ImagPart
!
!>    \brief <b> MQC_Vector_Complex_ImagPart is a function that returns a MQC vector
!>    with elements containing the imaginary part of elements of another MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Complex_ImagPart is a function that returns a MQC vector with 
!>    elements containing the imaginary part of elements of another MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_vector_complex_imagPart(A) result(output)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      type(mqc_vector)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      call output%init(MQC_Length_Vector(A))
      do i=1,MQC_Length_Vector(A)
        call output%put(aimag(A%at(i)),i)
      endDo
!
      end function mqc_vector_complex_imagPart
!
!
!     PROCEDURE MQC_Vector_Cmplx
!
!>    \brief <b> MQC_Vector_Cmplx is a function that takes a MQC vector representing 
!>    the real part and a MQC vector representing the imaginary part and combines
!>    them into another MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Cmplx is a function that takes a MQC vector representing the real 
!>    part and a MQC vector representing the imaginary part and combines them into 
!>    another MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector1
!>    \verbatim
!>        Vector1 is Type(MQC_Vector)
!>        The MQC vector containing the real part.
!>    \endverbatim
!>
!>    \param[in] Vector2
!>    \verbatim
!>        Vector2 is Type(MQC_Vector)
!>        The MQC vector containing the imaginary part.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Vector_Cmplx(Vector1,Vector2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector)::MQC_Vector_Cmplx
      Type(MQC_Vector),Intent(In)::Vector1,Vector2
!
      If(Vector1%Data_type.eq.'Real') then
        If(Vector2%Data_type.eq.'Real') then
          MQC_Vector_Cmplx = Cmplx(Vector1%vecR,Vector2%vecR)
        ElseIf(Vector2%Data_type.eq.'Integer') then
#ifdef PGI
          MQC_Vector_Cmplx = Cmplx(Vector1%vecR,dFloat(Vector2%vecI))
#else
          MQC_Vector_Cmplx = Cmplx(Vector1%vecR,Float(Vector2%vecI))
#endif
        ElseIf(Vector2%Data_Type.eq.'Complex') then
          Call MQC_Error_A('Complex MQC Vector type cannot be set as real/imaginary part in MQC_Vector_Cmplx', 6, &
             'Vector1%Data_Type', Vector1%Data_Type, 'Vector2%Data_Type', Vector2%Data_Type)
        Else
          Call MQC_Error_A('Vector type unspecified in MQC_Vector_Cmplx', 6, &
             'Vector1%Data_Type', Vector1%Data_Type, 'Vector2%Data_Type', Vector2%Data_Type)
        EndIf
      ElseIf(Vector1%Data_Type.eq.'Integer') then
        If(Vector2%Data_type.eq.'Real') then
#ifdef PGI
          MQC_Vector_Cmplx = Cmplx(dFloat(Vector1%vecI),Vector2%vecR)
#else
          MQC_Vector_Cmplx = Cmplx(Float(Vector1%vecI),Vector2%vecR)
#endif
        ElseIf(Vector2%Data_type.eq.'Integer') then
#ifdef PGI
          MQC_Vector_Cmplx = Cmplx(dFloat(Vector1%vecI),dFloat(Vector2%vecI))
#else
          MQC_Vector_Cmplx = Cmplx(Float(Vector1%vecI),Float(Vector2%vecI))
#endif
        ElseIf(Vector2%Data_Type.eq.'Complex') then
          Call MQC_Error_A('Complex MQC Vector type cannot be set as real/imaginary part in MQC_Vector_Cmplx', 6, &
             'Vector1%Data_Type', Vector1%Data_Type, 'Vector2%Data_Type', Vector2%Data_Type)
        Else
          Call MQC_Error_A('Vector type unspecified in MQC_Vector_Cmplx', 6, &
             'Vector1%Data_Type', Vector1%Data_Type, 'Vector2%Data_Type', Vector2%Data_Type)
        EndIf
      ElseIf(Vector1%Data_Type.eq.'Complex'.or.Vector2%Data_Type.eq.'Complex') then
        Call MQC_Error_A('Complex MQC Vector type cannot be set as real/imaginary part in MQC_Vector_Cmplx', 6, &
             'Vector1%Data_Type', Vector1%Data_Type, 'Vector2%Data_Type', Vector2%Data_Type)
      Else
        Call MQC_Error_A('Vector type unspecified in MQC_Vector_Cmplx', 6, &
             'Vector1%Data_Type', Vector1%Data_Type, 'Vector2%Data_Type', Vector2%Data_Type)
      EndIf
!
      Return
      End Function MQC_Vector_Cmplx
!
!
!     PROCEDURE MQC_Vector_Sum
!
!>    \brief <b> MQC_Vector_Sum is a function that returns the sum of all elements 
!>    of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Sum is a function that returns the sum of all elements of an MQC
!>    vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      function mqc_vector_sum(A) result(output)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      type(mqc_scalar)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      output = 0.0
      do i=1,MQC_Length_Vector(A)
        output = output + A%at(i)
      endDo
!
      end function mqc_vector_sum
!
!
!     PROCEDURE MQC_Vector_Product
!
!>    \brief <b> MQC_Vector_Product is a function that returns the product of all elements 
!>    of an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Vector_Product is a function that returns the sum of all elements of an MQC
!>    vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      function mqc_vector_product(A) result(output)
!
      Implicit None
      class(mqc_vector),intent(in)::A
      type(mqc_scalar)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      output = 1.0
      do i=1,MQC_Length_Vector(A)
        output = output * A%at(i)
      endDo
!
      end function mqc_vector_product
!
!
!     PROCEDURE MQC_Vector_Complex_Conjugate
!
!>    \brief <b> MQC_Vector_Complex_Conjugate is a function that returns the complex conjugate 
!>    of an MQC_Vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Complex_Conjugate is a function that returns the complex conjugate of an 
!>    MQC_Vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC_Vector input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_Vector_Complex_Conjugate(VectorIn) Result(VectorOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::VectorIn
      Type(MQC_Vector)::VectorOut
!
      If(VectorIn%Data_Type.eq.'Complex') then
        VectorOut = conjg(VectorIn%VecC)
      Else
        VectorOut = VectorIn
      EndIf
!
      Return
      End Function MQC_Vector_Complex_Conjugate
!
!
!     PROCEDURE MQC_Vector_Reshape_Matrix
!
!>    \brief <b> MQC_Vector_Reshape_Matrix is a function that reshapes an MQC vector as an
!>    MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector_Reshape_Matrix is a function that reshapes an MQC vector as an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The MQC_Vector input variable.
!>    \endverbatim
!>
!>    \param[in] DimArr
!>    \verbatim
!>        DimArr is Type(MQC_Vector)
!>        The dimensions of the MQC Matrix output.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_Vector_Reshape_Matrix(VectorIn,DimArr) Result(MatrixOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64),dimension(2),intent(in)::DimArr
      type(MQC_Matrix)::MatrixOut
      integer(kind=int64),dimension(:),allocatable::intVector
      real(kind=real64),dimension(:),allocatable::realVector
      complex(kind=real64),dimension(:),allocatable::compVector
!
      If(Size(VectorIn).gt.(DimArr(1)*DimArr(2))) Call MQC_Error_I('Vector not conformable &
        &with requested dimensions',6,'Size(VectorIn)',Size(VectorIn),'DimArr(1)*DimArr(2)',&
        DimArr(1)*DimArr(2))
!
      select case(VectorIn%Data_Type)
      case('Integer')
        intVector = VectorIn
        MatrixOut = reshape(intVector,[DimArr(1),DimArr(2)]) 
      case('Real')
        realVector = VectorIn
        MatrixOut = reshape(realVector,[DimArr(1),DimArr(2)]) 
      case('Complex')
        compVector = VectorIn
        MatrixOut = reshape(compVector,[DimArr(1),DimArr(2)]) 
      case default
        call mqc_error_a('Unrecognized data type in VectorIn in MQC_Vector_Reshape_Matrix',6,&
          'VectorIn%Data_Type',VectorIn%Data_Type)
      end select
!
      Return
      End Function MQC_Vector_Reshape_Matrix
!
!
!     PROCEDURE MQC_ScalarEQVector
!
!>    \brief <b> MQC_ScalarEQVector is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is equal to the MQC_Scalar
!>    and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarEQVector is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is equal to the MQC_Scalar and elements 
!>    FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2024
!
      Function MQC_ScalarEQVector(Scalar,Vector) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Vector),Intent(In)::Vector
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).eq.scalar) output(i) = .true.
      endDo
!
      Return
      End Function MQC_ScalarEQVector
!
!
!     PROCEDURE MQC_VectorEQScalar
!
!>    \brief <b> MQC_VectorEQScalar is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is equal to the MQC_Scalar
!>    and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorEQScalar is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is equal to the MQC_Scalar and elements 
!>    FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2024
!
      Function MQC_VectorEQScalar(Vector,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::Vector
      Type(MQC_Scalar),Intent(In)::Scalar
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).eq.scalar) output(i) = .true.
      endDo
!
      Return
      End Function MQC_VectorEQScalar
!
!
!     PROCEDURE MQC_IntegerEQVector
!
!>    \brief <b> MQC_IntegerEQVector is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is equal to the integer
!>    and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerEQVector is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is equal to the integer and elements 
!>    FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Integr
!>    \verbatim
!>        Integr is Integer(kind=int64)
!>        The integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2024
!
      Function MQC_IntegerEQVector(Integr,Vector) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::Integr
      Type(MQC_Vector),Intent(In)::Vector
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).eq.integr) output(i) = .true.
      endDo
!
      Return
      End Function MQC_IntegerEQVector
!
!
!     PROCEDURE MQC_VectorEQInteger
!
!>    \brief <b> MQC_VectorEQInteger is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is equal to the integer
!>    and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorEQInteger is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is equal to the integer and elements 
!>    FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!>
!>    \param[in] Integr
!>    \verbatim
!>        Integr is Type(MQC_Scalar)
!>        The integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2024
!
      Function MQC_VectorEQInteger(Vector,Integr) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::Vector
      Integer(kind=int64),Intent(In)::Integr
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).eq.integr) output(i) = .true.
      endDo
!
      Return
      End Function MQC_VectorEQInteger
!
!
!     PROCEDURE MQC_ScalarGEVector
!
!>    \brief <b> MQC_ScalarGEVector is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is greater than or equal 
!>    to the MQC_Scalar and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarGEVector is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is greater than or equal to the MQC_Scalar 
!>    and elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_ScalarGEVector(Scalar,Vector) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Vector),Intent(In)::Vector
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).ge.scalar) output(i) = .true.
      endDo
!
      Return
      End Function MQC_ScalarGEVector
!
!
!     PROCEDURE MQC_VectorGEScalar
!
!>    \brief <b> MQC_VectorGEScalar is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is greater than or equal 
!>    to the MQC_Scalar and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorGEScalar is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is greater than or equal to the MQC_Scalar 
!>    and elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_VectorGEScalar(Vector,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::Vector
      Type(MQC_Scalar),Intent(In)::Scalar
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).ge.scalar) output(i) = .true.
      endDo
!
      Return
      End Function MQC_VectorGEScalar
!
!
!     PROCEDURE MQC_IntegerGEVector
!
!>    \brief <b> MQC_IntegerGEVector is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is greater than or equal 
!>    to the integer and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerGEVector is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is greater than or equal to the integer 
!>    and elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Integr
!>    \verbatim
!>        Integr is Integer(kind=int64)
!>        The integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_IntegerGEVector(Integr,Vector) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::Integr
      Type(MQC_Vector),Intent(In)::Vector
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).ge.integr) output(i) = .true.
      endDo
!
      Return
      End Function MQC_IntegerGEVector
!
!
!     PROCEDURE MQC_VectorGEInteger
!
!>    \brief <b> MQC_VectorGEInteger is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is greater than or equal 
!>    to the integer and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorGEInteger is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is greater than or equal to the integer 
!>    and elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!>
!>    \param[in] Integr
!>    \verbatim
!>        Integr is Type(MQC_Scalar)
!>        The integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_VectorGEInteger(Vector,Integr) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::Vector
      Integer(kind=int64),Intent(In)::Integr
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).ge.integr) output(i) = .true.
      endDo
!
      Return
      End Function MQC_VectorGEInteger
!
!
!     PROCEDURE MQC_ScalarLEVector
!
!>    \brief <b> MQC_ScalarLEVector is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is less than or equal 
!>    to the MQC_Scalar and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarLEVector is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is less than or equal to the MQC_Scalar 
!>    and elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_ScalarLEVector(Scalar,Vector) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Vector),Intent(In)::Vector
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).le.scalar) output(i) = .true.
      endDo
!
      Return
      End Function MQC_ScalarLEVector
!
!
!     PROCEDURE MQC_VectorLEScalar
!
!>    \brief <b> MQC_VectorLEScalar is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is less than or equal 
!>    to the MQC_Scalar and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorLEScalar is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is less than or equal to the MQC_Scalar 
!>    and elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC_Scalar that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_VectorLEScalar(Vector,Scalar) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::Vector
      Type(MQC_Scalar),Intent(In)::Scalar
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).le.scalar) output(i) = .true.
      endDo
!
      Return
      End Function MQC_VectorLEScalar
!
!
!     PROCEDURE MQC_IntegerLEVector
!
!>    \brief <b> MQC_IntegerLEVector is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is less than or equal 
!>    to the integer and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerLEVector is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is less than or equal to the integer and 
!>    elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Integr
!>    \verbatim
!>        Integr is Integer(kind=int64)
!>        The integer that will be tested.
!>    \endverbatim
!>
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_IntegerLEVector(Integr,Vector) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::Integr
      Type(MQC_Vector),Intent(In)::Vector
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).le.integr) output(i) = .true.
      endDo
!
      Return
      End Function MQC_IntegerLEVector
!
!
!     PROCEDURE MQC_VectorLEInteger
!
!>    \brief <b> MQC_VectorLEInteger is a function that returns a logical array 
!>    with elements TRUE if the element of an MQC_Vector is less than or equal to 
!>    the integer and elements FALSE otherwise</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorLEInteger is a function that returns a logical array with elements 
!>    TRUE if the element of an MQC_Vector is less than or equal to the integer and 
!>    elements FALSE otherwise.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Type(MQC_Vector)
!>        The MQC_Vector that will be tested.
!>    \endverbatim
!>
!>    \param[in] Integr
!>    \verbatim
!>        Integr is Type(MQC_Scalar)
!>        The integer that will be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2025
!
      Function MQC_VectorLEInteger(Vector,Integr) Result(Output)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Vector),Intent(In)::Vector
      Integer(kind=int64),Intent(In)::Integr
      Logical,Dimension(:),Allocatable::Output
      integer::i
!
      allocate(output(size(vector)))
      output = .false.
      do i = 1, size(output)
        if(vector%at(i).le.integr) output(i) = .true.
      endDo
!
      Return
      End Function MQC_VectorLEInteger
!
!
!----------------------------------------------------------------
!                                                               |
!     MATRIX PROCEDURES                                         |
!                                                               |
!----------------------------------------------------------------
!
!     PROCEDURE MQC_Matrix_Diagonalize
!
!>    \brief <b> MQC_Matrix_Diagonalize is a subroutine that takes a symmetric, 
!>    hermitian, antisymmetric or antihermitian MQC matrix and returns eigenvalues 
!>    and eigenvectors</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Diagonalize is a subroutine that takes a symmetric, hermitian, 
!>    antisymmetric or antihermitian MQC matrix and optionally returns eigenvalues 
!>    to a MQC vector and/or eigenvectors to a MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to diagonalize. 
!>    \endverbatim
!>
!>    \param[in,out] EVals
!>    \verbatim
!>        EVals is Type(MQC_Vector),Optional
!>        Optional MQC vector containing the eigenvalues.
!>    \endverbatim
!>
!>    \param[in,out] EVecs
!>    \verbatim
!>        EVecs is Type(MQC_Matrix),Optional
!>        Optional MQC matrix containing the eigenvectors.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \author L. M. Thompson
!>    \date 2017
!
      recursive Subroutine MQC_Matrix_Diagonalize(A,EVals,EVecs)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::A
      Type(MQC_Matrix)::B
      Type(MQC_Matrix),Optional,Intent(InOut)::EVecs
      Type(MQC_Vector),Optional,Intent(InOut)::EVals
      Real(kind=real64),Dimension(:,:),allocatable::A_EVecs
      Complex(Kind=real64),Dimension(:,:),allocatable::AC_EVecs
      Real(kind=real64),Dimension(:),allocatable::A_EVals
      Complex(kind=real64),Dimension(:),allocatable::AC_EVals
!
      Integer(kind=int64)::NDim,i,j,k,IError=1
      Real(kind=real64),Dimension(:),Allocatable::A_Symm,Temp_Vector
      Complex(Kind=real64),Dimension(:),Allocatable::AC_Symm,TempC_Vector
      character(len=64)::typeFlag
      Real(kind=real64),Parameter::Zero=1.0E-8
!
      if(mqc_matrix_test_symmetric(A,'antihermitian',.true.).and.&
        A%norm().gt.Zero) then
        call MQC_Matrix_Diagonalize(im*A,EVals,EVecs)
        EVals = (-1)*im*EVals
        return
      endIf
!
      typeFlag = a%Data_Type
      if (A%data_type.eq.'Real'.or.A%data_type.eq.'Integer') then
        if(A%data_type.eq.'Integer') call mqc_matrix_copy_int2Real(A)
        if (A%storage .eq. 'StorFull') then
          if(.not.mqc_matrix_test_symmetric(A,'symmetric',.true.)) &
            call mqc_error_l('Input matrix not symmetric in MQC_Matrix_Diagonalize', 6, &
            'mqc_matrix_test_symmetric(A)', mqc_matrix_test_symmetric(A) )
          if (A%NRow .eq. A%NCol) then
            Allocate(A_Symm((A%NRow*(A%NRow+1))/2),Temp_Vector(3*A%NRow),A_EVecs(A%NRow,A%NRow),A_EVals(A%NRow))
            Do i = 1,A%NRow
              Do j = 1,i
                A_Symm(i+(j-1)*(2*A%NRow-j)/2) = A%matR(i,j)
              EndDo
            EndDo
            Call DSPEV('V','L',A%NRow,A_Symm,A_EVals,A_EVecs,A%NRow,Temp_Vector,IError)
            If(IError.ne.0) then
              call mqc_error_i('Diagonalization error: the lapack routine DSPEV failed', 6, &
                 'IError', IError )
            endif
            DeAllocate(A_Symm)
          else
            call mqc_error_I('Diagonalization error: the matrix being passed is not square', 6, &
                 'A%NRow', A%NRow, &
                 'A%NCol', A%NCol )
          endif
        else if (A%storage .eq. 'StorSymm' .or. A%storage .eq. 'StorHerm') then
          Allocate(A_Symm((A%NRow*(A%NRow+1))/2),Temp_Vector(3*A%NRow),A_EVecs(A%NRow,A%NRow),A_EVals(A%NRow))
          A_Symm = A%matR(:,1)
          call DSPEV('V','U',A%NRow,A_Symm,A_EVals,A_EVecs,A%NRow,Temp_Vector,IError)
          If(IError.ne.0) then
            call mqc_error_I('Diagonalization error: the lapack routine DSPEV failed', 6, &
                 'IError', IError )
          endif
          DeAllocate(A_Symm)
        elseIf (A%storage .eq. 'StorDiag') then
          Allocate(A_EVecs(A%NRow,A%NRow),A_EVals(A%NRow))
          A_EVals = A%matR(:,1)
          A_EVecs = 0.0
          Do i = 1,A%NRow
            A_EVecs(i,i) = 1.0
          EndDo
        else
          call mqc_error_a('Storage type not compatible in mqc_matrix_diag',6,'A%storage',A%storage)
        endif
        if(typeFlag.eq.'Integer') Call MQC_Matrix_Copy_Real2Int(A)
      elseIf(A%data_type.eq.'Complex') then

        if(A%storage.eq.'StorFull') then
          if(.not.mqc_matrix_test_symmetric(A,'hermitian',.true.)) &
            call mqc_error_L('Input matrix not Hermitian in MQC_Matrix_Diagonalize',6, &
            "mqc_matrix_test_symmetric(A,'hermitian',.true.)",mqc_matrix_test_symmetric(A,'hermitian',.true.))
          if (A%NRow .eq. A%NCol) then
            allocate(AC_Symm((A%NRow*(A%NRow+1))/2),TempC_Vector(Max(1,2*A%NRow-1)),Temp_Vector(Max(1,3*A%NRow-2)), &
              AC_EVecs(A%NRow,A%NRow),A_EVals(A%NRow))
            k = 0
            do i = 1,A%NRow
              do j = 1,i
                k = k+1
                AC_Symm(k) = A%matC(j,i)
              endDo
            endDo
            call ZHPEV('V','U',A%NRow,AC_Symm,A_EVals,AC_EVecs,A%NRow,TempC_Vector,Temp_Vector,IError)
            if(IError.ne.0) then
              call mqc_error_i('Diagonalization error: the lapack routine ZHPEV failed', 6, &
                 'IError', IError )
            endIf
            deallocate(AC_Symm)
          else
            call mqc_error_i('Diagonalization error: the matrix being passed is not square', 6, &
                 'A%NRow', A%NRow, &
                 'A%NCol', A%NCol )
          endif
        elseIf (A%storage .eq. 'StorHerm' .or. A%storage .eq. 'StorSymm') then
          if(.not.mqc_matrix_test_symmetric(A,'hermitian',.true.)) &
            call mqc_error_L('Input matrix not Hermitian in MQC_Matrix_Diagonalize',6, &
            "mqc_matrix_test_symmetric(A,'hermitian',.true.)",mqc_matrix_test_symmetric(A,'hermitian',.true.))
          allocate(AC_Symm((A%NRow*(A%NRow+1))/2),TempC_Vector(max(1,2*A%NRow-1)),Temp_Vector(max(1,3*A%NRow-2)),&
            AC_EVecs(A%NRow,A%NRow),A_EVals(A%NRow))
          do i = 1,A%NRow
            do j = 1,i
              AC_Symm(i+(j-1)*(2*A%NRow-j)/2) = A%matC(symIndexHash(i,j),1) 
            endDo
          endDo
          call ZHPEV('V','L',A%NRow,AC_Symm,A_EVals,AC_EVecs,A%NRow,TempC_Vector,Temp_Vector,IError)
          if(IError.ne.0) then
            call mqc_error_i('Diagonalization error: the lapack routine ZHPEV failed', 6, &
                 'IError', IError )
          endIf
          deallocate(AC_Symm)
        elseIf (A%storage .eq. 'StorDiag') then
          if(.not.mqc_matrix_test_symmetric(A,'hermitian',.true.)) &
            call mqc_error_L('Input matrix not Hermitian in MQC_Matrix_Diagonalize',6, &
            "mqc_matrix_test_symmetric(A,'hermitian',.true.)",mqc_matrix_test_symmetric(A,'hermitian',.true.))
          Allocate(AC_EVecs(A%NRow,A%NRow),AC_EVals(A%NRow))
          AC_EVals = A%matC(:,1)
          AC_EVecs = 0.0
          Do i = 1,A%NRow
            AC_EVecs(i,i) = 1.0
          EndDo
        else
          call mqc_error_a('Storage type not compatible in mqc_matrix_diag',6,'A%storage',A%storage)
        endIf
      else
        call mqc_error_A('data type not recognsed in mqc_matrix_diagonalize', 6, &
             'A%data_type', A%data_type )
      endIf

      if(present(EVecs)) then
        if(allocated(A_EVecs)) then
          do i = 1,A%NRow
            call mqc_vectorPhase(A_EVecs(:,i),.True.)
          endDo
          EVecs = A_EVecs
        elseIf(allocated(AC_EVecs)) then
          EVecs = AC_EVecs
        endIf
      endIf
      if(present(EVals)) then
        if(allocated(A_EVals)) then
          EVals = A_EVals
        elseif(allocated(AC_EVals)) then
          EVals = AC_EVals
        endIf
      endIf
      if(allocated(A_EVecs)) deallocate(A_EVecs)
      if(allocated(AC_EVecs)) deallocate(AC_EVecs)
      if(allocated(A_EVals)) deallocate(A_EVals)
      if(allocated(AC_EVals)) deallocate(AC_EVals)
      if(allocated(Temp_Vector)) deallocate(Temp_Vector)
      if(allocated(TempC_Vector)) deallocate(TempC_Vector)
!
      Return
      End Subroutine MQC_Matrix_Diagonalize
!
!     PROCEDURE MQC_Matrix_Cast_Real
!
!>    \brief <b> MQC_Matrix_Cast_Real is a function that converts an MQC matrix to
!>    its real space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Cast_Real is a function that converts an MQC matrix to its real 
!>    space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MA
!>    \verbatim
!>        MA is Type(MQC_Matrix)
!>        The MQC matrix to convert.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_Matrix_Cast_Real(MA) Result(MB)
!
      Implicit None
      Type(MQC_Matrix),Intent(In)::MA
      Type(MQC_Matrix)::MB

      Call MQC_Allocate_Matrix(MA%NRow,MA%NCol,MB,'Real',MA%Storage)
      if(mqc_have_int(MA)) then
        MB%MatR = MA%MatI
      elseif(mqc_have_complex(MA)) then
        MB%MatR = MA%MatC
      endif

      End Function MQC_Matrix_Cast_Real
!
!     PROCEDURE MQC_R4Tensor_Cast_Real
!
!>    \brief <b> MQC_R4Tensor_Cast_Real is a function that converts an MQC r4tensor to
!>    its real space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Cast_Real is a function that converts an MQC r4tensor to its real 
!>    space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RA
!>    \verbatim
!>        RA is Type(MQC_R4Tensor)
!>        The MQC r4tensor to convert.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2024
!
      Function MQC_R4Tensor_Cast_Real(RA) Result(RB)
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::RA
      Type(MQC_R4Tensor)::RB

      Call MQC_Allocate_R4Tensor(MQC_R4Tensor_Size(RA,1),MQC_R4Tensor_Size(RA,2),&
                                 MQC_R4Tensor_Size(RA,3),MQC_R4Tensor_Size(RA,4),&
                                 RB,'Real',RA%Storage)
      if(mqc_have_int(RA)) then
        RB%RTen = RA%ITen
      elseif(mqc_have_complex(RA)) then
        RB%RTen = RA%CTen
      endif

      End Function MQC_R4Tensor_Cast_Real
!
!
!
!     PROCEDURE MQC_Matrix_Cast_Integer
!
!>    \brief <b> MQC_Matrix_Cast_Integer is a function that converts an MQC matrix to
!>    its integer space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Cast_Integer is a function that converts an MQC matrix to its 
!>    integer space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MA
!>    \verbatim
!>        MA is Type(MQC_Matrix)
!>        The MQC matrix to convert.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Matrix_Cast_Integer(MA) Result(MB)
!
      Implicit None
      Type(MQC_Matrix),Intent(In)::MA
      Type(MQC_Matrix)::MB

      Call MQC_Allocate_Matrix(MA%NRow,MA%NCol,MB,'Integer',MA%Storage)
      if(mqc_have_real(MA)) then
        MB%MatI = MA%MatR
      elseIf(mqc_have_complex(MA)) then
        MB%MatI = MA%MatC
      endIf

      End Function MQC_Matrix_Cast_Integer
!
!
!     PROCEDURE MQC_Matrix_Cast_Complex
!
!>    \brief <b> MQC_Matrix_Cast_Complex is a function that converts an MQC matrix to
!>    its complex space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Cast_Complex is a function that converts an MQC matrix to its 
!>    complex space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MA
!>    \verbatim
!>        MA is Type(MQC_Matrix)
!>        The MQC matrix to convert.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_Cast_Complex(MA) Result(MB)
!
      Implicit None
      Type(MQC_Matrix),Intent(In)::MA
      Type(MQC_Matrix)::MB

      Call MQC_Allocate_Matrix(MA%NRow,MA%NCol,MB,'Complex',MA%Storage)
      if(mqc_have_int(MA)) then
        MB%MatC = MA%MatI
      elseIf(mqc_have_real(MA)) then
        MB%MatC = MA%MatR
      endIf

      End Function MQC_Matrix_Cast_Complex
!
!
!     PROCEDURE MQC_Matrix_Scalar_At_Scalar
!
!>    \brief <b> MQC_Matrix_Scalar_At_Scalar is a function that returns the value of 
!>    an element of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_At_Scalar is a function that returns the value of (I,J)th 
!>    element of a MQC matrix as an MQC scalar using scalar indices. If I or J is 
!>    negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix to return the value of the (I,J)th 
!>        element.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Type(MQC_Scalar)
!>        The row of the element in MQC matrix. 
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Type(MQC_Scalar)
!>        The column of the element in MQC matrix.
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_Matrix_Scalar_At_Scalar(Mat,I,J) Result(Element)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Mat
      Type(MQC_Scalar)::Element
      Type(MQC_Scalar),Intent(In)::I,J
      Integer(kind=int64)::IndI,IndJ

      IndI=I
      IndJ=J
      Element = MQC_Matrix_Scalar_At_Int(Mat,IndI,IndJ)

      End Function
!
!
!     PROCEDURE MQC_Matrix_Scalar_At_ScaInt
!
!>    \brief <b> MQC_Matrix_Scalar_At_ScaInt is a function that returns the value of 
!>    an element of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_At_ScaInt is a function that returns the value of (I,J)th 
!>    element of a MQC matrix as an MQC scalar one scalar and one integer index. If 
!>    I or J is negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix to return the value of the (I,J)th 
!>        element.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Type(MQC_Scalar)
!>        The row of the element in MQC matrix. 
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Integer
!>        The column of the element in MQC matrix.
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_Matrix_Scalar_At_ScaInt(Mat,I,J) Result(Element)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Mat
      Type(MQC_Scalar)::Element
      Type(MQC_Scalar),Intent(In)::I
      Integer,Intent(In)::J
      Integer(kind=int64)::IndI,IndJ

      IndI=I
      IndJ=J
      Element = MQC_Matrix_Scalar_At_Int(Mat,IndI,IndJ)

      End Function
!
!
!     PROCEDURE MQC_Matrix_Scalar_At_IntSca
!
!>    \brief <b> MQC_Matrix_Scalar_At_IntSca is a function that returns the value of 
!>    an element of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_At_IntSca is a function that returns the value of (I,J)th 
!>    element of a MQC matrix as an MQC scalar using an integer and a scalar index. 
!>    If I or J is negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix to return the value of the (I,J)th 
!>        element.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Integer
!>        The row of the element in MQC matrix. 
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Type(MQC_Scalar)
!>        The column of the element in MQC matrix.
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_Matrix_Scalar_At_IntSca(Mat,I,J) Result(Element)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Mat
      Type(MQC_Scalar)::Element
      Integer,Intent(In)::I
      Type(MQC_Scalar),Intent(In)::J
      Integer(kind=int64)::IndI,IndJ

      IndI=I
      IndJ=J
      Element = MQC_Matrix_Scalar_At_Int(Mat,IndI,IndJ)

      End Function
!
!
!     PROCEDURE MQC_Matrix_Scalar_At_Int
!
!>    \brief <b> MQC_Matrix_Scalar_At_Int is a function that returns the value of an  
!>    element of a MQC matrix using integer indices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_At_Int is a function that returns the value of (I,J)th 
!>    element of a MQC matrix as an MQC scalar using integer indices. If I or J is 
!>    negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix to return the value of the (I,J)th 
!>        element.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Integer
!>        The row of the element in MQC matrix. 
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Integer
!>        The column of the element in MQC matrix.
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_Scalar_At_Int(Mat,I,J) Result(Element)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Mat
      Type(MQC_Scalar)::Element
      Integer,Intent(In)::I,J
      Integer(kind=int64)::IndI,IndJ

      IndI = I
      IndJ = J 
      
      If (IndI.lt.0) IndI = Mat%NRow + IndI + 1
      If (IndJ.lt.0) IndJ = Mat%NCol + IndJ + 1
      If (IndI.eq.0.or.IndI.gt.Mat%NRow) Call MQC_Error_I('Index I badly specified in mqc_matrix_scalar_at', 6, &
           'IndI', IndI, &
           'Mat%NRow', Mat%NRow )
      If (IndJ.eq.0.or.IndJ.gt.Mat%NCol) Call MQC_Error_I('Index J badly specified in mqc_matrix_scalar_at', 6, &
           'IndJ', IndJ, &
           'Mat%NCol', Mat%NCol )

      If (Mat%Storage.eq.'StorFull') then
        If (Mat%Data_Type.eq.'Integer') then
          Element = (Mat%MatI(IndI,IndJ))
        Elseif (Mat%Data_Type.eq.'Real') then
          Element = (Mat%MatR(IndI,IndJ))
        Elseif (Mat%Data_Type.eq.'Complex') then
          Element = (Mat%MatC(IndI,IndJ))
        Else
          Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
        EndIf
      ElseIf (Mat%Storage.eq.'StorSymm') then
        If (IndI.ge.IndJ) then
          If (Mat%Data_Type.eq.'Integer') then
            Element = (Mat%MatI(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (Mat%MatR(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (Mat%MatC(IndI*(IndI-1)/2+IndJ,1))
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        Else
          If (Mat%Data_Type.eq.'Integer') then
            Element = (Mat%MatI(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (Mat%MatR(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (Mat%MatC(IndJ*(IndJ-1)/2+IndI,1))
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        EndIf
      ElseIf (Mat%Storage.eq.'StorAsym') then
        If (IndI.ge.IndJ) then
          If (Mat%Data_Type.eq.'Integer') then
            Element = (Mat%MatI(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (Mat%MatR(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (Mat%MatC(IndI*(IndI-1)/2+IndJ,1))
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        Else
          If (Mat%Data_Type.eq.'Integer') then
            Element = (-1)*(Mat%MatI(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (-1)*(Mat%MatR(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (-1)*(Mat%MatC(IndJ*(IndJ-1)/2+IndI,1))
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        EndIf
      ElseIf (Mat%Storage.eq.'StorHerm') then
        If (IndI.ge.IndJ) then
          If (Mat%Data_Type.eq.'Integer') then
            Element = (Mat%MatI(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (Mat%MatR(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (Mat%MatC(IndI*(IndI-1)/2+IndJ,1))
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        Else
          If (Mat%Data_Type.eq.'Integer') then
            Element = (Mat%MatI(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (Mat%MatR(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (Mat%MatC(IndJ*(IndJ-1)/2+IndI,1))
            Element = conjg(Element)
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        EndIf
      ElseIf (Mat%Storage.eq.'StorAhrm') then
        If (IndI.ge.IndJ) then
          If (Mat%Data_Type.eq.'Integer') then
            Element = (Mat%MatI(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (Mat%MatR(IndI*(IndI-1)/2+IndJ,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (Mat%MatC(IndI*(IndI-1)/2+IndJ,1))
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        Else
          If (Mat%Data_Type.eq.'Integer') then
            Element = (-1)*(Mat%MatI(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (-1)*(Mat%MatR(IndJ*(IndJ-1)/2+IndI,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (-1)*(Mat%MatC(IndJ*(IndJ-1)/2+IndI,1))
            Element = conjg(Element)
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        EndIf
      ElseIf (Mat%Storage.eq.'StorDiag') then
        If (IndI.eq.IndJ) then
          If (Mat%Data_Type.eq.'Integer') then
            Element = (Mat%MatI(IndI,1))
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = (Mat%MatR(IndI,1))
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = (Mat%MatC(IndI,1))
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        Else
          If (Mat%Data_Type.eq.'Integer') then
            Element = 0
          ElseIf (Mat%Data_Type.eq.'Real') then
            Element = 0.0
          ElseIf (Mat%Data_Type.eq.'Complex') then
            Element = cmplx(0.0,0.0,kind=real64)
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_At', 6, &
                 'Mat%Data_Type', Mat%Data_Type )
          EndIf
        EndIf
      Else
        Call MQC_Error_A('Unrecognized storage type in MQC_Matrix_Scalar_At', 6, &
             'Mat%Storage', Mat%Storage )
      EndIf

      End Function MQC_Matrix_Scalar_At_Int
!
!
!     PROCEDURE MQC_Matrix_Vector_At
!
!>    \brief <b> MQC_Matrix_Vector_At is a function that returns the subvector of an  
!>    MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Vector_At is a function that returns the subvector of an MQC matrix.
!>    The row and column specification are given as a vector where one vector must 
!>    contain a single non-zero integer to specify the row or column of the 
!>    subvector, and the other vector must be either zero or two non-zero integers to
!>    specify the range of elements that will form the subvector. If the value of an
!>    element specification is negative, it counts from the last element back. If the
!>    value of an element specification is zero, the whole row/column is specified.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix from which to return the subvector.
!>    \endverbatim
!>    
!>    \param[in] Rows
!>    \verbatim
!>        Rows is Integer(kind=int64),Dimension(:)
!>        The specification of the rows to include in the 
!>        subvector. 
!>        If = [A,B]: output is subvector of rows A to B
!>          If (A,B)>0 row count is from first index
!>          If (A,B)<0 row count is from last index
!>        If = [0]: subvector of rows equivalent to [1,-1].
!>    \endverbatim
!>    
!>    \param[in] Cols  
!>    \verbatim
!>        Cols is Integer(kind=int64),Dimension(:)
!>        The specification of the columns to include in the 
!>        subvector. 
!>        If = [A,B]: output is subvector of columns A to B
!>          If (A,B)>0 column count is from first index
!>          If (A,B)<0 column count is from last index
!>        If = [0]: subvector of columns equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_Vector_At(Mat,Rows,Cols) Result(Vector)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Mat
      Type(MQC_Vector)::Vector
      Integer(kind=int64),Dimension(:),Intent(In)::Rows,Cols
      Integer(kind=int64)::Length,IndI,IndJ,IndK,Cnt,L,I,J,K
      Logical::Column

      If(Size(Rows).gt.1.and.Size(Cols).gt.1) then
        Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_vector_at', 6, &
             'Size(Rows)', Size(Rows), &
             'Size(Cols)', Size(Cols) )
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.1) then
        If(Rows(1).eq.0.and.Cols(1).ne.0) then
          Column = .True.
          I = 1
          J = Mat%NRow
          K = Cols(1)
        EndIf
        If(Cols(1).eq.0.and.Rows(1).ne.0) then
          Column = .False.
          I = 1
          J = Mat%NCol
          K = Rows(1)
        EndIf
        If(Rows(1).eq.0.and.Cols(1).eq.0) Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_vector_at', 6, &
            'Rows(1)', Rows(1), &
             'Cols(1)', Cols(1) )
        If(Rows(1).ne.0.and.Cols(1).ne.0) Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_vector_at', 6, &
             'Rows(1)', Rows(1), &
             'Cols(1)', Cols(1) )
      ElseIf(Size(Rows).eq.2.and.Size(Cols).eq.1) then
        Column = .True.
        I = Rows(1)
        J = Rows(2)
        K = Cols(1)
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.2) then
        Column = .False.
        I = Cols(1)
        J = Cols(2)
        K = Rows(1)
      Else
        Call MQC_Error_I('Unspecified boundaries in mqc_matrix_vector_at', 6, &
             'Size(Rows)', Size(Rows), &
             'Size(Cols)', Size(Cols) )
      EndIf

      IndK = K
      If (IndK.lt.0.and.Column) IndK = Mat%NCol + IndK + 1
      If (IndK.lt.0.and..not.Column) IndK = Mat%NRow + IndK + 1
      If (IndK.le.0.or.(IndK.gt.Mat%NCol.and.Column).or.(IndK.gt.Mat%NRow.and..not.Column)) &
        Call MQC_Error_I('Cannot select the Kth Row/Column in MQC_Matrix_Vector_At', 6, &
        'IndK', IndK, &
        'Mat%NCol', Mat%NCol, &
        'Mat%NRow', Mat%NRow )

      IndI = I
      IndJ = J
      If (IndI.lt.0.and.Column) IndI = Mat%NRow + IndI + 1
      If (IndJ.lt.0.and.Column) IndJ = Mat%NRow + IndJ + 1
      If (IndI.lt.0.and..not.Column) IndI = Mat%NCol + IndI + 1
      If (IndJ.lt.0.and..not.Column) IndJ = Mat%NCol + IndJ + 1

      Length = IndJ-IndI+1
      If(Column) then
        If (Length.le.0.or.Length.gt.Mat%NRow) Call MQC_Error_I('Vector length badly &
     &    defined in MQC_Matrix_Vector_At', 6, &
     'Length', Length, &
     'Mat%NRow', Mat%NRow )
        If (IndI.le.0.or.IndI.gt.(Mat%NRow-Length+1)) Call MQC_Error_I('Index I out of bounds &
    &    in MQC_Matrix_Vector_At', 6, &
    'IndI', IndI, &
    'Mat%NRow', Mat%NRow, &
    'Length', Length )
        If (IndJ.lt.Length.or.IndJ.gt.Mat%NRow) Call MQC_Error_I('Index J out of bounds &
    &     in MQC_Matrix_Vector_At', 6, &
    'IndJ', IndJ, &
    'Length', Length, &
    'Mat%NRow', Mat%NRow )
      ElseIf(.not.Column) then
        If (Length.le.0.or.Length.gt.Mat%NCol) Call MQC_Error_I('Vector length badly &
    &     defined in MQC_Matrix_Vector_At', 6, &
    'Length', Length, &
    'Mat%NCol', Mat%NCol )
        If (IndI.le.0.or.IndI.gt.(Mat%NCol-Length+1)) Call MQC_Error_I('Index I out of bounds &
    &     in MQC_Matrix_Vector_At', 6, &
    'IndI', IndI, &
    'Mat%NCol', Mat%NCol, &
    'Length', Length )
        If (IndJ.lt.Length.or.IndJ.gt.Mat%NCol) Call MQC_Error_I('Index J out of bounds &
    &     in MQC_Matrix_Vector_At', 6, &
    'IndJ', IndJ, &
    'Length', Length, &
    'Mat%NCol', Mat%NCol )
      EndIf

      If (Mat%Storage.eq.'StorFull') then
        If (Mat%Data_Type.eq.'Integer') then
          If (Column) then
            Call MQC_Allocate_Vector(Length,Vector,'Integer')
            Vector%VecI = (Mat%MatI(IndI:IndJ,IndK))
          ElseIf (.not.Column) then
            Call MQC_Allocate_Vector(Length,Vector,'Integer')
            Vector%VecI = (Mat%MatI(IndK,IndI:IndJ))
          EndIf
        Elseif (Mat%Data_Type.eq.'Real') then
          If (Column) then
            Call MQC_Allocate_Vector(Length,Vector,'Real')
            Vector%VecR = (Mat%MatR(IndI:IndJ,IndK))
          ElseIf (.not.Column) then
            Call MQC_Allocate_Vector(Length,Vector,'Real')
            Vector%VecR = (Mat%MatR(IndK,IndI:IndJ))
          EndIf
        Elseif (Mat%Data_Type.eq.'Complex') then
          If (Column) then
            Call MQC_Allocate_Vector(Length,Vector,'Complex')
            Vector%VecC = (Mat%MatC(IndI:IndJ,IndK))
          ElseIf (.not.Column) then
            Call MQC_Allocate_Vector(Length,Vector,'Complex')
            Vector%VecC = (Mat%MatC(IndK,IndI:IndJ))
          EndIf
        Else
          Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Vector_At', 6, &
               'Mat%Data_Type', Mat%Data_Type )
        EndIf
      ElseIf (Mat%Storage.eq.'StorSymm'.or.Mat%Storage.eq.'StorAsym'.or.Mat%Storage.eq.'StorHerm'.or.&
          Mat%Storage.eq.'StorAhrm') then
        If (Mat%Data_Type.eq.'Integer') then
          Call MQC_Allocate_Vector(Length,Vector,'Integer')
        ElseIf (Mat%Data_Type.eq.'Real') then
          Call MQC_Allocate_Vector(Length,Vector,'Real')
        ElseIf (Mat%Data_Type.eq.'Complex') then
          Call MQC_Allocate_Vector(Length,Vector,'Complex')
        Else
          Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Vector_At', 6, &
               'Mat%Data_Type', Mat%Data_Type )
        EndIf
        L = 1
        Do Cnt = IndI, IndJ
          If (Cnt.ge.IndK) then
            If (Mat%Data_Type.eq.'Integer') Vector%VecI(L) = (Mat%MatI(Cnt*(Cnt-1)/2+IndK,1))
            If (Mat%Data_Type.eq.'Real') Vector%VecR(L) = (Mat%MatR(Cnt*(Cnt-1)/2+IndK,1))
            If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = (Mat%MatC(Cnt*(Cnt-1)/2+IndK,1))
          Else
            If (Mat%Data_Type.eq.'Integer') Vector%VecI(L) = (Mat%MatI(IndK*(IndK-1)/2+Cnt,1))
            If (Mat%Data_Type.eq.'Real') Vector%VecR(L) = (Mat%MatR(IndK*(IndK-1)/2+Cnt,1))
            If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = (Mat%MatC(IndK*(IndK-1)/2+Cnt,1))
          EndIf
          If(Column.and.Cnt.lt.IndK) then
            If(Mat%Storage.eq.'StorAsym') then
              If (Mat%Data_Type.eq.'Integer') Vector%VecI(L) = (-1)*Vector%VecI(L)
              If (Mat%Data_Type.eq.'Real') Vector%VecR(L) = (-1)*Vector%VecR(L)
              If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = (-1)*Vector%VecC(L)
            ElseIf(Mat%Storage.eq.'StorHerm') then
              If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = conjg(Vector%VecC(L))
            ElseIf(Mat%Storage.eq.'StorAhrm') then
              If (Mat%Data_Type.eq.'Integer') Vector%VecI(L) = (-1)*Vector%VecI(L)
              If (Mat%Data_Type.eq.'Real') Vector%VecR(L) = (-1)*Vector%VecR(L)
              If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = (-1)*conjg(Vector%VecC(L))
            EndIf
          ElseIf(.not.Column.and.Cnt.gt.IndK) then
            If(Mat%Storage.eq.'StorAsym') then
              If (Mat%Data_Type.eq.'Integer') Vector%VecI(L) = (-1)*Vector%VecI(L)
              If (Mat%Data_Type.eq.'Real') Vector%VecR(L) = (-1)*Vector%VecR(L)
              If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = (-1)*Vector%VecC(L)
            ElseIf(Mat%Storage.eq.'StorHerm') then
              If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = conjg(Vector%VecC(L))
            ElseIf(Mat%Storage.eq.'StorAhrm') then
              If (Mat%Data_Type.eq.'Integer') Vector%VecI(L) = (-1)*Vector%VecI(L)
              If (Mat%Data_Type.eq.'Real') Vector%VecR(L) = (-1)*Vector%VecR(L)
              If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = (-1)*conjg(Vector%VecC(L))
            EndIf
          EndIf
          L = L + 1
        EndDo
      ElseIf (Mat%Storage.eq.'StorDiag') then
        If (Mat%Data_Type.eq.'Integer') then
          Call Vector%init(Length,0)
        ElseIf (Mat%Data_Type.eq.'Real') then
          Call Vector%init(Length,0.0)
        ElseIf (Mat%Data_Type.eq.'Complex') then
          Call Vector%init(Length,cmplx(0.0,0.0))
        Else
          Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Vector_At', 6, &
               'Mat%Data_Type', Mat%Data_Type )
        EndIf
        L = 1
        Do Cnt = IndI,IndJ
          If (Cnt.eq.IndK) then
            If (Mat%Data_Type.eq.'Integer') Vector%VecI(L) = Mat%MatI(IndK,1)
            If (Mat%Data_Type.eq.'Real') Vector%VecR(L) = Mat%MatR(IndK,1)
            If (Mat%Data_Type.eq.'Complex') Vector%VecC(L) = Mat%MatC(IndK,1)
          EndIf
          L = L + 1
        EndDo
      Else
        Call MQC_Error_A('MQC_Matrix_Vector_At: Only full, Symm, and Diagonal type matrices are supported', 6, &
             'Mat%Storage', Mat%Storage )
      EndIf

      Vector%Column = Column

      End Function MQC_Matrix_Vector_At
!
!
!     PROCEDURE MQC_Matrix_Vector_Put
!
!>    \brief <b> MQC_Matrix_Vector_Put is a subroutine that writes a subvector to the
!>    specified position of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Vector_Put is a subroutine that writes a subvector to the specified
!>    position of a MQC matrix. The row and column specification are given as a vector 
!>    where one vector must contain a single non-zero integer to specify the row or 
!>    column where the subvector will be written, and the other vector must be either 
!>    zero or two non-zero integers to specify the range of elements that will be
!>    overwritten by the subvector. If the value of an element specification is 
!>    negative, it counts from the last element back. If the value of an element 
!>    specification is zero, the whole row/column is specified.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix from which to return the subvector.
!>    \endverbatim
!>    
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The subvector to overwrite at the specified elements 
!>        of Mat.
!>    \endverbatim
!>    
!>    \param[in] Rows
!>    \verbatim
!>        Rows is Integer(kind=int64),Dimension(:)
!>        The specification of the rows to include in the 
!>        subvector. 
!>        If = [A,B]: output is subvector of rows A to B
!>          If (A,B)>0 row count is from first index
!>          If (A,B)<0 row count is from last index
!>        If = [0]: subvector of rows equivalent to [1,-1].
!>    \endverbatim
!>    
!>    \param[in] Cols  
!>    \verbatim
!>        Cols is Integer(kind=int64),Dimension(:)
!>        The specification of the columns to include in the 
!>        subvector. 
!>        If = [A,B]: output is subvector of columns A to B
!>          If (A,B)>0 column count is from first index
!>          If (A,B)<0 column count is from last index
!>        If = [0]: subvector of columns equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Recursive Subroutine MQC_Matrix_Vector_Put(Mat,VectorIn,Rows,Cols)
!
      Implicit None
      Class(MQC_Matrix),Intent(InOut)::Mat
      Integer(kind=int64),Dimension(:),Intent(In)::Rows,Cols
      Type(MQC_Vector),Intent(In)::VectorIn
      Integer(kind=int64)::Length,IndI,IndJ,IndK,I,J,K
      Logical::Column

      If(Size(Rows).gt.1.and.Size(Cols).gt.1) then
        Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_vector_put', 6, &
             'Size(Rows)', Size(Rows), &
             'Size(Cols)', Size(Cols) )
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.1) then
        If(Rows(1).eq.0.and.Cols(1).ne.0) then
          Column = .True.
          I = 1
          J = Mat%NRow
          K = Cols(1)
        EndIf
        If(Cols(1).eq.0.and.Rows(1).ne.0) then
          Column = .False.
          I = 1
          J = Mat%NCol
          K = Rows(1)
        EndIf
        If(Rows(1).eq.0.and.Cols(1).eq.0) Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_vector_put', 6, &
             'Rows(1)', Rows(1), &
             'Cols(1)', Cols(1) )
        If(Rows(1).ne.0.and.Cols(1).ne.0) Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_vector_put', 6, &
             'Rows(1)', Rows(1), &
             'Cols(1)', Cols(1) )
      ElseIf(Size(Rows).eq.2.and.Size(Cols).eq.1) then
        Column = .True.
        I = Rows(1)
        J = Rows(2)
        K = Cols(1)
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.2) then
        Column = .False.
        I = Cols(1)
        J = Cols(2)
        K = Rows(1)
      Else
        Call MQC_Error_I('Unspecified boundaries in mqc_matrix_vector_put', 6, &
             'Size(Rows)', Size(Rows), &
             'Size(Cols)', Size(Cols) )
      EndIf

      IndK = K
      If (IndK.lt.0.and.Column) IndK = Mat%NCol + IndK + 1
      If (IndK.lt.0.and..not.Column) IndK = Mat%NRow + IndK + 1
      If (IndK.le.0.or.(IndK.gt.Mat%NCol.and.Column).or.(IndK.gt.Mat%NRow.and..not.Column)) &
        Call MQC_Error_I('Cannot select the Kth Row/Column in MQC_Matrix_Vector_Put', 6, &
        'IndK', IndK, &
        'Mat%NCol', Mat%NCol, &
        'Mat%NRow', Mat%NRow )
      IndI = I
      IndJ = J
      If (IndI.lt.0.and.Column) IndI = Mat%NRow + IndI + 1
      If (IndJ.lt.0.and.Column) IndJ = Mat%NRow + IndJ + 1
      If (IndI.lt.0.and..not.Column) IndI = Mat%NCol + IndI + 1
      If (IndJ.lt.0.and..not.Column) IndJ = Mat%NCol + IndJ + 1

      Length = IndJ-IndI+1
      If(Column) then
        If (Length.le.0.or.Length.gt.Mat%NRow.or.Length.ne.VectorIn%Length) &
          Call MQC_Error_I('Vector length badly defined in MQC_Matrix_Vector_Put', 6, &
          'Length', Length, &
          'Mat%NRow', Mat%NRow, &
          'VectorIn%Length', VectorIn%Length )
        If (IndI.le.0.or.IndI.gt.(Mat%NRow-Length+1)) Call MQC_Error_I('Index I out of bounds &
    &    in MQC_Matrix_Vector_Put', 6, &
    'IndI', IndI, &
    'Mat%NRow', Mat%NRow, &
    'Length', Length )
        If (IndJ.lt.Length.or.IndJ.gt.Mat%NRow) Call MQC_Error_I('Index J out of bounds &
    &     in MQC_Matrix_Vector_Put', 6, &
    'IndJ', IndJ, &
    'Length', Length, &
    'Mat%NRow', Mat%NRow )
      ElseIf(.not.Column) then
        If (Length.le.0.or.Length.gt.Mat%NCol.or.Length.ne.VectorIn%Length) &
          Call MQC_Error_I('Vector length badly defined in MQC_Matrix_Vector_Put', 6, &
          'Length', Length, &
          'Mat%NCol', Mat%NCol, &
          'VectorIn%Length', VectorIn%Length )
        If (IndI.le.0.or.IndI.gt.(Mat%NCol-Length+1)) Call MQC_Error_I('Index I out of bounds &
    &     in MQC_Matrix_Vector_Put', 6, &
    'IndI', IndI, &
    'Mat%NCol', Mat%NCol, &
    'Length', Length )
        If (IndJ.lt.Length.or.IndJ.gt.Mat%NCol) Call MQC_Error_I('Index J out of bounds &
             &     in MQC_Matrix_Vector_Put', 6, &
             'IndJ', IndJ, &
             'Length', Length, &
             'Mat%NCol', Mat%NCol )
      EndIf

      If (Mat%Storage.eq.'StorFull') then
        If (Mat%Data_Type.eq.'Integer') then
          If (VectorIn%Data_Type.eq.'Integer') then
            If(Column) Mat%MatI(IndI:IndJ,IndK) = VectorIn%VecI
            If(.not.Column) Mat%MatI(IndK,IndI:IndJ) = VectorIn%VecI
          ElseIf (VectorIn%Data_Type.eq.'Real') then
            Call MQC_Matrix_Copy_Int2Real(Mat)
            If(Column) Mat%MatR(IndI:IndJ,IndK) = VectorIn%VecR
            If(.not.Column) Mat%MatR(IndK,IndI:IndJ) = VectorIn%VecR
          ElseIf (VectorIn%Data_Type.eq.'Complex') then
            Call MQC_Matrix_Copy_Int2Complex(Mat)
            If(Column) Mat%MatC(IndI:IndJ,IndK) = VectorIn%VecC
            If(.not.Column) Mat%MatC(IndK,IndI:IndJ) = VectorIn%VecC
          Else
            Call MQC_Error_A('VectorIn type not defined in MQC_Vector_Vector_Put', 6, &
                 'VectorIn%Data_Type', VectorIn%Data_Type )
          EndIf
        ElseIf (Mat%Data_Type.eq.'Real') then
          If (VectorIn%Data_Type.eq.'Integer') then
            If(Column) Mat%MatR(IndI:IndJ,IndK) = VectorIn%VecI
            If(.not.Column) Mat%MatR(IndK,IndI:IndJ) = VectorIn%VecI
          ElseIf (VectorIn%Data_Type.eq.'Real') then
            If(Column) Mat%MatR(IndI:IndJ,IndK) = VectorIn%VecR
            If(.not.Column) Mat%MatR(IndK,IndI:IndJ) = VectorIn%VecR
          ElseIf (VectorIn%Data_Type.eq.'Complex') then
            Call MQC_Matrix_Copy_Real2Complex(Mat)
            If(Column) Mat%MatC(IndI:IndJ,IndK) = VectorIn%VecC
            If(.not.Column) Mat%MatC(IndK,IndI:IndJ) = VectorIn%VecC
          Else
            Call MQC_Error_A('VectorIn type not defined in MQC_Vector_Vector_Put', 6, &
                 'VectorIn%Data_Type', VectorIn%Data_Type )
          EndIf
        ElseIf (Mat%Data_Type.eq.'Complex') then
          If (VectorIn%Data_Type.eq.'Integer') then
            If(Column) Mat%MatC(IndI:IndJ,IndK) = VectorIn%VecI
            If(.not.Column) Mat%MatC(IndK,IndI:IndJ) = VectorIn%VecI
          ElseIf (VectorIn%Data_Type.eq.'Real') then
            If(Column) Mat%MatC(IndI:IndJ,IndK) = VectorIn%VecR
            If(.not.Column) Mat%MatC(IndK,IndI:IndJ) = VectorIn%VecR
          ElseIf (VectorIn%Data_Type.eq.'Complex') then
            If(Column) Mat%MatC(IndI:IndJ,IndK) = VectorIn%VecC
            If(.not.Column) Mat%MatC(IndK,IndI:IndJ) = VectorIn%VecC
          Else
            Call MQC_Error_A('VectorIn type not defined in MQC_Vector_Vector_Put', 6, &
                 'VectorIn%Data_Type', VectorIn%Data_Type )
          EndIf
        Else
          Call MQC_Error_A('Mat type not defined in MQC_Vector_Vector_Put', 6, &
               'Mat%Data_Type', Mat%Data_Type )
        EndIf
      ElseIf (Mat%Storage.eq.'StorSymm') then
        Call MQC_Matrix_Symm2Full(Mat)
        If(Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndI,IndJ],[IndK])
        If(.not.Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndK],[IndI,IndJ])
        If(MQC_Matrix_Test_Symmetric(Mat)) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorAsym') then
        Call MQC_Matrix_Symm2Full(Mat)
        If(Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndI,IndJ],[IndK])
        If(.not.Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndK],[IndI,IndJ])
        If(MQC_Matrix_Test_Symmetric(Mat,'antisymmetric')) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorHerm') then
        Call MQC_Matrix_Symm2Full(Mat)
        If(Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndI,IndJ],[IndK])
        If(.not.Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndK],[IndI,IndJ])
        If(MQC_Matrix_Test_Symmetric(Mat,'hermitian')) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorAhrm') then
        Call MQC_Matrix_Symm2Full(Mat)
        If(Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndI,IndJ],[IndK])
        If(.not.Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndK],[IndI,IndJ])
        If(MQC_Matrix_Test_Symmetric(Mat,'antihermitian')) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorDiag') then
        Call MQC_Matrix_Diag2Full(Mat)
        If(Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndI,IndJ],[IndK])
        If(.not.Column) Call MQC_Matrix_Vector_Put(Mat,VectorIn,[IndK],[IndI,IndJ])
        If(MQC_Matrix_Test_Diagonal(Mat)) Call MQC_Matrix_Full2Diag(Mat)
      Else
        Call MQC_Error_A('Matrix type not recognosed in MQC_Matrix_Vector_Put', 6, &
             'Mat%Storage', Mat%Storage )
      EndIf

      End Subroutine MQC_Matrix_Vector_Put
!
!
!     PROCEDURE MQC_Matrix_Matrix_At
!
!>    \brief <b> MQC_Matrix_Matrix_At is a function that returns a submatrix of the matrix</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_Matrix_At is a function that returns the matrix between rows (I,J) and 
!>    columns (K,L) of an MQC_Matrix Mat as an MQC_Matrix Matrix. If I, J, K or L is 
!>    negative, the (N-I+1)th index value is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        Name of the input matrix variable
!>    \endverbatim
!>
!>    \param[in] rows
!>    \verbatim
!>        Rows is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is submatrix of rows A to B
!>          If (A,B)>0 row count is from first index
!>          If (A,B)<0 row count is from last index
!>        If = [0]: submatrix of rows equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] Cols
!>    \verbatim
!>        Cols is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is submatrix of columns A to B
!>          If (A,B)>0 column count is from first index
!>          If (A,B)<0 column count is from last index
!>        If = [0]: submatrix of columns equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_Matrix_At(Mat,Rows,Cols) Result(Matrix)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Mat
      Type(MQC_Matrix)::Matrix
      Integer(kind=int64),Dimension(:),Intent(In)::Rows,Cols
      Integer(kind=int64)::LenCol,LenRow,IndI,IndJ,IndK,IndL
      Integer(kind=int64)::M,N,Cnt1,Cnt2,I,J,K,L

      If(Size(Rows).gt.2.and.Size(Cols).gt.2) then
        Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_at', 6, &
             'Size(Rows)', Size(Rows), &
             'Size(Cols)', Size(Cols) )
      ElseIf(Size(Rows).eq.2.and.Size(Cols).eq.2) then
          I = Rows(1)
          J = Rows(2)
          K = Cols(1)
          L = Cols(2)
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.1) then
        If(Rows(1).eq.0.and.Cols(1).eq.0) then
          I = 1
          J = Mat%NRow
          K = 1
          L = Mat%NCol
        Else
          Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_at', 6, &
               'Rows(1)', Rows(1), &
               'Cols(1)', Cols(1), &
               'Size(Rows)', Size(Rows) , &
               'Size(Cols)', Size(Cols) )
        EndIf
      ElseIf(Size(Rows).eq.2.and.Size(Cols).eq.1) then
        If(Cols(1).eq.0) then
          I = Rows(1)
          J = Rows(2)
          K = 1
          L = Mat%NCol
        Else
          Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_at', 6, &
               'Cols(1)', Cols(1), &
               'Size(Rows)', Size(Rows) , &
               'Size(Cols)', Size(Cols) )
        EndIf
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.2) then
        If(Rows(1).eq.0) then
          I = 1
          J = Mat%NRow
          K = Cols(1)
          L = Cols(2)
        Else
          Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_at', 6, &
               'Rows(1)', Rows(1), &
               'Size(Rows)', Size(Rows) , &
               'Size(Cols)', Size(Cols) )
        EndIf
      Else
        Call MQC_Error_I('Unspecified boundaries in mqc_matrix_matrix_at', 6, &
             'Size(Rows)', Size(Rows) , &
             'Size(Cols)', Size(Cols) )
      EndIf

      IndI = I
      IndJ = J
      If (IndI.lt.0) IndI = Mat%NRow + IndI + 1
      If (IndJ.lt.0) IndJ = Mat%NRow + IndJ + 1
      LenRow = IndJ-IndI+1
      If (LenRow.le.0.or.LenRow.gt.Mat%NRow) Call MQC_Error_I('Row length badly &
           &   defined in MQC_Matrix_Matrix_At', 6, &
           'LenRow', LenRow, &
           'Mat%NRow', Mat%NRow )
      If (IndI.le.0.or.IndI.gt.(Mat%NRow-LenRow+1)) Call MQC_Error_I('Index I out of bounds &
           &   in MQC_Matrix_Matrix_At', 6, &
           'IndI', IndI, &
           'Mat%NRow', Mat%NRow, &
           'LenRow', LenRow )
      If (IndJ.lt.LenRow.or.IndJ.gt.Mat%NRow) Call MQC_Error_I('Index J out of bounds &
           &   in MQC_Matrix_Matrix_At', 6, &
           'IndJ', IndJ, &
           'LenRow', LenRow, &
           'Mat%NRow', Mat%NRow )
      IndK = K
      IndL = L
      If (IndK.lt.0) IndK = Mat%NCol + IndK + 1
      If (IndL.lt.0) IndL = Mat%NCol + IndL + 1
      LenCol = IndL-IndK+1
      If (LenCol.le.0.or.LenCol.gt.Mat%NCol) Call MQC_Error_I('Column length badly &
           &  defined in MQC_Matrix_Matrix_At', 6, &
           'LenCol', LenCol, &
           'Mat%NCol', Mat%NCol )
      If (IndK.le.0.or.IndK.gt.(Mat%NCol-LenCol+1)) Call MQC_Error_I('Index K out of bounds &
           &   in MQC_Matrix_Matrix_At', 6, &
           'IndK', IndK, &
           'Mat%NCol', Mat%NCol, &
           'LenCol', LenCol )
      If (IndL.lt.LenCol.or.IndL.gt.Mat%NCol) Call MQC_Error_I('Index L out of bounds &
           &   in MQC_Matrix_Matrix_At', 6, &
           'IndL', IndL, &
           'LenCol', LenCol, &
           'Mat%NCol', Mat%NCol )
      If (Mat%Storage.eq.'StorFull') then
        If (Mat%Data_Type.eq.'Integer') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Integer','StorFull')
          Matrix%MatI = (Mat%MatI(IndI:IndJ,IndK:IndL))
        Elseif (Mat%Data_Type.eq.'Real') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Real','StorFull')
          Matrix%MatR = (Mat%MatR(IndI:IndJ,IndK:IndL))
        Elseif (Mat%Data_Type.eq.'Complex') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Complex','StorFull')
          Matrix%MatC = (Mat%MatC(IndI:IndJ,IndK:IndL))
        Else
          Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Vector_At', 6, &
               'Mat%Data_Type', Mat%Data_Type )
        EndIf
      ElseIf (Mat%Storage.eq.'StorSymm') then
        If (Mat%Data_Type.eq.'Integer') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Integer','StorFull')
        ElseIf (Mat%Data_Type.eq.'Real') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Real','StorFull')
        ElseIf (Mat%Data_Type.eq.'Complex') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Complex','StorFull')
        EndIf
        M = 1
        N = 1
        Do Cnt1 = IndI, IndJ
          Do Cnt2 = IndK, IndL
            If (Cnt1.ge.Cnt2) then
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (Mat%MatI(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (Mat%MatR(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = (Mat%MatC(Cnt1*(Cnt1-1)/2+Cnt2,1))
            Else
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (Mat%MatI(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (Mat%MatR(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = (Mat%MatC(Cnt2*(Cnt2-1)/2+Cnt1,1))
            EndIf
            If(N.eq.LenCol) then
              N = 1
            Else
              N = N + 1
            EndIf
          EndDo
          M = M + 1
        EndDo
        If(MQC_Matrix_Test_Symmetric(Matrix)) Call MQC_Matrix_Full2Symm(Matrix)
      ElseIf (Mat%Storage.eq.'StorAsym') then
        If (Mat%Data_Type.eq.'Integer') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Integer','StorFull')
        ElseIf (Mat%Data_Type.eq.'Real') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Real','StorFull')
        ElseIf (Mat%Data_Type.eq.'Complex') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Complex','StorFull')
        EndIf
        M = 1
        N = 1
        Do Cnt1 = IndI, IndJ
          Do Cnt2 = IndK, IndL
            If (Cnt1.ge.Cnt2) then
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (Mat%MatI(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (Mat%MatR(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = (Mat%MatC(Cnt1*(Cnt1-1)/2+Cnt2,1))
            Else
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (-1)*(Mat%MatI(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (-1)*(Mat%MatR(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = (-1)*(Mat%MatC(Cnt2*(Cnt2-1)/2+Cnt1,1))
            EndIf
            If(N.eq.LenCol) then
              N = 1
            Else
              N = N + 1
            EndIf
          EndDo
          M = M + 1
        EndDo
        If(MQC_Matrix_Test_Symmetric(Matrix,'antisymmetric')) Call MQC_Matrix_Full2Symm(Matrix)
      ElseIf (Mat%Storage.eq.'StorHerm') then
        If (Mat%Data_Type.eq.'Integer') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Integer','StorFull')
        ElseIf (Mat%Data_Type.eq.'Real') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Real','StorFull')
        ElseIf (Mat%Data_Type.eq.'Complex') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Complex','StorFull')
        EndIf
        M = 1
        N = 1
        Do Cnt1 = IndI, IndJ
          Do Cnt2 = IndK, IndL
            If (Cnt1.ge.Cnt2) then
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (Mat%MatI(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (Mat%MatR(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = (Mat%MatC(Cnt1*(Cnt1-1)/2+Cnt2,1))
            Else
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (Mat%MatI(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (Mat%MatR(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = conjg(Mat%MatC(Cnt2*(Cnt2-1)/2+Cnt1,1))
            EndIf
            If(N.eq.LenCol) then
              N = 1
            Else
              N = N + 1
            EndIf
          EndDo
          M = M + 1
        EndDo
        If(MQC_Matrix_Test_Symmetric(Matrix,'hermitian')) Call MQC_Matrix_Full2Symm(Matrix)
      ElseIf (Mat%Storage.eq.'StorAhrm') then
        If (Mat%Data_Type.eq.'Integer') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Integer','StorFull')
        ElseIf (Mat%Data_Type.eq.'Real') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Real','StorFull')
        ElseIf (Mat%Data_Type.eq.'Complex') then
          Call MQC_Allocate_Matrix(LenRow,LenCol,Matrix,'Complex','StorFull')
        EndIf
        M = 1
        N = 1
        Do Cnt1 = IndI, IndJ
          Do Cnt2 = IndK, IndL
            If (Cnt1.ge.Cnt2) then
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (Mat%MatI(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (Mat%MatR(Cnt1*(Cnt1-1)/2+Cnt2,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = (Mat%MatC(Cnt1*(Cnt1-1)/2+Cnt2,1))
            Else
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = (-1)*(Mat%MatI(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Real') Matrix%MatR(M,N) = (-1)*(Mat%MatR(Cnt2*(Cnt2-1)/2+Cnt1,1))
              If (Mat%Data_Type.eq.'Complex') Matrix%MatC(M,N) = (-1)*conjg(Mat%MatC(Cnt2*(Cnt2-1)/2+Cnt1,1))
            EndIf
            If(N.eq.LenCol) then
              N = 1
            Else
              N = N + 1
            EndIf
          EndDo
          M = M + 1
        EndDo
        If(MQC_Matrix_Test_Symmetric(Matrix,'antihermitian')) Call MQC_Matrix_Full2Symm(Matrix)
      ElseIf (Mat%Storage.eq.'StorDiag') then
        If (Mat%Data_Type.eq.'Integer') then
          Call Matrix%init(LenRow,LenCol,0)
        ElseIf (Mat%Data_Type.eq.'Real') then
          Call Matrix%init(LenRow,LenCol,0.0)
        ElseIf (Mat%Data_Type.eq.'Complex') then
          Call Matrix%init(LenRow,LenCol,cmplx(0.0,0.0))
        EndIf
        M = 1
        N = 1
        Do Cnt1 = IndI, IndJ
          Do Cnt2 = IndK, IndL
            If(Cnt1.eq.Cnt2) then
              If (Mat%Data_Type.eq.'Integer') Matrix%MatI(M,N) = Mat%MatI(Cnt1,1)
              If (Mat%data_Type.eq.'Real') Matrix%MatR(M,N) = Mat%MatR(Cnt1,1)
              If (Mat%data_Type.eq.'Complex') Matrix%MatC(M,N) = Mat%MatC(Cnt1,1)
            EndIf
            If(N.eq.LenCol) then
              N = 1
            Else
              N = N + 1
            EndIf
          EndDo
          M = M + 1
        EndDo
        If(MQC_Matrix_Test_Diagonal(Matrix)) Call MQC_Matrix_Full2Diag(Matrix)
      Else
        Call MQC_Error_A('Matrix type not recognised in MQC_Matrix_Matrix_At', 6, &
             'Mat%Storage', Mat%Storage )
      EndIf

      End Function MQC_Matrix_Matrix_At
!
!
!     PROCEDURE MQC_Matrix_DiagMatrix_Put_Vector_Func 
!
!>    \brief <b> MQC_Matrix_DiagMatrix_Put_Vector_Func is a function that returns a 
!>    diagonal MQC matrix with elements defined by values in a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_DiagMatrix_Put_Vector_Func is a function that returns a diagonal MQC 
!>    matrix with elements defined by values in a MQC vector.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] DiagVectorIn
!>    \verbatim
!>        DiagVectorIn is class(MQC_Vector)
!>        Name of the MQC vector to write as diagonal matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_Matrix_DiagMatrix_Put_Vector_Func(diagVectorIn) result(mat)
!
      implicit none
      class(MQC_Vector),intent(in)::diagVectorIn
        type(MQC_Matrix)::mat
!
      integer(kind=int64)::n
      character(len=64)::data_type 
!
      n = diagVectorIn%length
      data_type = diagVectorIn%data_type
      call MQC_Allocate_Matrix(n,n,mat,data_type,'stordiag')
      select case (data_type)
      case ('Integer') 
        mat%matI(:,1) = diagVectorIn%vecI(:)
      case ('Real') 
        mat%matR(:,1) = diagVectorIn%vecR(:)
      case ('Complex') 
        mat%matC(:,1) = diagVectorIn%vecC(:)
      case default
        call mqc_error_A('diagVectorIn has unrecognised data type:',6,'data_type',data_type)
      end select
!
      return
      end function MQC_Matrix_DiagMatrix_Put_Vector_Func 
!
!
!     PROCEDURE MQC_Matrix_DiagMatrix_Put_Vector 
!
!>    \brief <b> MQC_Matrix_DiagMatrix_Put_Vector is a subroutine that returns a 
!>    diagonal MQC matrix with elements defined by values in a MQC vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_DiagMatrix_Put_Vector is a subroutine that returns a diagonal MQC 
!>    matrix with elements defined by values in a MQC vector.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] DiagVectorIn
!>    \verbatim
!>        DiagVectorIn is class(MQC_Vector)
!>        Name of the MQC vector to write as diagonal matrix.
!>    \endverbatim
!>
!>    \param[in,out] mat 
!>    \verbatim
!>        Mat is class(MQC_Matrix)
!>        MQC matrix to overwrite with output diagonal matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2018
!
      Subroutine MQC_Matrix_DiagMatrix_Put_Vector(diagVectorIn,mat)
!
      implicit none
      class(MQC_Matrix),intent(inOut)::mat
      class(MQC_Vector),intent(in)::diagVectorIn
!
      integer(kind=int64)::n
      character(len=64)::data_type 
!
      n = diagVectorIn%length
      data_type = diagVectorIn%data_type
      call MQC_Allocate_Matrix(n,n,mat,data_type,'stordiag')
      select case (data_type)
      case ('Integer') 
        mat%matI(:,1) = diagVectorIn%vecI(:)
      case ('Real') 
        mat%matR(:,1) = diagVectorIn%vecR(:)
      case ('Complex') 
        mat%matC(:,1) = diagVectorIn%vecC(:)
      case default
        call mqc_error_A('diagVectorIn has unrecognised data type:',6,'data_type',data_type)
      end select
!
      return
      end subroutine MQC_Matrix_DiagMatrix_Put_Vector 
!
!
!     PROCEDURE MQC_Matrix_DiagMatrix_Put_Integer
!
!>    \brief <b> MQC_Matrix_DiagMatrix_Put_integer is a subroutine that returns a 
!>    diagonal MQC matrix with elements defined by values in an intrinsic integer 
!>    vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_DiagMatrix_Put_integer is a subroutine that returns a diagonal MQC
!>    matrix with elements defined by values in an intrinsic integer vector.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] mat 
!>    \verbatim
!>        Mat is class(MQC_Matrix)
!>        MQC matrix to overwrite with output diagonal matrix.
!>    \endverbatim
!>
!>    \param[in] DiagMatrixIn
!>    \verbatim
!>        DiagMatrixIn is integer(kind=int64),dimension(:)
!>        Intrinsic integer vector to write as diagonal matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author H. P. Hratchian
!>    \date 2017
!
      Subroutine MQC_Matrix_DiagMatrix_Put_Integer(mat,diagMatrixIn)
!
      implicit none
      class(MQC_Matrix),intent(inOut)::mat
      integer(kind=int64),dimension(:),intent(in)::diagMatrixIn
!
      integer(kind=int64)::n
!
!
!     Begin by figuring out the leading dimension of the matrix. Then, ensure
!     mat is allocated correctly and then use mat%mput routine.
!
      n = SIZE(diagMatrixIn)
      call MQC_Allocate_Matrix(n,n,mat,'integer','stordiag')
      mat%matI(:,1) = diagMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_DiagMatrix_Put_Integer
!
!
!     PROCEDURE MQC_Matrix_DiagMatrix_Put_Real
!
!>    \brief <b> MQC_Matrix_DiagMatrix_Put_Real is a subroutine that returns a 
!>    diagonal MQC matrix with elements defined by values in an intrinsic real 
!>    vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_DiagMatrix_Put_Real is a subroutine that returns a diagonal MQC
!>    matrix with elements defined by values in an intrinsic real vector.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] mat 
!>    \verbatim
!>        Mat is class(MQC_Matrix)
!>        MQC matrix to overwrite with output diagonal matrix.
!>    \endverbatim
!>
!>    \param[in] DiagMatrixIn
!>    \verbatim
!>        DiagMatrixIn is real(kind=real64),dimension(:)
!>        Intrinsic real vector to write as diagonal matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author H. P. Hratchian
!>    \date 2017
!
      Subroutine MQC_Matrix_DiagMatrix_Put_Real(mat,diagMatrixIn)
!
      implicit none
      class(MQC_Matrix),intent(inOut)::mat
      real(kind=real64),dimension(:),intent(in)::diagMatrixIn
!
      integer(kind=int64)::n
!
!
!     Begin by figuring out the leading dimension of the matrix. Then, ensure
!     mat is allocated correctly and then use mat%mput routine.
!
      n = SIZE(diagMatrixIn)
      call MQC_Allocate_Matrix(n,n,mat,'real','stordiag')
      mat%matR(:,1) = diagMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_DiagMatrix_Put_Real
!
!
!     PROCEDURE MQC_Matrix_DiagMatrix_Put_Complex
!
!>    \brief <b> MQC_Matrix_DiagMatrix_Put_Complex is a subroutine that returns a 
!>    diagonal MQC matrix with elements defined by values in an intrinsic complex 
!>    vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_DiagMatrix_Put_Complex is a subroutine that returns a diagonal MQC
!>    matrix with elements defined by values in an intrinsic complex vector.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] mat 
!>    \verbatim
!>        Mat is class(MQC_Matrix)
!>        MQC matrix to overwrite with output diagonal matrix.
!>    \endverbatim
!>
!>    \param[in] DiagMatrixIn
!>    \verbatim
!>        DiagMatrixIn is complex(kind=real64),dimension(:)
!>        Intrinsic complex vector to write as diagonal matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson 
!>    \date 2017
!
      Subroutine MQC_Matrix_DiagMatrix_Put_Complex(mat,diagMatrixIn)
!
      implicit none
      class(MQC_Matrix),intent(inOut)::mat
      Complex(Kind=real64),dimension(:),intent(in)::diagMatrixIn
!
      integer(kind=int64)::n
!
!
!     Begin by figuring out the leading dimension of the matrix. Then, ensure
!     mat is allocated correctly and then use mat%mput routine.
!
      n = SIZE(diagMatrixIn)
      call MQC_Allocate_Matrix(n,n,mat,'Complex','stordiag')
      mat%matC(:,1) = diagMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_DiagMatrix_Put_Complex
!
!
!     PROCEDURE MQC_Matrix_SymmMatrix_Put_Integer
!
!>    \brief <b> MQC_Matrix_SymmMatrix_Put_Integer is a subroutine that returns a 
!>    symmetric packed MQC matrix with elements defined by values in an intrinsic 
!>    integer vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_SymmMatrix_Put_Integer is a subroutine that returns a symmetric 
!>    packed MQC matrix with elements defined by values in an intrinsic integer 
!>    vector. The following options are available:
!>      Option = 'symmetric' input matrix is symmetric.
!>      Option = 'antisymmetric' input matrix is antisymmetric.
!>      Option = 'hermitian' input matrix is hermitian.
!>      Option = 'antihermitian' input matrix is antihermitian.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] mat 
!>    \verbatim
!>        Mat is class(MQC_Matrix)
!>        MQC matrix to overwrite with output symmetric matrix.
!>    \endverbatim
!>
!>    \param[in] SymmMatrixIn
!>    \verbatim
!>        SymmMatrixIn is integer(kind=int64),dimension(:)
!>        Intrinsic integer vector to write as symmetric-packed 
!>        matrix.
!>    \endverbatim
!>
!>    \param[in] label
!>    \verbatim
!>        Label is Character(len=*),Optional
!>        = 'symmetric':      Input matrix is symmetric
!>        = 'antisymmetric':  Input matrix is antisymmetric
!>        = 'hermitian':      Input matrix is hermitian
!>        = 'antihermitian':  Input matrix is antihermitian
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author H. P. Hratchian
!>    \date 2017
!
      Subroutine MQC_Matrix_SymmMatrix_Put_Integer(mat,symmMatrixIn,label)
!
      implicit none
      class(MQC_Matrix),intent(inOut)::mat
      integer(kind=int64),dimension(:),intent(in)::symmMatrixIn
      character(len=*),optional,intent(in)::label
!
      integer(kind=int64)::n,nSymm,intTemp1
      real(kind=real64)::realTemp1,realTemp2
      character(len=64)::myLabel
!
!
!     Begin by figuring out the leading dimension of the matrix. Then, ensure
!     mat is allocated correctly and then use mat%mput routine.
!
      nSymm = SIZE(symmMatrixIn)
      intTemp1 = 1+8*nSymm
#ifdef PGI
      realTemp1 = (sqrt(dfloat(intTemp1))-1)/dfloat(2)
#else
      realTemp1 = (sqrt(float(intTemp1))-1)/float(2)
#endif
      n = INT(realTemp1)
#ifdef PGI
      realTemp2 = ABS(realTemp1 - dfloat(n))
#else
      realTemp2 = ABS(realTemp1 - float(n))
#endif
      If(present(label)) then
        call string_change_case(label,'l',myLabel)
      else
        myLabel = 'symmetric'
      endIf

      if(realTemp2.gt.1.d-5) call MQC_Error_R('Error in MQC_Matrix_SymmMatrix_Put', 6, &
           'realTemp2', realTemp2 )
      if(mylabel.eq.'symmetric') call MQC_Allocate_Matrix(n,n,mat,'integer','StorSymm')
      if(mylabel.eq.'antisymmetric') call MQC_Allocate_Matrix(n,n,mat,'integer','StorAsym')
      if(mylabel.eq.'hermitian') call MQC_Allocate_Matrix(n,n,mat,'integer','StorHerm')
      if(mylabel.eq.'antihermitian') call MQC_Allocate_Matrix(n,n,mat,'integer','StorAhrm')
      mat%matI(:,1) = symmMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_SymmMatrix_Put_Integer
!
!
!     PROCEDURE MQC_Matrix_SymmMatrix_Put_Real
!
!>    \brief <b> MQC_Matrix_SymmMatrix_Put_Real is a subroutine that returns a 
!>    symmetric packed MQC matrix with elements defined by values in an intrinsic 
!>    real vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_SymmMatrix_Put_Real is a subroutine that returns a symmetric 
!>    packed MQC matrix with elements defined by values in an intrinsic real
!>    vector. The following options are available:
!>      Option = 'symmetric' input matrix is symmetric.
!>      Option = 'antisymmetric' input matrix is antisymmetric.
!>      Option = 'hermitian' input matrix is hermitian.
!>      Option = 'antihermitian' input matrix is antihermitian.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] mat 
!>    \verbatim
!>        Mat is class(MQC_Matrix)
!>        MQC matrix to overwrite with output symmetric matrix.
!>    \endverbatim
!>
!>    \param[in] SymmMatrixIn
!>    \verbatim
!>        SymmMatrixIn is real(kind=real64),dimension(:)
!>        Intrinsic real vector to write as symmetric-packed 
!>        matrix.
!>    \endverbatim
!>
!>    \param[in] label
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'symmetric':      Input matrix is symmetric
!>        = 'antisymmetric':  Input matrix is antisymmetric
!>        = 'hermitian':      Input matrix is hermitian
!>        = 'antihermitian':  Input matrix is antihermitian
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author H. P. Hratchian
!>    \date 2017
!
      Subroutine MQC_Matrix_SymmMatrix_Put_Real(mat,symmMatrixIn,label)
!
      implicit none
      class(MQC_Matrix),intent(inOut)::mat
      real(kind=real64),dimension(:),intent(in)::symmMatrixIn
      character(len=*),optional,intent(in)::label
!
      integer(kind=int64)::n,nSymm,intTemp1
      real(kind=real64)::realTemp1,realTemp2
      character(len=64)::myLabel
!
!
!     Begin by figuring out the leading dimension of the matrix. Then, ensure
!     mat is allocated correctly and then use mat%mput routine.
!
      nSymm = SIZE(symmMatrixIn)
      intTemp1 = 1+8*nSymm
#ifdef PGI
      realTemp1 = (sqrt(dfloat(intTemp1))-1)/dfloat(2)
#else
      realTemp1 = (sqrt(float(intTemp1))-1)/float(2)
#endif
      n = INT(realTemp1)
#ifdef PGI
      realTemp2 = ABS(realTemp1 - dfloat(n))
#else
      realTemp2 = ABS(realTemp1 - float(n))
#endif
      If(present(label)) then
        call string_change_case(label,'l',myLabel)
      else
        myLabel = 'symmetric'
      endIf

      if(realTemp2.gt.1.d-5) call MQC_Error_R('Error in MQC_Matrix_SymmMatrix_Put', 6, &
           'realTemp2', realTemp2 )
      if(mylabel.eq.'symmetric') call MQC_Allocate_Matrix(n,n,mat,'real','StorSymm')
      if(mylabel.eq.'antisymmetric') call MQC_Allocate_Matrix(n,n,mat,'real','StorAsym')
      if(mylabel.eq.'hermitian') call MQC_Allocate_Matrix(n,n,mat,'real','StorHerm')
      if(mylabel.eq.'antihermitian') call MQC_Allocate_Matrix(n,n,mat,'real','StorAhrm')
      mat%matR(:,1) = symmMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_SymmMatrix_Put_Real
!
!
!     PROCEDURE MQC_Matrix_SymmMatrix_Put_Complex
!
!>    \brief <b> MQC_Matrix_SymmMatrix_Put_Complex is a subroutine that returns a 
!>    symmetric packed MQC matrix with elements defined by values in an intrinsic 
!>    complex vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_Matrix_SymmMatrix_Put_Complex is a subroutine that returns a symmetric 
!>    packed MQC matrix with elements defined by values in an intrinsic complex
!>    vector. The following options are available:
!>      Option = 'symmetric' input matrix is symmetric.
!>      Option = 'antisymmetric' input matrix is antisymmetric.
!>      Option = 'hermitian' input matrix is hermitian.
!>      Option = 'antihermitian' input matrix is antihermitian.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] mat 
!>    \verbatim
!>        Mat is class(MQC_Matrix)
!>        MQC matrix to overwrite with output symmetric matrix.
!>    \endverbatim
!>
!>    \param[in] SymmMatrixIn
!>    \verbatim
!>        SymmMatrixIn is complex(kind=real64),dimension(:)
!>        Intrinsic complex vector to write as symmetric-packed 
!>        matrix.
!>    \endverbatim
!>
!>    \param[in] label
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'symmetric':      Input matrix is symmetric
!>        = 'antisymmetric':  Input matrix is antisymmetric
!>        = 'hermitian':      Input matrix is hermitian
!>        = 'antihermitian':  Input matrix is antihermitian
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson 
!>    \date 2017
!
      Subroutine MQC_Matrix_SymmMatrix_Put_Complex(mat,symmMatrixIn,label)
!
      implicit none
      class(MQC_Matrix),intent(inOut)::mat
      Complex(Kind=real64),dimension(:),intent(in)::symmMatrixIn
      character(len=*),optional,intent(in)::label
!
      integer(kind=int64)::n,nSymm,intTemp1
      real(kind=real64)::realTemp1,realTemp2
      character(len=64)::myLabel
!
!
!     Begin by figuring out the leading dimension of the matrix. Then, ensure
!     mat is allocated correctly and then use mat%mput routine.
!
      nSymm = SIZE(symmMatrixIn)
      intTemp1 = 1+8*nSymm
#ifdef PGI
      realTemp1 = (sqrt(dfloat(intTemp1))-1)/dfloat(2)
#else
      realTemp1 = (sqrt(float(intTemp1))-1)/float(2)
#endif
      n = INT(realTemp1)
#ifdef PGI
      realTemp2 = ABS(realTemp1 - dfloat(n))
#else
      realTemp2 = ABS(realTemp1 - float(n))
#endif
      If(present(label)) then
        call string_change_case(label,'l',myLabel)
      else
        myLabel = 'symmetric'
      endIf

      if(realTemp2.gt.1.d-5) call MQC_Error_R('Error in MQC_Matrix_SymmMatrix_Put', 6, &
           'realTemp2', realTemp2 )
      if(mylabel.eq.'symmetric') call MQC_Allocate_Matrix(n,n,mat,'complex','StorSymm')
      if(mylabel.eq.'antisymmetric') call MQC_Allocate_Matrix(n,n,mat,'complex','StorAsym')
      if(mylabel.eq.'hermitian') call MQC_Allocate_Matrix(n,n,mat,'complex','StorHerm')
      if(mylabel.eq.'antihermitian') call MQC_Allocate_Matrix(n,n,mat,'complex','StorAhrm')
      mat%matC(:,1) = symmMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_SymmMatrix_Put_Complex
!
!
!
!     PROCEDURE MQC_Matrix_Matrix_Put
!
!>    \brief <b> MQC_Matrix_Matrix_Put is a subroutine that writes a submatrix to the
!>    specified position of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Matrix_Put is a subroutine that writes a submatrix to the specified
!>    position of a MQC matrix. The row and column specification are given as a vector 
!>    where each vector must contain either zero or two non-zero integers to specify 
!>    the range of elements that will be overwritten by the submatrix. If the value 
!>    of an element specification is negative, it counts from the last element back. 
!>    If the value of an element specification is zero, the whole row/column is 
!>    specified.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Mat
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix from which to return the subvector.
!>    \endverbatim
!>    
!>    \param[in] MatrixIn
!>    \verbatim
!>        MatrixIn is Type(MQC_Matrix)
!>        The submatrix to overwrite at the specified elements 
!>        of Mat.
!>    \endverbatim
!>    
!>    \param[in] Rows
!>    \verbatim
!>        Rows is Integer(kind=int64),Dimension(:)
!>        The specification of the rows to include in the 
!>        subvector. 
!>        If = [A,B]: output is subvector of rows A to B
!>          If (A,B)>0 row count is from first index
!>          If (A,B)<0 row count is from last index
!>        If = [0]: subvector of rows equivalent to [1,-1].
!>    \endverbatim
!>    
!>    \param[in] Cols  
!>    \verbatim
!>        Cols is Integer(kind=int64),Dimension(:)
!>        The specification of the columns to include in the 
!>        subvector. 
!>        If = [A,B]: output is subvector of columns A to B
!>          If (A,B)>0 column count is from first index
!>          If (A,B)<0 column count is from last index
!>        If = [0]: subvector of columns equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Recursive Subroutine MQC_Matrix_Matrix_Put(Mat,MatrixIn,Rows,Cols)
!
      Implicit None
      Class(MQC_Matrix),Intent(InOut)::Mat
      Type(MQC_Matrix),Intent(In)::MatrixIn
      Integer(kind=int64),Dimension(:),Intent(In)::Rows,Cols
      Integer(kind=int64)::IndI,IndJ,IndK,IndL,LenCol,LenRow
      Integer(kind=int64)::M,N,Cnt1,Cnt2,I,J,K,L
!
!
!     Do the work...
!
 1020 Format( " " )
      If(Size(Rows).gt.2.and.Size(Cols).gt.2) then
        Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_put', 6, &
             'Size(Rows)', Size(Rows), &
             'Size(Cols)', Size(Cols) )
      ElseIf(Size(Rows).eq.2.and.Size(Cols).eq.2) then
          I = Rows(1)
          J = Rows(2)
          K = Cols(1)
          L = Cols(2)
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.1) then
        If(Rows(1).eq.0.and.Cols(1).eq.0) then
          I = 1
          J = Mat%NRow
          K = 1
          L = Mat%NCol
        Else
          Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_put', 6, &
               'Rows(1)', Rows(1), &
               'Cols(1)', Cols(1) )
        EndIf
      ElseIf(Size(Rows).eq.2.and.Size(Cols).eq.1) then
        If(Cols(1).eq.0) then
          I = Rows(1)
          J = Rows(2)
          K = 1
          L = Mat%NCol
        Else
          Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_put', 6, &
               'Cols(1)', Cols(1) )
        EndIf
      ElseIf(Size(Rows).eq.1.and.Size(Cols).eq.2) then
        If(Rows(1).eq.0) then
          I = 1
          J = Mat%NRow
          K = Cols(1)
          L = Cols(2)
        Else
          Call MQC_Error_I('Vector bounds badly specified in mqc_matrix_matrix_put', 6, &
               'Rows(1)', Rows(1) )
        EndIf
      Else
        Call MQC_Error_I('Unspecified boundaries in mqc_matrix_matrix_put', 6, &
             'Size(Rows)', Size(Rows), &
             'Size(Cols)', Size(Cols) )
      EndIf
!
      IndI = I
      IndJ = J
      IndK = K
      IndL = L
      If (IndI.lt.0) IndI = Mat%NRow + IndI + 1
      If (IndJ.lt.0) IndJ = Mat%NRow + IndJ + 1
      If (IndK.lt.0) IndK = Mat%NCol + IndK + 1
      If (IndL.lt.0) IndL = Mat%NCol + IndL + 1
      LenRow = IndJ-IndI+1
      LenCol = IndL-IndK+1
      If (LenRow.lt.0.or.LenRow.gt.Mat%NRow.or.LenRow.ne.MatrixIn%NRow) Call MQC_Error_I('Row length badly &
     &  defined in MQC_Matrix_Matrix_Put', 6, &
     'LenRow', LenRow, &
     'Mat%NRow', Mat%NRow, &
     'MatrixIn%NRow', MatrixIn%NRow )
      If (IndI.le.0.or.IndI.gt.(Mat%NRow-LenRow+1)) Call MQC_Error_I('Index I out of bounds &
     &  in MQC_Matrix_Matrix_At', 6, &
     'IndI', IndI, &
     'Mat%NRow', Mat%NRow, &
     'LenRow', LenRow )
      If (IndJ.lt.LenRow.or.IndJ.gt.Mat%NRow) Call MQC_Error_I('Index J out of bounds &
     &  in MQC_Matrix_Matrix_At', 6, &
     'IndJ', IndJ, &
     'LenRow', LenRow, &
     'Mat%NRow', Mat%NRow )
      If (LenCol.lt.0.or.LenCol.gt.Mat%NCol.or.LenCol.ne.MatrixIn%NCol) Call MQC_Error_I('Column length badly &
     &  defined in MQC_Matrix_Matrix_Put', 6, &
     'LenCol', LenCol, &
     'Mat%NCol', Mat%NCol, &
     'MatrixIn%NCol', MatrixIn%NCol )
      If (IndK.le.0.or.IndK.gt.(Mat%NCol-LenCol+1)) Call MQC_Error_I('Index K out of bounds &
     &  in MQC_Matrix_Matrix_At', 6, &
     'IndK', IndK, &
     'Mat%NCol', Mat%NCol, &
     'LenCol', LenCol )
      If (IndL.lt.LenCol.or.IndL.gt.Mat%NCol) Call MQC_Error_I('Index L out of bounds &
     &  in MQC_Matrix_Matrix_At', 6, &
     'IndL', IndL, &
     'LenCol', LenCol, &
     'Mat%NCol', Mat%NCol )

      If (Mat%Storage.eq.'StorFull') then
        If (Mat%Data_Type.eq.'Integer') then
          If (MatrixIn%Data_Type.eq.'Integer') then
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatI(IndI:IndJ,IndK:IndL) = MatrixIn%MatI
            ElseIf(MatrixIn%Storage.eq.'StorSymm'.or.MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatI(IndI+M-1,IndK+N-1) = MatrixIn%MatI(L,1)
                  Mat%MatI(IndI+N-1,IndK+M-1) = MatrixIn%MatI(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym'.or.MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatI(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatI(L,1)
                  Mat%MatI(IndI+M-1,IndK+N-1) = MatrixIn%MatI(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatI(Cnt1,Cnt2) = (MatrixIn%MatI(M,1))
                  Else
                    Mat%MatI(Cnt1,Cnt2) = 0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          ElseIf (MatrixIn%Data_Type.eq.'Real') then
            Call MQC_Matrix_Copy_Int2Real(Mat)
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatR(IndI:IndJ,IndK:IndL) = MatrixIn%MatR
            ElseIf(MatrixIn%Storage.eq.'StorSymm'.or.MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatR(IndI+M-1,IndK+N-1) = MatrixIn%MatR(L,1)
                  Mat%MatR(IndI+N-1,IndK+M-1) = MatrixIn%MatR(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym'.or.MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatR(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatR(L,1)
                  Mat%MatR(IndI+M-1,IndK+N-1) = MatrixIn%MatR(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatR(Cnt1,Cnt2) = (MatrixIn%MatR(M,1))
                  Else
                    Mat%MatR(Cnt1,Cnt2) = 0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          ElseIf (MatrixIn%Data_Type.eq.'Complex') then
            Call MQC_Matrix_Copy_Int2Complex(Mat)
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatC(IndI:IndJ,IndK:IndL) = MatrixIn%MatC
            ElseIf(MatrixIn%Storage.eq.'StorSymm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatI(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  Mat%MatI(IndI+N-1,IndK+M-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatI(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatC(L,1)
                  Mat%MatI(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatI(IndI+N-1,IndK+M-1) = conjg(MatrixIn%MatC(L,1))
                  Mat%MatI(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatI(IndI+N-1,IndK+M-1) = (-1)*conjg(MatrixIn%MatC(L,1))
                  Mat%MatI(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatC(Cnt1,Cnt2) = (MatrixIn%MatC(M,1))
                  Else
                    Mat%MatC(Cnt1,Cnt2) = 0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          Else
            Call MQC_Error_A('MatrixIn type not defined in MQC_Vector_Vector_Put', 6, &
                 'MatrixIn%Data_Type', MatrixIn%Data_Type )
          EndIf
        ElseIf (Mat%Data_Type.eq.'Real') then
          If (MatrixIn%Data_Type.eq.'Integer') then
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatR(IndI:IndJ,IndK:IndL) = MatrixIn%MatI
            ElseIf(MatrixIn%Storage.eq.'StorSymm'.or.MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatR(IndI+M-1,IndK+N-1) = MatrixIn%MatI(L,1)
                  Mat%MatR(IndI+N-1,IndK+M-1) = MatrixIn%MatI(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym'.or.MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatR(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatI(L,1)
                  Mat%MatR(IndI+M-1,IndK+N-1) = MatrixIn%MatI(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatR(Cnt1,Cnt2) = (MatrixIn%MatI(M,1))
                  Else
                    Mat%MatR(Cnt1,Cnt2) = 0.0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          ElseIf (MatrixIn%Data_Type.eq.'Real') then
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatR(IndI:IndJ,IndK:IndL) = MatrixIn%MatR
            ElseIf(MatrixIn%Storage.eq.'StorSymm'.or.MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatR(IndI+M-1,IndK+N-1) = MatrixIn%MatR(L,1)
                  Mat%MatR(IndI+N-1,IndK+M-1) = MatrixIn%MatR(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym'.or.MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatR(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatR(L,1)
                  Mat%MatR(IndI+M-1,IndK+N-1) = MatrixIn%MatR(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatR(Cnt1,Cnt2) = (MatrixIn%MatR(M,1))
                  Else
                    Mat%MatR(Cnt1,Cnt2) = 0.0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          ElseIf (MatrixIn%Data_Type.eq.'Complex') then
            Call MQC_Matrix_Copy_Real2Complex(Mat)
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatC(IndI:IndJ,IndK:IndL) = matrixIn%MatC
            ElseIf(MatrixIn%Storage.eq.'StorSymm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  Mat%MatC(IndI+N-1,IndK+M-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatC(L,1)
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = conjg(MatrixIn%MatC(L,1))
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = (-1)*conjg(MatrixIn%MatC(L,1))
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatC(Cnt1,Cnt2) = (MatrixIn%MatC(M,1))
                  Else
                    Mat%MatC(Cnt1,Cnt2) = 0.0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          Else
            Call MQC_Error_A('MatrixIn type not defined in MQC_Vector_Vector_Put', 6, &
                 'MatrixIn%Data_Type', MatrixIn%Data_Type )
          EndIf
        ElseIf (Mat%Data_Type.eq.'Complex') then
          If (MatrixIn%Data_Type.eq.'Integer') then
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatC(IndI:IndJ,IndK:IndL) = MatrixIn%MatI
            ElseIf(MatrixIn%Storage.eq.'StorSymm'.or.MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatI(L,1)
                  Mat%MatC(IndI+N-1,IndK+M-1) = MatrixIn%MatI(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym'.or.MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatI(L,1)
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatI(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatC(Cnt1,Cnt2) = (MatrixIn%MatI(M,1))
                  Else
                    Mat%MatC(Cnt1,Cnt2) = 0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          ElseIf (MatrixIn%Data_Type.eq.'Real') then
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatC(IndI:IndJ,IndK:IndL) = MatrixIn%MatR
            ElseIf(MatrixIn%Storage.eq.'StorSymm'.or.MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatR(L,1)
                  Mat%MatC(IndI+N-1,IndK+M-1) = MatrixIn%MatR(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym'.or.MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatR(L,1)
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatR(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatC(Cnt1,Cnt2) = (MatrixIn%MatR(M,1))
                  Else
                    Mat%MatC(Cnt1,Cnt2) = 0.0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage )
            EndIf
          ElseIf (MatrixIn%Data_Type.eq.'Complex') then
            If(MatrixIn%Storage.eq.'StorFull') then
              Mat%MatC(IndI:IndJ,IndK:IndL) = matrixIn%MatC
            ElseIf(MatrixIn%Storage.eq.'StorSymm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  Mat%MatC(IndI+N-1,IndK+M-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAsym') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = (-1)*MatrixIn%MatC(L,1)
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorHerm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = conjg(MatrixIn%MatC(L,1))
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorAhrm') then
              L = 1
              Do M = 1, LenCol
                Do N = 1, M
                  Mat%MatC(IndI+N-1,IndK+M-1) = (-1)*conjg(MatrixIn%MatC(L,1))
                  Mat%MatC(IndI+M-1,IndK+N-1) = MatrixIn%MatC(L,1)
                  L = L + 1
                endDo
              endDo
            ElseIf(MatrixIn%Storage.eq.'StorDiag') then
              M = 1
              N = 1
              Do Cnt1 = IndI, IndJ
                Do Cnt2 = IndK, IndL
                  If (M.eq.N) then
                    Mat%MatC(Cnt1,Cnt2) = (MatrixIn%MatC(M,1))
                  Else
                    Mat%MatC(Cnt1,Cnt2) = 0.0
                  EndIf
                  If(N.eq.LenCol) then
                    N = 1
                  Else
                    N = N + 1
                  EndIf
                EndDo
                M = M + 1
              EndDo
            Else
              Call MQC_Error_A('MatrixIn storage type not recognised in MQC_Matrix_Matrix_Put', 6, &
                   'MatrixIn%Storage', MatrixIn%Storage)
            EndIf
          Else
            Call MQC_Error_A('MatrixIn type not defined in MQC_Vector_Vector_Put', 6, &
                 'MatrixIn%Data_Type', MatrixIn%Data_Type )
          EndIf
        Else
          Call MQC_Error_A('Mat type not defined in MQC_Vector_Vector_Put', 6, &
               'Mat%Data_Type', Mat%Data_Type )
        EndIf
      ElseIf (Mat%Storage.eq.'StorSymm') then
        Call MQC_Matrix_Symm2Full(Mat)
        Call MQC_Matrix_Matrix_Put(Mat,MatrixIn,[IndI,IndJ],[IndK,IndL])
        Write(*,1020)
        If(MQC_Matrix_Test_Symmetric(Mat)) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorAsym') then
        Call MQC_Matrix_Symm2Full(Mat)
        Call MQC_Matrix_Matrix_Put(Mat,MatrixIn,[IndI,IndJ],[IndK,IndL])
        Write(*,1020)
        If(MQC_Matrix_Test_Symmetric(Mat,'antisymmetric')) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorHerm') then
        Call MQC_Matrix_Symm2Full(Mat)
        Call MQC_Matrix_Matrix_Put(Mat,MatrixIn,[IndI,IndJ],[IndK,IndL])
        Write(*,1020)
        If(MQC_Matrix_Test_Symmetric(Mat,'hermitian')) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorAhrm') then
        Call MQC_Matrix_Symm2Full(Mat)
        Call MQC_Matrix_Matrix_Put(Mat,MatrixIn,[IndI,IndJ],[IndK,IndL])
        Write(*,1020)
        If(MQC_Matrix_Test_Symmetric(Mat,'antihermitian')) Call MQC_Matrix_Full2Symm(Mat)
      ElseIf (Mat%Storage.eq.'StorDiag') then
        Call MQC_Matrix_Diag2Full(Mat)
        Call MQC_Matrix_Matrix_Put(Mat,MatrixIn,[IndI,IndJ],[IndK,IndL])
        If(MQC_Matrix_Test_Diagonal(Mat)) Call MQC_Matrix_Full2Diag(Mat)
      Else
        Call MQC_Error_A('Mat storage type not recognosed in MQC_Matrix_Vector_Put', 6, &
             'Mat%Storage', Mat%Storage )
      EndIf

      End Subroutine MQC_Matrix_Matrix_Put
!
!
!     PROCEDURE MQC_Matrix_Pad
!
!>    \brief <b> MQC_Matrix_Pad is a function that increases the dimension of a
!>    MQC matrix and set the new elements to zero.</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Pad is a function that increases the dimension of a
!>    MQC matrix and set the new elements to zero. Each dimension of the
!>    final MQC matrix cannot be smaller that the input one.
!>    To reduce the dimension of a MQC matrix use MQC_Matrix_Matrix_At.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Mat is Class(MQC_Matrix)
!>        The MQC matrix from which the dimension will be increased.
!>    \endverbatim
!>
!>    \param[in] Rows
!>    \verbatim
!>        Rows is Integer(kind=int64)
!>        The specification of the number of rows after padding.
!>        The final number of rows must be larger or equal to the initial.
!>        Otherwise the rows of the final matrix is the same as the initial
!>        one. To reduce the dimension of a MQC matrix use MQC_Matrix_Matrix_At.
!>        If Rows > Matrix%NRow
!>          The MatrixOut%Row = Rows
!>        else
!>          The MatrixOut%Row = Matrix%Row
!>    \endverbatim
!>
!>    \param[in] Cols
!>    \verbatim
!>        Cols is Integer(kind=int64)
!>        The specification of the number of columns after padding.
!>        The final number of columns must be larger or equal to the initial.
!>        Otherwise the columns of the final matrix is the same as the initial
!>        one. To reduce the dimension of a MQC matrix use MQC_Matrix_Matrix_At.
!>        If Cols > Matrix%NCol
!>          The MatrixOut%Col = Cols
!>        else
!>          The MatrixOut%Col = Matrix%Col
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2025
!
      function MQC_Matrix_Pad(Matrix,Rows,Cols) result(MatrixOut)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Matrix
      Integer(kind=int64),Intent(In)::Rows,Cols
      Type(MQC_Matrix)::MatrixOut

      if (Rows.le.Matrix%NRow) then
        if (Cols.le.Matrix%NCol) then
          MatrixOut = Matrix
        else
          call MatrixOut%init(Matrix%NRow,Cols)
          call MatrixOut%mput(Matrix,[1,Matrix%NRow],[1,Matrix%NCol])
        end if
      else
        if (Cols.le.Matrix%NCol) then
          call MatrixOut%init(Rows,Matrix%NCol)
          call MatrixOut%mput(Matrix,[1,Matrix%NRow],[1,Matrix%NCol])
        else
          call MatrixOut%init(Rows,Cols)
          call MatrixOut%mput(Matrix,[1,Matrix%NRow],[1,Matrix%NCol])
        end if
      end if
!
      end function MQC_Matrix_Pad
!
!
!     PROCEDURE SymIndexHash
!
!>    \brief <b> SymIndexHash is a function that returns the index in a vector of a 
!>    symmetric-packed matrix or rank-4 tensor</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    SymIndexHash is a function that returns the index in a vector of a symmetric-
!>    packed matrix or rank-4 tensor. If a matrix is tested, it is assumed lower-
!>    triangular row-wise stored.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] I
!>    \verbatim
!>        I is integer(kind=int64)
!>        The first index of the matrix/rank-4 tensor.
!>    \endverbatim
!>    
!>    \param[in] J
!>    \verbatim
!>        I is integer(kind=int64)
!>        The second index of the matrix/rank-4 tensor.
!>    \endverbatim
!>    
!>    \param[in] K
!>    \verbatim
!>        K is integer(kind=int64),Optional
!>        The third index of the rank-4 tensor. This argument is
!>        only required when taking hash of a rank-4 tensor.
!>    \endverbatim
!>    
!>    \param[in] L
!>    \verbatim
!>        L is integer(kind=int64),Optional
!>        The fourth index of the rank-4 tensor. This argument is
!>        only required when taking hash of a rank-4 tensor.
!>    \endverbatim
!>    
!>    \param[in] OrderIn
!>    \verbatim
!>        OrderIn is Character(Len=*),optional
!>        The symmetry order for rank-4 tensors. Options are:
!>        = '8-fold':  8-fold symmetry (default)
!>        = '4-fold':  4-fold symmetry 
!>       =  '2-fold':  2-fold symmetry
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \author L. M. Thompson
!>    \date 2017
!
      Function symIndexHash(i,j,k,l,orderIn) result(hash)

      implicit none
      integer(kind=int64),intent(in)::i,j
      integer(kind=int64),intent(in),optional::k,l
      integer(kind=int64)::ij,kl,ijkl,hash
      character(Len=*),intent(in),optional::orderIn
      character(Len=64)::order

      if(.not.(present(k).and.present(l))) then

        if(i.gt.j) then
          ij = i*(i-1)/2+j
        else
          ij = j*(j-1)/2+i
        endif
        hash = ij

      elseIf(present(k).and.present(l)) then

        if(.not.present(orderIn)) then
          order = '8-fold'
        else
          order = orderIn
        endIf

        if(order.eq.'8-fold') then
          if(i.gt.j) then
            ij = i*(i-1)/2+j
          else
            ij = j*(j-1)/2+i
          endif
          if(k.gt.l) then
            kl = k*(k-1)/2+l 
          else
            kl = l*(l-1)/2+k
          endIf
          if(ij.gt.kl) then
            ijkl = ij*(ij-1)/2+kl 
          else
            ijkl = kl*(kl-1)/2+ij 
          endIf
          hash = ijkl
        elseIf(order.eq.'2-fold') then
          if(i.gt.j) then
            ij = (i-1)**2+j
          else
            ij = (j-1)**2+(j-1)+i
          endif
          if(k.gt.l) then
            kl = (k-1)**2+l
          else
            kl = (l-1)**2+(l-1)+k
          endif
          if(ij.gt.kl) then
            ijkl = ij*(ij-1)/2+kl 
          else
            ijkl = kl*(kl-1)/2+ij 
          endIf
          hash = ijkl
        else
          call mqc_error_A('Unrecognized order option in synIndexHash',6,'order',order)
        endIf
      endif

      end function symIndexHash
!
!
!     PROCEDURE MQC_ElementMatrixProduct
!
!>    \brief <b> MQC_ElementMatrixProduct is a function that returns the element-
!>    wise product of two MQC matrices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ElementMatrixProduct is a function that returns the element-wise product 
!>    of two MQC matrices.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is type(mqc_matrix)
!>        The first matrix to element-wise multiply.
!>    \endverbatim
!>    
!>    \param[in] B
!>    \verbatim
!>        B is type(mqc_matrix)
!>        The second matrix to element-wise multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_ElementMatrixProduct(A,B) Result(C)
!
      implicit none
      type(mqc_matrix),intent(in)::A,B
      type(mqc_matrix)::C
      integer(kind=int64)::i,j

      if (A%NRow .ne. B%NRow .or. A%NCol .ne. B%NCol) then
        call mqc_error_I('The two matrices must have the same dimensions in MQC_elementMatrixProduct', 6, &
             'A%NRow', A%NRow, &
             'B%NRow', B%NRow, &
             'A%NCol', A%NCol, &
             'B%NCol', B%NCol )
      endif

      if (A%data_type .eq. 'Integer') then
        if (B%data_type .eq. 'Integer') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              C%matI = A%matI * B%matI
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matI(i,j) = A%matI(i,j) * B%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matI(i,j) = A%matI(i,j) * B%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matI(i,j) = (-1)*C%matI(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                C%matI(i,1) = A%matI(i,i) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matI(i,j) = B%matI(i,j) * A%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorSymm')
              C%matI(:,1) = A%matI(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorAsym')
              C%matI(:,1) = A%matI(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                  C%matI(i,1) = A%matI(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matI(i,j) = B%matI(i,j) * A%matI(symIndexHash(i,j),1)
                  If(j.gt.i) C%matI(i,j) = (-1)*C%matI(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorAsym')
              C%matI(:,1) = A%matI(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorSymm')
              C%matI(:,1) = A%matI(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                  C%matI(i,1) = A%matI(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                C%matI(i,1) = B%matI(i,i) * A%matI(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                  C%matI(i,1) = B%matI(symIndexHash(i,i),1) * A%matI(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                  C%matI(i,1) = 0
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              C%matI(:,1) = A%matI(:,1) * B%matI(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Real') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              C%matR = A%matI * B%matR
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matI(i,j) * B%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matI(i,j) * B%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matR(i,j) = (-1)*C%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = A%matI(i,i) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = B%matR(i,j) * A%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matI(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matI(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matI(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = B%matR(i,j) * A%matI(symIndexHash(i,j),1)
                  If(j.gt.i) C%matR(i,j) = (-1)*C%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matI(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matI(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matI(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = B%matR(i,i) * A%matI(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = B%matR(symIndexHash(i,i),1) * A%matI(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = 0.0
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              C%matR(:,1) = A%matI(:,1) * B%matR(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Complex') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matI * B%matC
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matI(i,j) * B%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matI(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matI(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matI(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matI(i,i) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matI(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matI(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matI(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matI(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = B%matC(i,i) * A%matI(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = B%matC(symIndexHash(i,i),1) * A%matI(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = (0.0,0.0)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matI(:,1) * B%matC(:,1)
            endif
          endif
        endif
      else if (A%data_type .eq. 'Real') then
        if (B%data_type .eq. 'Integer') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              C%matR = A%matR * B%matI
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(i,j) * B%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(i,j) * (-1)*B%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matR(i,j) = (-1)*C%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = A%matR(i,i) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = B%matI(i,j) * A%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = B%matI(i,j) * A%matR(symIndexHash(i,j),1)
                  If(j.gt.i) C%matR(i,j) = (-1)*C%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = B%matI(i,i) * A%matR(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = B%matI(symIndexHash(i,i),1) * A%matR(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = 0.0
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              C%matR(:,1) = A%matR(:,1) * B%matI(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Real') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              C%matR = A%matR * B%matR
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(i,j) * B%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(i,j) * (-1)*B%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matR(i,j) = (-1)*C%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = A%matR(i,i) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = B%matR(i,j) * A%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = B%matR(i,j) * A%matR(symIndexHash(i,j),1)
                  If(j.gt.i) C%matR(i,j) = (-1)*C%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = B%matR(i,i) * A%matR(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = B%matR(symIndexHash(i,i),1) * A%matR(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = 0.0
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              C%matR(:,1) = A%matR(:,1) * B%matR(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Complex') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matR * B%matC
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matR(i,j) * B%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matR(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matR(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matR(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matR(i,i) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matR(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matR(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matR(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matR(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = B%matC(i,i) * A%matR(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = B%matC(symIndexHash(i,i),1) * A%matR(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = (0.0,0.0)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matR(:,1) * B%matC(:,1)
            endif
          endif
        endif
      else if (A%data_type .eq. 'Complex') then
        if (B%data_type .eq. 'Integer') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matC * B%matI
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matI(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matC(i,i) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matI(i,j) * A%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matI(i,j) * A%matC(symIndexHash(i,j),1)
                  If(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matI(i,j) * A%matC(symIndexHash(i,j),1)
                  If(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matI(i,j) * A%matC(symIndexHash(i,j),1)
                  If(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matI(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = B%matI(i,i) * A%matC(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = B%matI(symIndexHash(i,i),1) * A%matC(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = (0.0,0.0)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matC(:,1) * B%matI(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Real') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matC * B%matR
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorASym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matR(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matC(i,i) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matR(i,j) * A%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matR(i,j) * A%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorASym')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matR(i,j) * A%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matR(i,j) * A%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(symIndexHash(i,i),1) * B%matR(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = B%matR(i,i) * A%matC(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = B%matR(symIndexHash(i,i),1) * A%matC(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = (0.0,0.0)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matC(:,1) * B%matR(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Complex') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matC * B%matC
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) * B%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matC(i,i) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*C%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = B%matC(i,j) * A%matC(symIndexHash(i,j),1)
                  if(j.gt.i) C%matC(i,j) = (-1)*conjg(C%matC(i,j))
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(symIndexHash(i,i),1) * B%matC(i,1)
              enddo
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = B%matC(i,i) * A%matC(i,1)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = B%matC(symIndexHash(i,i),1) * A%matC(i,1)
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = (0.0,0.0)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matC(:,1) * B%matC(:,1)
            endif
          endif
        endif
      endif

      end function MQC_elementMatrixProduct
!
!
!     PROCEDURE MQC_ElementMatrixDivide
!
!>    \brief <b> MQC_ElementMatrixDivide is a function that returns the element-
!>    wise quotient of two MQC matrices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ElementMatrixDivide is a function that returns the element-wise quotient 
!>    of two MQC matrices.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is type(mqc_matrix)
!>        The matrix with elements being the numerator.
!>    \endverbatim
!>    
!>    \param[in] B
!>    \verbatim
!>        B is type(mqc_matrix)
!>        The matrix with elements being the denominator.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_ElementMatrixDivide(A,B) Result(C)
!
      implicit none
      type(mqc_matrix),intent(in)::A,B
      type(mqc_matrix)::C,Tmp1
      integer(kind=int64)::i,j

      if (A%NRow .ne. B%NRow .or. A%NCol .ne. B%NCol) then
        call mqc_error_I('The two matrices must have the same dimensions in MQC_elementMatrixDivide', 6, &
             'A%NRow', A%NRow, &
             'B%NRow', B%NRow, &
             'A%NCol', A%NCol, &
             'B%NCol', B%NCol )
      endif

      if (A%data_type .eq. 'Integer') then
        if (B%data_type .eq. 'Integer') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              C%matI = A%matI / B%matI
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matI(i,j) = A%matI(i,j) / B%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matI(i,j) = A%matI(i,j) / B%matI(symIndexHash(i,j),1)
                  else
                    C%matI(i,j) = A%matI(i,j) / (-1)*B%matI(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matI = A%matI / B%matI
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matI(i,j) = A%matI(symIndexHash(i,j),1) / B%matI(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorSymm')
              C%matI(:,1) = A%matI(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorAsym')
              C%matI(:,1) = A%matI(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matI(:,1) = A%matI(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matI(i,j) = A%matI(symIndexHash(i,j),1) / B%matI(i,j)
                  else
                    C%matI(i,j) = (-1)*A%matI(symIndexHash(i,j),1) / B%matI(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorAsym')
              C%matI(:,1) = A%matI(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorSymm')
              C%matI(:,1) = A%matI(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorAsym')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matI(:,1) = A%matI(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                C%matI(i,1) = A%matI(i,1) / B%matI(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              do i = 1, A%NRow
                  C%matI(i,1) = A%matI(i,1) / B%matI(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Integer','StorDiag')
              C%matI(:,1) = A%matI(:,1) / B%matI(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Real') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              C%matR = A%matI / B%matR
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matI(i,j) / B%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matR(i,j) = A%matI(i,j) / B%matR(symIndexHash(i,j),1)
                  else
                    C%matR(i,j) = A%matI(i,j) / (-1)*B%matR(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matR = A%matI / B%matR
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matI(symIndexHash(i,j),1) / B%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matI(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matI(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matR(:,1) = A%matI(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matR(i,j) = A%matI(symIndexHash(i,j),1) / B%matR(i,j)
                  else
                    C%matR(i,j) = (-1)*A%matI(symIndexHash(i,j),1) / B%matR(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matI(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matI(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matR(:,1) = A%matI(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = A%matI(i,1) / B%matR(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matI(i,1) / B%matR(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              C%matR(:,1) = A%matI(:,1) / B%matR(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Complex') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matI / B%matC
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matI(i,j) / B%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matI(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matI(i,j) / (-1)*B%matC(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matI(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matI(i,j) / conjg(B%matC(symIndexHash(i,j),1))
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matI(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matI(i,j) / (-1)*conjg(B%matC(symIndexHash(i,j),1))
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matC = A%matI / B%matC
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matI(symIndexHash(i,j),1) / B%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matI(symIndexHash(i,j),1) / B%matC(i,j)
                  else
                    C%matC(i,j) = (-1)*A%matI(symIndexHash(i,j),1) / B%matC(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matI(i,1) / B%matC(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matI(i,1) / B%matC(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matI(:,1) / B%matC(:,1)
            endif
          endif
        endif
      else if (A%data_type .eq. 'Real') then
        if (B%data_type .eq. 'Integer') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              C%matR = A%matR / B%matI
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(i,j) / B%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matR(i,j) = A%matR(i,j) / B%matI(symIndexHash(i,j),1)
                  else
                    C%matR(i,j) = A%matR(i,j) / (-1)*B%matI(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matR = A%matR / B%matI
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(symIndexHash(i,j),1) / B%matI(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matR(:,1) = A%matR(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matR(i,j) = A%matR(symIndexHash(i,j),1) / B%matI(i,j)
                  else
                    C%matR(i,j) = (-1)*A%matR(symIndexHash(i,j),1) / B%matI(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matR(:,1) = A%matR(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = A%matR(i,1) / B%matI(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(i,1) / B%matI(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              C%matR(:,1) = A%matR(:,1) / B%matI(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Real') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              C%matR = A%matR / B%matR
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(i,j) / B%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matR(i,j) = A%matR(i,j) / B%matR(symIndexHash(i,j),1)
                  else
                    C%matR(i,j) = A%matR(i,j) / (-1)*B%matR(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matR = A%matR / B%matR
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matR(i,j) = A%matR(symIndexHash(i,j),1) / B%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matR(:,1) = A%matR(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matR(i,j) = A%matR(symIndexHash(i,j),1) / B%matR(i,j)
                  else
                    C%matR(i,j) = (-1)*A%matR(symIndexHash(i,j),1) / B%matR(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              C%matR(:,1) = A%matR(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorSymm')
              C%matR(:,1) = A%matR(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorAsym')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matR(:,1) = A%matR(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                C%matR(i,1) = A%matR(i,1) / B%matR(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              do i = 1, A%NRow
                  C%matR(i,1) = A%matR(i,1) / B%matR(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Real','StorDiag')
              C%matR(:,1) = A%matR(:,1) / B%matR(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Complex') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matR / B%matC
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matR(i,j) / B%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matR(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matR(i,j) / (-1)*B%matC(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matR(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matR(i,j) / conjg(B%matC(symIndexHash(i,j),1))
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matR(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matR(i,j) / (-1)*conjg(B%matC(symIndexHash(i,j),1))
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matC = A%matR / B%matC
            endif
          else if (A%storage .eq. 'StorSymm'.or.A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matR(symIndexHash(i,j),1) / B%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorAsym'.or.A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matR(symIndexHash(i,j),1) / B%matC(i,j)
                  else
                    C%matC(i,j) = (-1)*A%matR(symIndexHash(i,j),1) / B%matC(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matR(i,1) / B%matC(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matR(i,1) / B%matC(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            endif
          endif
        endif
      else if (A%data_type .eq. 'Complex') then
        if (B%data_type .eq. 'Integer') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matC / B%matI
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) / B%matI(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(i,j) / B%matI(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matC(i,j) / (-1)*B%matI(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matC = A%matC / B%matI
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matI(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matI(i,j)
                  else
                    C%matC(i,j) = (-1)*A%matC(symIndexHash(i,j),1) / B%matI(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matI(i,j)
                  else
                    C%matC(i,j) = conjg(A%matC(symIndexHash(i,j),1)) / B%matI(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matI(i,j)
                  else
                    C%matC(i,j) = (-1)*conjg(A%matC(symIndexHash(i,j),1)) / B%matI(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matC(i,1) / B%matI(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(i,1) / B%matI(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matC(:,1) / B%matI(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Real') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matC / B%matR
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) / B%matR(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(i,j) / B%matR(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matC(i,j) / (-1)*B%matR(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matC = A%matC / B%matR
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matR(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matR(i,j)
                  else
                    C%matC(i,j) = (-1)*A%matC(symIndexHash(i,j),1) / B%matR(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matR(i,j)
                  else
                    C%matC(i,j) = conjg(A%matC(symIndexHash(i,j),1)) / B%matR(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matR(i,j)
                  else
                    C%matC(i,j) = (-1)*conjg(A%matC(symIndexHash(i,j),1)) / B%matR(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matC(i,1) / B%matR(i,i)
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matC(i,1) / B%matR(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matC(:,1) / B%matR(:,1)
            endif
          endif
        else if (B%data_type .eq. 'Complex') then
          if (A%storage .eq. 'StorFull') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              C%matC = A%matC / B%matC
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(i,j) / B%matC(symIndexHash(i,j),1)
                enddo
              enddo
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matC(i,j) / (-1)*B%matC(symIndexHash(i,j),1)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matC(i,j) / conjg(B%matC(symIndexHash(i,j),1))
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(i,j) / B%matC(symIndexHash(i,j),1)
                  else
                    C%matC(i,j) = A%matC(i,j) / (-1)*conjg(B%matC(symIndexHash(i,j),1))
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              Tmp1 = B
              call mqc_matrix_diag2full(Tmp1)
              C%matC = A%matC / B%matC
            endif
          else if (A%storage .eq. 'StorSymm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matC(i,j)
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorAsym') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matC(i,j)
                  else
                    C%matC(i,j) = (-1)*A%matC(symIndexHash(i,j),1) / B%matC(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorHerm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matC(i,j)
                  else
                    C%matC(i,j) = conjg(A%matC(symIndexHash(i,j),1)) / B%matC(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorSymm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorAhrm') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorFull')
              do i = 1, A%NRow
                do j = 1, A%NCol
                  if(i.ge.j) then
                    C%matC(i,j) = A%matC(symIndexHash(i,j),1) / B%matC(i,j)
                  else
                    C%matC(i,j) = (-1)*conjg(A%matC(symIndexHash(i,j),1)) / B%matC(i,j)
                  endIf
                enddo
              enddo
            else if (B%storage .eq. 'StorSymm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAsym') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorHerm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAsym')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorHerm')
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorAhrm')
              Tmp1 = B
              call mqc_matrix_diag2symm(Tmp1)
              C%matC(:,1) = A%matC(:,1) / B%matC(:,1)
            endif
          else if (A%storage .eq. 'StorDiag') then
            if (B%storage .eq. 'StorFull') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                C%matC(i,1) = A%matR(i,1) / B%matC(i,i) 
              enddo
            else if (B%storage .eq. 'StorSymm'.or.B%storage .eq. 'StorHerm'.or.&
              B%storage .eq. 'StorAsym'.or.B%storage .eq. 'StorAhrm') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              do i = 1, A%NRow
                  C%matC(i,1) = A%matR(i,1) /  B%matC(symIndexHash(i,i),1)
              enddo
            else if (B%storage .eq. 'StorDiag') then
              call mqc_allocate_matrix(A%NRow,A%NCol,C,'Complex','StorDiag')
              C%matC(:,1) = A%matR(:,1) / B%matC(:,1)
            endif
          endif
        endif
      endif

      end function MQC_elementMatrixDivide
!
!
!     PROCEDURE MQC_ElementMatrixPower
!
!>    \brief <b> MQC_ElementMatrixPower is a function that returns the matrix with
!>    each element raised to the power specified</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ElementMatrixPower is a function that returns the matrix with each element 
!>    raised to the power specified.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is type(mqc_matrix)
!>        The matrix raised to be operated on.
!>    \endverbatim
!>    
!>    \param[in] P
!>    \verbatim
!>        P is class(*)
!>        The power to raise each element in the matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_ElementMatrixPower(A,P) Result(C)
!
      implicit none
      type(mqc_matrix),intent(in)::A
      class(*),intent(in)::P
      type(mqc_matrix)::C
      type(mqc_scalar)::Psca
      integer(kind=int64)::i,j

      select type(P)
      type is (integer)
        Psca = P
      type is (real)
        Psca = P
      type is (complex)
        Psca = P
      type is (mqc_scalar)
        Psca = P
      class default
        call mqc_error_I('P type not defined in MQC_ElementMatrixPower',6)
      end select

      C = A

      select case (A%data_type)
      case('Integer')
        select case (Psca%data_type)
        case('Integer')
          C%MatI = C%MatI**Psca%ScaI
        case('Real')
          C%MatI = C%MatI**Psca%ScaR
        case('Complex')
          C%MatI = C%MatI**Psca%ScaC
        case default
          call mqc_error_a('Unrecognized data type of scalar Psca in MQC_ElementMatrixPower',6,'Psca%data_type',&
            Psca%data_type)
        end select
      case('Real')
        select case (Psca%data_type)
        case('Integer')
          C%MatR = C%MatR**Psca%ScaI
        case('Real')
          C%MatR = C%MatR**Psca%ScaR
        case('Complex')
          C%MatR = C%MatR**Psca%ScaC
        case default
          call mqc_error_a('Unrecognized data type of scalar Psca in MQC_ElementMatrixPower',6,'Psca%data_type',&
            Psca%data_type)
        end select
      case('Complex')
        select case (Psca%data_type)
        case('Integer')
          C%MatC = C%MatC**Psca%ScaI
        case('Real')
          C%MatC = C%MatC**Psca%ScaR
        case('Complex')
          C%MatC = C%MatC**Psca%ScaC
        case default
          call mqc_error_a('Unrecognized data type of scalar Psca in MQC_ElementMatrixPower',6,'Psca%data_type',&
            Psca%data_type)
        end select
      case default
        call mqc_error_a('Unrecognized data type of matrix A in MQC_ElementMatrixPower',6,'A%data_type',&
          A%data_type)
      end select

      End Function MQC_ElementMatrixPower
!
!     PROCEDURE MQC_Matrix_Test_Symmetric
!
!>    \brief <b> MQC_Matrix_Test_Symmetric is a function that tests a MQC matrix for
!>    symmetry</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Test_Symmetric is a function that tests a MQC matrix for symmetry 
!>    specified by optional argument, with the default test being for a symmetric
!>    matrix. Note that this function differs from haveSymmetric subroutine which
!>    tests how a matrix is packed. The optional logical argument Math can be used
!>    to test the diagonal elements and so return true/false based on the 
!>    mathematical definition rather that the default, which returns true if the 
!>    matrix can be stored in the specified lower-triangular packing format (i.e.
!>    without any constraints on the form of diagonal elements). The following 
!>    options are available: 
!>
!>    1. Option = 'any' tests all matrix symmetries (default).
!>    2. Option = 'symmetric' tests for a symmetric matrix.
!>    3. Option = 'antisymmetric' tests for an antisymmetric matrix.
!>    4. Option = 'hermitian' tests for a hermitian matrix.
!>    5. Option = 'antihermitian' tests for an antihermitian matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Class(mqc_matrix)
!>        The matrix to be tested for symmetry.
!>    \endverbatim
!>    
!>    \param[in] Option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'any':           test all matrix symmetries
!>        = 'symmetric':     symmetric matrix test (default)
!>        = 'antisymmetric': antisymmetric matrix test
!>        = 'hermitian':     hermitian matrix test
!>        = 'antihermitian': antihermitian matrix test.
!>    \endverbatim
!>
!>    \param[in] Math
!>    \verbatim
!>        Math is Logical,Optional 
!>        If true, do additional tests on diagonal elements  
!>        for mathematical definition. The default is false.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      recursive Function MQC_Matrix_Test_Symmetric(Matrix,Option,Math) Result(Symmetric)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Matrix
      Character(len=*),Optional,Intent(In)::Option
      Logical,Optional,Intent(In)::Math
      Logical::Symmetric,myMath
      Integer(kind=int64)::I,J,K
      Real(kind=real64)::Thresh=1e-10
      Character(len=64)::myOption

      If(Present(Option)) then
        call string_change_case(Option,'l',myOption)
      else
        myOption = 'any'
      endIf

      If(Present(Math)) then
        myMath = Math
      else
        myMath = .false.
      endIf

      Symmetric = .True.
      Select Case (myOption)
      Case ('symmetric')
        If(MQC_Matrix_Rows(Matrix).ne.MQC_Matrix_Columns(Matrix)) then
          Symmetric = .False.
          Return
        Else
          If(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorDiag') then
            Return
          ElseIf(Matrix%Storage.eq.'StorAsym') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I-1
                If(Matrix%Data_Type.eq.'Integer') then
                  If(Matrix%MatI(symIndexHash(I,J),1).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If(abs(Matrix%MatR(symIndexHash(I,J),1)).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If((abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) .or. &
                    (abs(Aimag(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh)) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                       'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          ElseIf(Matrix%Storage.eq.'StorHerm') then
            If(Matrix%Data_Type.eq.'Integer'.or.Matrix%Data_Type.eq.'Real') then
              return
            ElseIf(Matrix%Data_Type.eq.'Complex') then
              Do I = 1, MQC_Matrix_Rows(Matrix)
                Do J = 1, I-1
                  If(abs(Aimag(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              EndDo
            Else
              Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                   'Matrix%Data_Type', Matrix%Data_Type )
            EndIf
          ElseIf(Matrix%Storage.eq.'StorAhrm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I-1
                If(Matrix%Data_Type.eq.'Integer') then
                  If(Matrix%MatI(symIndexHash(I,J),1).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If(abs(Matrix%MatR(symIndexHash(I,J),1)).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If(abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                       'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          ElseIf(Matrix%Storage.eq.'StorFull') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I-1
                If(Matrix%Data_Type.eq.'Integer') then
                  If((Matrix%MatI(I,J) - Matrix%MatI(J,I)).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If(abs((Matrix%MatR(I,J) - Matrix%MatR(J,I))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If((abs(Real(Matrix%MatC(I,J)) - Real(Matrix%MatC(J,I))).gt.Thresh) .or. &
                    (abs(Aimag(Matrix%MatC(I,J)) - Aimag(Matrix%MatC(J,I))).gt.Thresh)) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                       'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          Else
            Call MQC_Error_A('Matrix type not identified in MQC_Matrix_Test_Symmetric', 6, &
                 'Matrix%Storage', Matrix%Storage )
          EndIf
        EndIf
      Case ('antisymmetric')
        If(MQC_Matrix_Rows(Matrix).ne.MQC_Matrix_Columns(Matrix)) then
          Symmetric = .False.
        Else
          If(myMath) then
            If (MQC_Vector_Norm(Matrix%diagonal()).gt.Thresh) then
              Symmetric = .False.
              Return
            EndIf
          EndIf
          If(Matrix%Storage.eq.'StorDiag') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                If(Matrix%MatI(I,1).ne.0) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Real') then
                If(abs(Matrix%MatR(I,1)).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Complex') then
                If((abs(Real(Matrix%MatC(I,1))).gt.Thresh) .or. &
                  (abs(Aimag(Matrix%MatC(I,1))).gt.Thresh)) then
                  Symmetric = .False.
                  Return
                EndIf
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorSymm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I
                If(Matrix%Data_Type.eq.'Integer') then
                  If(Matrix%MatI(symIndexHash(I,J),1).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If(abs(Matrix%MatR(symIndexHash(I,J),1)).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If((abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) .or. &
                    (abs(Aimag(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh)) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                       'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          ElseIf(Matrix%Storage.eq.'StorAsym') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                If(Matrix%MatI(symIndexHash(I,I),1).ne.0) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Real') then
                If(abs(Matrix%MatR(symIndexHash(I,I),1)).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Complex') then
                If((abs(Real(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh) .or. &
                  (abs(Aimag(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh)) then
                  Symmetric = .False.
                  Return
                EndIf
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorHerm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I-1
                If(Matrix%Data_Type.eq.'Integer') then
                  If(Matrix%MatI(symIndexHash(I,J),1).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                ElseIf(Matrix%Data_Type.eq.'Real') then
                  If(Matrix%MatR(symIndexHash(I,J),1).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                ElseIf(Matrix%Data_Type.eq.'Complex') then
                  If(abs(real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                    'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          ElseIf(Matrix%Storage.eq.'StorAhrm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                If(Matrix%MatI(symIndexHash(I,I),1).ne.0) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Real') then
                If(Matrix%MatR(symIndexHash(I,I),1).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Complex') then
                If((abs(Real(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh) .or. &
                  (abs(Aimag(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh)) then
                  Symmetric = .False.
                  Return
                EndIf
                Do J = 1, I-1
                  If(abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorFull') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I-1
                If(Matrix%Data_Type.eq.'Integer') then
                  If((Matrix%MatI(I,J) + Matrix%MatI(J,I)).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If(abs(Matrix%MatR(I,J) + Matrix%MatR(J,I)).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If((abs(Real(Matrix%MatC(I,J)) + Real(Matrix%MatC(J,I))).gt.Thresh) .or. &
                    (abs(Aimag(Matrix%MatC(I,J)) + Aimag(Matrix%MatC(J,I))).gt.Thresh)) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                       'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          Else
            Call MQC_Error_A('Matrix type not identified in MQC_Matrix_Test_Symmetric', 6, &
                 'Matrix%Storage', Matrix%Storage )
          EndIf
        EndIf
      Case ('hermitian')
        If(MQC_Matrix_Rows(Matrix).ne.MQC_Matrix_Columns(Matrix)) then
          Symmetric = .False.
        Else
          If(myMath) then
            If (MQC_Vector_Norm(aimag(Matrix%diagonal())).gt.Thresh) then
              Symmetric = .False.
              Return
            EndIf
          EndIf
          If(Matrix%Storage.eq.'StorDiag') then
            If(Matrix%Data_Type.eq.'Integer'.or.Matrix%Data_Type.eq.'Real') then
              return
            ElseIf(Matrix%Data_Type.eq.'Complex') then
              Do I = 1, MQC_Matrix_Rows(Matrix)
                If(abs(Aimag(Matrix%MatC(I,1))).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              EndDo
            Else
              Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                   'Matrix%Data_Type', Matrix%Data_Type )
            EndIf
          ElseIf(Matrix%Storage.eq.'StorSymm') then
            If(Matrix%Data_Type.eq.'Integer'.or.Matrix%Data_Type.eq.'Real') then
              return
            ElseIf(Matrix%Data_Type.eq.'Complex') then
              Do I = 1, MQC_Matrix_Rows(Matrix)
                Do J = 1, I
                  K = symIndexHash(I,J)
                  If(abs(Aimag(Matrix%MatC(K,1))).gt.Thresh) then
                    Symmetric = .False.
                    return
                  EndIf
                EndDo
              EndDo
            Else
              Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                   'Matrix%Data_Type', Matrix%Data_Type )
            EndIf
          ElseIf(Matrix%Storage.eq.'StorAsym') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                Do J = 1, I-1
                  K = symIndexHash(I,J)
                  If(Matrix%MatI(K,1).ne.0) then
                    Symmetric = .False.
                    return
                  EndIf
                EndDo
              ElseIf(Matrix%Data_Type.eq.'Real') then
                Do J = 1, I-1
                  K = symIndexHash(I,J)
                  If(abs(Matrix%MatR(K,1)).gt.Thresh) then
                    Symmetric = .False.
                    return
                  EndIf
                EndDo
              ElseIf(Matrix%Data_Type.eq.'Complex') then
                If(abs(Aimag(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
                Do J = 1, I-1
                  If(abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorHerm') then
            If(Matrix%Data_Type.eq.'Integer'.or.Matrix%Data_Type.eq.'Real') then
              return
            ElseIf(Matrix%Data_Type.eq.'Complex') then
              Do I = 1, MQC_Matrix_Rows(Matrix)
                K = symIndexHash(I,I)
                If(abs(Aimag(Matrix%MatC(K,1))).gt.Thresh) then
                  Symmetric = .False.
                  return
                EndIf
              EndDo
            Else
              Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                   'Matrix%Data_Type', Matrix%Data_Type )
            EndIf
          ElseIf(Matrix%Storage.eq.'StorAhrm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                Do J = 1, I-1
                  If(Matrix%MatI(symIndexHash(I,J),1).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              elseIf(Matrix%Data_Type.eq.'Real') then
                Do J = 1, I-1
                  If(abs(Matrix%MatR(symIndexHash(I,J),1)).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              elseIf(Matrix%Data_Type.eq.'Complex') then
                If(abs(Aimag(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
                Do J = 1, I-1
                  If((abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) .or. &
                    (abs(Aimag(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh)) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorFull') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I-1
                If(Matrix%Data_Type.eq.'Integer') then
                  If((Matrix%MatI(I,J) - Matrix%MatI(J,I)).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If(abs(Matrix%MatR(I,J) - Matrix%MatR(J,I)).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If((abs(Real(Matrix%MatC(I,J)) - Real(Matrix%MatC(J,I))).gt.Thresh) .or. &
                    (abs(Aimag(Matrix%MatC(I,J)) + Aimag(Matrix%MatC(J,I))).gt.Thresh)) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                       'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          Else
            Call MQC_Error_A('Matrix type not identified in MQC_Matrix_Test_Symmetric', 6, &
                 'Matrix%Storage', Matrix%Storage )
          EndIf
        EndIf
      Case ('antihermitian')
        If(MQC_Matrix_Rows(Matrix).ne.MQC_Matrix_Columns(Matrix)) then
          Symmetric = .False.
        Else
          If(myMath) then
            If (MQC_Vector_Norm(real(Matrix%diagonal())).gt.Thresh) then
              Symmetric = .False.
              Return
            EndIf
          EndIf
          If(Matrix%Storage.eq.'StorDiag') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                If(Matrix%MatI(I,1).ne.0) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Real') then
                If(abs(Matrix%MatR(I,1)).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Complex') then
                If(abs(Real(Matrix%MatC(I,1))).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorSymm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I
                If(Matrix%Data_Type.eq.'Integer') then
                  If(Matrix%MatI(symIndexHash(I,J),1).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If(abs(Matrix%MatR(symIndexHash(I,J),1)).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If(abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                Else
                  Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                       'Matrix%Data_Type', Matrix%Data_Type )
                EndIf
              EndDo
            EndDo
          ElseIf(Matrix%Storage.eq.'StorAsym') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                If(Matrix%MatI(symIndexHash(I,I),1).ne.0) then
                  Symmetric = .False.
                  Return
                EndIf
              elseIf(Matrix%Data_Type.eq.'Real') then
                If(abs(Matrix%MatR(symIndexHash(I,I),1)).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              elseIf(Matrix%Data_Type.eq.'Complex') then
                If(abs(Real(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
                Do J = 1, I-1
                  If(abs(Aimag(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorHerm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                Do J = 1, I
                  K = symIndexHash(I,J)
                  If(Matrix%MatI(K,1).ne.0) then
                    Symmetric = .False.
                    return
                  EndIf
                EndDo
              ElseIf(Matrix%Data_Type.eq.'Real') then
                Do J = 1, I
                  K = symIndexHash(I,J)
                  If(abs(Matrix%MatR(K,1)).gt.Thresh) then
                    Symmetric = .False.
                    return
                  EndIf
                EndDo
              ElseIf(Matrix%Data_Type.eq.'Complex') then
                If(abs(Real(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
                Do J = 1, I-1
                  If((abs(Real(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh) .or. &
                    (abs(Aimag(Matrix%MatC(symIndexHash(I,J),1))).gt.Thresh)) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndDo
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorAhrm') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              If(Matrix%Data_Type.eq.'Integer') then
                If(Matrix%MatI(symIndexHash(I,I),1).ne.0) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Real') then
                If(abs(Matrix%MatR(symIndexHash(I,I),1)).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              ElseIf(Matrix%Data_Type.eq.'Complex') then
                If(abs(Real(Matrix%MatC(symIndexHash(I,I),1))).gt.Thresh) then
                  Symmetric = .False.
                  Return
                EndIf
              Else
                Call MQC_Error_A('Unrecognised data type in mqc_matrix_test_symmetric', 6, &
                     'Matrix%Data_Type', Matrix%Data_Type )
              EndIf
            EndDo
          ElseIf(Matrix%Storage.eq.'StorFull') then
            Do I = 1, MQC_Matrix_Rows(Matrix)
              Do J = 1, I-1
                If(Matrix%Data_Type.eq.'Integer') then
                  If((Matrix%MatI(I,J) + Matrix%MatI(J,I)).ne.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Real') then
                  If((Matrix%MatR(I,J) + Matrix%MatR(J,I)).ne.0.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                elseIf(Matrix%Data_Type.eq.'Complex') then
                  If((Real(Matrix%MatC(I,J)) + Real(Matrix%MatC(J,I))).ne.0.0 .or. &
                    (Aimag(Matrix%MatC(I,J)) - Aimag(Matrix%MatC(J,I))).ne.0.0) then
                    Symmetric = .False.
                    Return
                  EndIf
                EndIf
              EndDo
            EndDo
          Else
            Call MQC_Error_A('Matrix type not identified in MQC_Matrix_Test_Symmetric', 6, &
                 'Matrix%Storage', Matrix%Storage)

!            Call MQC_Error('Matrix type not identified in MQC_Matrix_Test_Symmetric')
          EndIf
        EndIf
      Case ('any')
        if(mqc_matrix_test_symmetric(matrix,'symmetric',myMath).or. &
          mqc_matrix_test_symmetric(matrix,'antisymmetric',myMath).or. &
          mqc_matrix_test_symmetric(matrix,'hermitian',myMath).or. &
          mqc_matrix_test_symmetric(matrix,'antihermitian',myMath)) then
          return
        else
          Symmetric = .False.
          return
        endIf
      Case Default
        Call MQC_Error_A('Invalid option sent to mqc_matrix_test_symmetric', 6, &
             'myOption', myOption )
      End Select

      Return
      End Function MQC_Matrix_Test_Symmetric
!
!
!     PROCEDURE MQC_Matrix_Test_Diagonal
!
!>    \brief <b> MQC_Matrix_Test_Diagonal is a function that tests a MQC matrix to
!>    determine if it is diagonal</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Test_Diagonal is a function that tests a MQC matrix to determine 
!>    if it is diagonal. The function returns TRUE if the matrix is diagonal and 
!>    FALSE if the matrix is not diagonal.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Class(mqc_matrix)
!>        The matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_Test_Diagonal(Matrix) Result(Diagonal)
!
      Implicit None
      Class(MQC_Matrix),Intent(In)::Matrix
      Logical::Diagonal
      Integer(kind=int64)::I,J,II
      Real(kind=real64)::Thresh=1e-14

      Diagonal = .True.
      If(Matrix%Storage.eq.'StorDiag') then
        Return
      ElseIf(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorAsym'.or.&
          Matrix%Storage.eq.'StorHerm'.or.Matrix%Storage.eq.'StorAhrm') then
        Do I = 1, MQC_Matrix_Rows(Matrix)
          II = (I*(I-1))/2
          Do J = 1, I-1
            If(Matrix%Data_Type.eq.'Integer') then
              If(Matrix%MatI(II+J,1).ne.0) then
                Diagonal = .False.
                Return
              EndIf
            ElseIf(Matrix%Data_Type.eq.'Real') then
              If(abs(Matrix%MatR(II+J,1)).gt.Thresh) then
                Diagonal = .False.
                Return
              EndIf
            ElseIf(Matrix%Data_Type.eq.'Complex') then 
              If(abs(Real(Matrix%MatC(II+J,1))).gt.Thresh.or. &
                abs(Aimag(Matrix%MatC(II+J,1))).gt.Thresh) then
                Diagonal = .False.
                Return
              EndIf
            EndIf
          EndDo
        EndDo
      ElseIf(Matrix%Storage.eq.'StorFull') then
        Do I = 1, MQC_Matrix_Rows(Matrix)
          Do J = 1 , MQC_Matrix_Columns(Matrix)
            If(I.eq.J) cycle
            If(Matrix%Data_Type.eq.'Integer') then
              If(Matrix%MatI(I,J).ne.0) then
                Diagonal = .False.
                Return
              EndIf
            ElseIf(Matrix%Data_Type.eq.'Real') then
              If(abs(Matrix%MatR(I,J)).gt.Thresh) then
                Diagonal = .False.
                Return
              EndIf
            ElseIf(Matrix%Data_Type.eq.'Complex') then 
              If(abs(Real(Matrix%MatC(I,J))).gt.Thresh.or.&
                abs(Aimag(Matrix%MatC(I,J))).gt.Thresh) then
                Diagonal = .False.
                Return
              EndIf
            EndIf
          EndDo
        EndDo
      Else
        Call MQC_Error_A('Matrix type not identified in MQC_Matrix_Test_Diagonal', 6, &
             'Matrix%Storage', Matrix%Storage )
      EndIf

      Return
      End Function MQC_Matrix_Test_Diagonal
!
!
!     PROCEDURE MQC_Allocate_Matrix
!
!>    \brief <b> MQC_Allocate_Matrix is used to allocate a matrix type variable
!>    of the MQC_Matrix class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Allocate_Matrix is a subroutine used to allocate a matrix type variable
!>    of the MQC_Matrix class. The following options are available:
!>
!>    1. Data_Type = 'Real' declares the MQC_Matrix variable to be of real type. 
!>    2. Data_Type = 'Integer' declares the MQC_Matrix variable to be of integer type.
!>    3. Data_Type = 'Complex' declares the MQC_Matrix variable to be of complex type.
!>    4. Storage = 'StorFull' declares the MQC_Matrix variable to be unpacked.
!>    5. Storage = 'StorSymm' declares the MQC_Matrix variable to be symmetric packed.
!>    5. Storage = 'StorAsym' declares the MQC_Matrix variable to be antisymmetric packed.
!>    5. Storage = 'StorHerm' declares the MQC_Matrix variable to be hermitian packed.
!>    5. Storage = 'StorAhrm' declares the MQC_Matrix variable to be antihermitian packed.
!>    6. Storage = 'StorDiag' declares the MQC_Matrix variable to be diagonal packed.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] M
!>    \verbatim
!>        M is Integer(kind=int64)
!>        M is the number of rows of Matrix. 
!>    \endverbatim
!>    
!>    \param[in] N
!>    \verbatim
!>        N is Integer(kind=int64)
!>        N is the number of columns of Matrix.
!>    \endverbatim
!>    
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix to be allocated.
!>    \endverbatim
!>
!>    \param[in] Data_Type
!>    \verbatim
!>        Data_Type is Character(Len=*)
!>        = 'Real':    the MQC_Matrix is real
!>        = 'Integer': the MQC_Matrix is integer
!>        = 'Complex': the MQC_Matrix is complex.
!>    \endverbatim
!>
!>    \param[in] Storage  
!>    \verbatim
!>        Storage is Character(Len=*)
!>        = 'StorFull': the MQC_Matrix is unpacked
!>        = 'StorSymm': the MQC_Matrix is symmetric packed
!>        = 'StorAsym': the MQC_Matrix is antisymmetric packed
!>        = 'StorHerm': the MQC_Matrix is hermitian packed
!>        = 'StorAhrm': the MQC_Matrix is antihermitian packed
!>        = 'StorDiag': the MQC_Matrix is diagonal packed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Allocate_Matrix(M,N,Matrix,Data_Type,Storage)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::M,N
      Class(MQC_Matrix),Intent(InOut)::Matrix
      Character(Len=*),Intent(In)::Data_Type,Storage
      Integer(kind=int64)::MCur,NCur
      character(len=64)::mystorage
!
      call string_change_case(storage,'l',myStorage)

      If (M.lt.0 .or. N.lt.0) then
        Call MQC_Error_I('Dimensions less than zero in MQC_Allocate_Matrix', 6, &
             'M', M, &
             'N', N )
      EndIf

      Call MQC_Deallocate_Matrix(Matrix)

      If(myStorage.eq.'full' .or. myStorage.eq.'storfull') then
        Matrix%Storage = 'StorFull'
        MCur = M
        NCur = N
      ElseIf(myStorage.eq.'symm' .or. myStorage.eq.'storsymm') then
         If(M.ne.N) Call MQC_Error_I('Attempting to assign non-square matrix to lower &
           & triangular in MQC_Allocate_Matrix', 6, 'M', M, 'N', N )
        Matrix%Storage = 'StorSymm'
        MCur = (M*(M+1))/2
        NCur = 1
      ElseIf(myStorage.eq.'asym' .or. myStorage.eq.'storasym') then
         If(M.ne.N) Call MQC_Error_I('Attempting to assign non-square matrix to lower &
           & triangular in MQC_Allocate_Matrix', 6, 'M', M, 'N', N )
        Matrix%Storage = 'StorAsym'
        MCur = (M*(M+1))/2
        NCur = 1
      ElseIf(myStorage.eq.'herm' .or. myStorage.eq.'storherm') then
         If(M.ne.N) Call MQC_Error_I('Attempting to assign non-square matrix to lower &
           & triangular in MQC_Allocate_Matrix', 6, 'M', M, 'N', N )
        Matrix%Storage = 'StorHerm'
        MCur = (M*(M+1))/2
        NCur = 1
      ElseIf(myStorage.eq.'ahrm' .or. myStorage.eq.'storahrm') then
         If(M.ne.N) Call MQC_Error_I('Attempting to assign non-square matrix to lower &
           & triangular in MQC_Allocate_Matrix', 6, 'M', M, 'N', N )
        Matrix%Storage = 'StorAhrm'
        MCur = (M*(M+1))/2
        NCur = 1
      ElseIf(myStorage.eq.'diag' .or. myStorage.eq.'stordiag') then
        Matrix%Storage = 'StorDiag'
        MCur = Min(M,N)
        NCur = 1
      ElseIf(myStorage.eq.'trid' .or. myStorage.eq.'stortrid') then
        Matrix%Storage = 'StorTriD'
        If(M.ne.N) then
          MCur = 3*Min(M,N)-1
        Else
          MCur = 3*N-2
        EndIf
        NCur = 1
      Else
        Call MQC_Error_A('Storage type not recognised in MQC_Allocate_Matrix', 6, &
             'Storage', Storage )
      EndIf

      If(Data_Type.eq.'Integer' .or. Data_Type.eq.'integer' .or. Data_Type.eq.'Int' .or. Data_Type.eq.'int') then
        Matrix%Data_Type = 'Integer'
        If(Allocated(Matrix%MatI)) DeAllocate(Matrix%MatI)
        Allocate(Matrix%MatI(MCur,NCur))
      ElseIf(Data_Type.eq.'Real' .or. Data_Type.eq.'real') then
        Matrix%Data_Type = 'Real'
        If(Allocated(Matrix%MatR)) DeAllocate(Matrix%MatR)
        Allocate(Matrix%MatR(MCur,NCur))
      ElseIf(Data_Type.eq.'Complex' .or. Data_Type.eq.'complex') then
        Matrix%Data_Type = 'Complex'
        If(Allocated(Matrix%MatC)) DeAllocate(Matrix%MatC)
        Allocate(Matrix%MatC(MCur,NCur))
      EndIf

      Matrix%NRow = M
      Matrix%NCol = N
!
      Return
      End Subroutine MQC_Allocate_Matrix
!
!
!     PROCEDURE MQC_Deallocate_Matrix
!
!>    \brief <b> MQC_Deallocate_Matrix is used to deallocate a matrix type variable
!>    of the MQC_Matrix class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Deallocate_Matrix is a subroutine used to deallocate a matrix type variable
!>    of the MQC_Matrix class. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix to be deallocated.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Deallocate_Matrix(Matrix)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Matrix),Intent(InOut)::Matrix
!
      If(Allocated(Matrix%MatI)) DeAllocate(Matrix%MatI)
      If(Allocated(Matrix%MatR)) DeAllocate(Matrix%MatR)
      If(Allocated(Matrix%MatC)) DeAllocate(Matrix%MatC)
      If(.not.Allocated(Matrix%MatR).and..not.Allocated(Matrix%MatI).and..not.Allocated(Matrix%MatC)) then
        Matrix%NCol = 0
        Matrix%NRow = 0
        Matrix%Data_Type = ''
        Matrix%Storage = ''
      EndIf
!
      Return
      End Subroutine MQC_Deallocate_Matrix
!
!
!     PROCEDURE MQC_Matrix_isAllocated
!
!>    \brief <b> MQC_Matrix_isAllocate is a function that returns the allocation
!>    status of a MQC_Matrix variable</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_isAllocate is a function that returns the allocation status of a 
!>    MQC_Matrix variable. The function returns TRUE if the matrix is allocated 
!>    and FALSE if the matrix is not allocated.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_isAllocated(Matrix) Result(isAllocated)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Matrix),Intent(In)::Matrix
      Logical::isAllocated
!
      isAllocated = .False.
      If(Allocated(Matrix%MatR)) isAllocated = .True.
      If(Allocated(Matrix%MatI)) isAllocated = .True.
      If(Allocated(Matrix%MatC)) isAllocated = .True.
!
      Return
      End Function MQC_Matrix_isAllocated
!
!
!     PROCEDURE MQC_Set_IntegerArray2Matrix
!
!>    \brief <b> MQC_Set_IntegerArray2Matrix is a subroutine that sets an MQC matrix
!>    equal to an intrinsic integer rank-2 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_IntegerArray2Matrix is a subroutine that sets an MQC matrix equal to an
!>    intrinsic integer rank-2 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] MatrixOut
!>    \verbatim
!>        MatrixOut is Type(MQC_Matrix)
!>        The MQC matrix to be set equal to the integer array.
!>    \endverbatim
!>
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayIn is Integer(kind=int64),Dimension(:,:)
!>        The integer array to be input into MatrixOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Set_IntegerArray2Matrix(MatrixOut,ArrayIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::MatrixOut
      Integer(kind=int64),Dimension(:,:),Intent(In)::ArrayIn
!
      Call MQC_Deallocate_Matrix(MatrixOut)
      Call MQC_Allocate_Matrix(Size(ArrayIn,1),Size(ArrayIn,2),MatrixOut,'Integer', &
            'StorFull')
      MatrixOut%MatI = ArrayIn
      if(MQC_Matrix_Test_Diagonal(MatrixOut)) then
        call MQC_Matrix_Full2Diag(MatrixOut)
      elseIf(MQC_Matrix_Test_Symmetric(MatrixOut)) then
        call MQC_Matrix_Full2Symm(MatrixOut)
      endIf
!
      Return
      End Subroutine MQC_Set_IntegerArray2Matrix
!
!
!     PROCEDURE MQC_Set_RealArray2Matrix
!
!>    \brief <b> MQC_Set_RealArray2Matrix is a subroutine that sets an MQC matrix
!>    equal to an intrinsic real rank-2 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_RealArray2Matrix is a subroutine that sets an MQC matrix equal to an
!>    intrinsic real rank-2 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] MatrixOut
!>    \verbatim
!>        MatrixOut is Type(MQC_Matrix)
!>        The MQC matrix to be set equal to the real array.
!>    \endverbatim
!>
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayIn is Real(kind=real64),Dimension(:,:)
!>        The real array to be input into MatrixOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Set_RealArray2Matrix(MatrixOut,ArrayIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::MatrixOut
      Real(kind=real64),Dimension(:,:),Intent(In)::ArrayIn
!
      Call MQC_Deallocate_Matrix(MatrixOut)
      Call MQC_Allocate_Matrix(Size(ArrayIn,1),Size(ArrayIn,2),MatrixOut,'Real', &
        'StorFull')
      MatrixOut%MatR = ArrayIn
      if(MQC_Matrix_Test_Diagonal(MatrixOut)) then
        call MQC_Matrix_Full2Diag(MatrixOut)
      elseIf(MQC_Matrix_Test_Symmetric(MatrixOut)) then
        call MQC_Matrix_Full2Symm(MatrixOut)
      endIf
!
      Return
      End Subroutine MQC_Set_RealArray2Matrix
!
!
!     PROCEDURE MQC_Set_ComplexArray2Matrix
!
!>    \brief <b> MQC_Set_ComplexArray2Matrix is a subroutine that sets an MQC matrix
!>    equal to an intrinsic complex rank-2 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_ComplexArray2Matrix is a subroutine that sets an MQC matrix equal to an
!>    intrinsic complex rank-2 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] MatrixOut
!>    \verbatim
!>        MatrixOut is Type(MQC_Matrix)
!>        The MQC matrix to be set equal to the complex array.
!>    \endverbatim
!>
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayIn is Complex(kind=real64),Dimension(:,:)
!>        The complex array to be input into MatrixOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Set_ComplexArray2Matrix(MatrixOut,ArrayIn)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::MatrixOut
      Complex(Kind=real64),Dimension(:,:),Intent(In)::ArrayIn
!
      Call MQC_Deallocate_Matrix(MatrixOut)
      Call MQC_Allocate_Matrix(Size(ArrayIn,1),Size(ArrayIn,2),MatrixOut,'Complex', &
        'StorFull')
      MatrixOut%MatC = ArrayIn
      if(MQC_Matrix_Test_Diagonal(MatrixOut)) then
        call MQC_Matrix_Full2Diag(MatrixOut)
      elseIf(MQC_Matrix_Test_Symmetric(MatrixOut)) then
        call MQC_Matrix_Full2Symm(MatrixOut)
      endIf
!
      Return
      End Subroutine MQC_Set_ComplexArray2Matrix
!
!
!     PROCEDURE MQC_Set_Matrix2IntegerArray
!
!>    \brief <b> MQC_Set_Matrix2IntegerArray is a subroutine that sets an intrinsic 
!>    integer rank-2 array equal to an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_Matrix2IntegerArray is a subroutine that sets an intrinsic integer 
!>    rank-2 array equal to an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Integer(kind=int64),Dimension(:,:),Allocatable
!>        The integer array to be set equal to the MQC matrix.
!>    \endverbatim
!>
!>    \param[in] MatrixIn 
!>    \verbatim
!>        MatrixIn is Type(MQC_Matrix)
!>        The MQC matrix to be input into ArrayOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Set_Matrix2IntegerArray(ArrayOut,MatrixIn)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Dimension(:,:),Allocatable,Intent(InOut)::ArrayOut
      Type(MQC_Matrix),Intent(In)::MatrixIn
      Integer(kind=int64)::ColsMatIn,RowsMatIn,I,J
!
!     Need to have a way of determining output based on matrix packing which
!     depends on type of array in as well ( here assuming full).
!     Need to have a way of dealing with row vs column-wise arrays (here
!     assuming cols).
!
      RowsMatIn = MQC_Matrix_Rows(MatrixIn)
      If(MatrixIn%Storage.eq.'StorFull') then
        ColsMatIn = MQC_Matrix_Columns(MatrixIn)
      ElseIf(MatrixIn%Storage.eq.'StorTriD') then
        If(MQC_Matrix_Columns(MatrixIn).ne.RowsMatIn) then
          ColsMatIn = 3*Min(MQC_Matrix_Columns(MatrixIn),RowsMatIn)-1
        Else
          ColsMatIn = 3*RowsMatIn-2
        EndIf ! Xianghai: Is this the right dimensions for triD?
      Elseif (MatrixIn%Storage.eq.'StorSymm' .or. MatrixIn%Storage.eq.'StorAsym' .or. &
          MatrixIn%Storage.eq.'StorHerm'.or. MatrixIn%Storage.eq.'StorAhrm' .or. &
          MatrixIn%Storage.eq.'StorDiag') then
        ColsMatIn = 1
      Else
        Call MQC_Error_A('MatrixIn storage type unkown in MQC_Matrix2Array', 6, &
             'MatrixIn%Storage', MatrixIn%Storage )
      EndIf
!
      If(.not.Allocated(ArrayOut)) then
        Allocate(ArrayOut(RowsMatIn,ColsMatIn))
      ElseIf(RowsMatIn.ne.Size(ArrayOut,1).or.ColsMatIn.ne.Size(ArrayOut,2)) then
        Deallocate(ArrayOut)
        Allocate(ArrayOut(RowsMatIn,ColsMatIn))
      EndIf

      If(MatrixIn%Data_Type.eq.'Integer') then
        ArrayOut = MatrixIn%MatI
      ElseIf(MatrixIn%Data_Type.eq.'Real') then
        ArrayOut = MatrixIn%MatR
      ElseIf(MatrixIn%Data_Type.eq.'Complex') then
        ArrayOut = MatrixIn%MatC
      Else
        Call MQC_Error_A('MatrixIn type unkown in MQC_Matrix2Array', 6, &
             'MatrixIn%Data_Type', MatrixIn%Data_Type )
      EndIf
!
      Return
      End Subroutine MQC_Set_Matrix2IntegerArray
!
!
!     PROCEDURE MQC_Set_Matrix2RealArray
!
!>    \brief <b> MQC_Set_Matrix2RealArray is a subroutine that sets an intrinsic 
!>    real rank-2 array equal to an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_Matrix2RealArray is a subroutine that sets an intrinsic real rank-2 
!>    array equal to an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Real(kind=real64),Dimension(:,:),Allocatable
!>        The real array to be set equal to the MQC matrix.
!>    \endverbatim
!>
!>    \param[in] MatrixIn 
!>    \verbatim
!>        MatrixIn is Type(MQC_Matrix)
!>        The MQC matrix to be input into ArrayOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Set_Matrix2RealArray(ArrayOut,MatrixIn)
!
!     Variable Declarations.
      Implicit None
      Real(kind=real64),Dimension(:,:),Allocatable,Intent(InOut)::ArrayOut
      Type(MQC_Matrix),Intent(In)::MatrixIn
      Integer(kind=int64)::ColsMatIn,RowsMatIn,I,J
!
!     Need to have a way of determining output based on matrix packing which
!     depends on type of array in as well ( here assuming full).
!     Need to have a way of dealing with row vs column-wise arrays (here
!     assuming cols).
!
      RowsMatIn = MQC_Matrix_Rows(MatrixIn)
      If(MatrixIn%Storage.eq.'StorFull') then
        ColsMatIn = MQC_Matrix_Columns(MatrixIn)
      ElseIf(MatrixIn%Storage.eq.'StorTriD') then
        If(MQC_Matrix_Columns(MatrixIn).ne.RowsMatIn) then
          ColsMatIn = 3*Min(MQC_Matrix_Columns(MatrixIn),RowsMatIn)-1
        Else
          ColsMatIn = 3*RowsMatIn-2
        EndIf ! Xianghai: Is this the right dimensions for triD?
      Elseif (MatrixIn%Storage.eq.'StorSymm' .or. MatrixIn%Storage.eq.'StorAsym' .or. &
          MatrixIn%Storage.eq.'StorHerm'.or. MatrixIn%Storage.eq.'StorAhrm' .or. &
          MatrixIn%Storage.eq.'StorDiag') then
        ColsMatIn = 1
      Else
        Call MQC_Error_A('MatrixIn storage type unkown in MQC_Matrix2Array', 6, &
             'MatrixIn%Storage', MatrixIn%Storage )
      EndIf
!
      If(.not.Allocated(ArrayOut)) then
        Allocate(ArrayOut(RowsMatIn,ColsMatIn))
      ElseIf(RowsMatIn.ne.Size(ArrayOut,1).or.ColsMatIn.ne.Size(ArrayOut,2)) then
        Deallocate(ArrayOut)
        Allocate(ArrayOut(RowsMatIn,ColsMatIn))
      EndIf

      If(RowsMatIn.gt.0.and.ColsMatIn.gt.0) then
        If(MatrixIn%Data_Type.eq.'Integer') then
          ArrayOut = MatrixIn%MatI
        ElseIf(MatrixIn%Data_Type.eq.'Real') then
          ArrayOut = MatrixIn%MatR
        ElseIf(MatrixIn%Data_Type.eq.'Complex') then
          ArrayOut = MatrixIn%MatC
        Else
          Call MQC_Error_A('MatrixIn type unkown in MQC_Matrix2Array', 6, &
               'MatrixIn%Data_Type', MatrixIn%Data_Type )
        EndIf
      EndIf
!
      Return
      End Subroutine MQC_Set_Matrix2RealArray
!
!
!     PROCEDURE MQC_Set_Matrix2ComplexArray
!
!>    \brief <b> MQC_Set_Matrix2ComplexArray is a subroutine that sets an intrinsic 
!>    complex rank-2 array equal to an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_Matrix2ComplexArray is a subroutine that sets an intrinsic complex 
!>    rank-2 array equal to an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Complex(kind=real64),Dimension(:,:),Allocatable
!>        The complex array to be set equal to the MQC matrix.
!>    \endverbatim
!>
!>    \param[in] MatrixIn 
!>    \verbatim
!>        MatrixIn is Type(MQC_Matrix)
!>        The MQC matrix to be input into ArrayOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Set_Matrix2ComplexArray(ArrayOut,MatrixIn)
!
!     Variable Declarations.
      Implicit None
      Complex(Kind=real64),Dimension(:,:),Allocatable,Intent(InOut)::ArrayOut
      Type(MQC_Matrix),Intent(In)::MatrixIn
      Integer(kind=int64)::ColsMatIn,RowsMatIn,I,J
!
!     Need to have a way of determining output based on matrix packing which
!     depends on type of array in as well ( here assuming full).
!     Need to have a way of dealing with row vs column-wise arrays (here
!     assuming cols).
!
      RowsMatIn = MQC_Matrix_Rows(MatrixIn)
      If(MatrixIn%Storage.eq.'StorFull') then
        ColsMatIn = MQC_Matrix_Columns(MatrixIn)
      ElseIf(MatrixIn%Storage.eq.'StorTriD') then
        If(MQC_Matrix_Columns(MatrixIn).ne.RowsMatIn) then
          ColsMatIn = 3*Min(MQC_Matrix_Columns(MatrixIn),RowsMatIn)-1
        Else
          ColsMatIn = 3*RowsMatIn-2
        EndIf ! Xianghai: Is this the right dimensions for triD?
      Elseif (MatrixIn%Storage.eq.'StorSymm' .or. MatrixIn%Storage.eq.'StorAsym' .or. &
          MatrixIn%Storage.eq.'StorHerm'.or. MatrixIn%Storage.eq.'StorAhrm' .or. &
          MatrixIn%Storage.eq.'StorDiag') then
        ColsMatIn = 1
      Else
        Call MQC_Error_A('MatrixIn storage type unkown in MQC_Matrix2Array', 6, &
             'MatrixIn%Storage', MatrixIn%Storage )
      EndIf
!
      If(.not.Allocated(ArrayOut)) then
        Allocate(ArrayOut(RowsMatIn,ColsMatIn))
      ElseIf(RowsMatIn.ne.Size(ArrayOut,1).or.ColsMatIn.ne.Size(ArrayOut,2)) then
        Deallocate(ArrayOut)
        Allocate(ArrayOut(RowsMatIn,ColsMatIn))
      EndIf

      If(RowsMatIn.gt.0.and.ColsMatIn.gt.0) then
        If(MatrixIn%Data_Type.eq.'Integer') then
          ArrayOut = MatrixIn%MatI
        ElseIf(MatrixIn%Data_Type.eq.'Real') then
          ArrayOut = MatrixIn%MatR
        ElseIf(MatrixIn%Data_Type.eq.'Complex') then
          ArrayOut = MatrixIn%MatC
        Else
          Call MQC_Error_A('MatrixIn type unkown in MQC_Matrix2Array', 6, &
               'MatrixIn%Data_Type', MatrixIn%Data_Type )
        EndIf
      EndIf
!
      Return
      End Subroutine MQC_Set_Matrix2ComplexArray
!
!
!     PROCEDURE MQC_Set_Matrix2Matrix
!
!>    \brief <b> MQC_Set_Matrix2Matrix is a subroutine that sets an MQC matrix equal
!>    to another MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_Matrix2Matrix is a subroutine that sets an MQC matrix equal to another 
!>    MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] MatrixOut
!>    \verbatim
!>        MatrixOut is Class(MQC_Matrix)
!>        The MQC matrix to be set equal to the incoming MQC 
!>        matrix.
!>    \endverbatim
!>
!>    \param[in] MatrixIn 
!>    \verbatim
!>        MatrixIn is Class(MQC_Matrix)
!>        The MQC matrix to be input into MatrixOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Set_Matrix2Matrix(MatrixOut,MatrixIn)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_Matrix),Intent(InOut)::MatrixOut
      Class(MQC_Matrix),Intent(In)::MatrixIn
!
      Call MQC_Deallocate_Matrix(MatrixOut)
      If(MQC_Matrix_HaveReal(MatrixIn)) then
        Call MQC_Allocate_Matrix(MQC_Matrix_Rows(MatrixIn),MQC_Matrix_Columns(MatrixIn), &
          MatrixOut,'Real',MatrixIn%Storage)
        MatrixOut%MatR = MatrixIn%MatR
      EndIf
      If(MQC_Matrix_HaveInteger(MatrixIn)) then
        Call MQC_Allocate_Matrix(MQC_Matrix_Rows(MatrixIn),MQC_Matrix_Columns(MatrixIn), &
          MatrixOut,'Integer',MatrixIn%Storage)
        MatrixOut%MatI = MatrixIn%MatI
      EndIf
      If(MQC_Matrix_HaveComplex(MatrixIn)) then
        Call MQC_Allocate_Matrix(MQC_Matrix_Rows(MatrixIn),MQC_Matrix_Columns(MatrixIn), &
          MatrixOut,'Complex',MatrixIn%Storage)
        MatrixOut%MatC = MatrixIn%MatC
      EndIf
!
      !MatrixOut%Column = MatrixIn%Column
!
      Return
      End Subroutine MQC_Set_Matrix2Matrix
!
!
!     PROCEDURE MQC_Print_Matrix_Algebra1
!
!>    \brief <b> MQC_Print_Matrix_Algebra1 is a subroutine used to print an MQC
!>    matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Print_Matrix_Algebra1 is a subroutine used to print an MQC matrix. 
!>    Blank_At_Top and Blank_At_Bottom are optional logical arguments to print blank
!>    lines before or after output.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The variable to be printed.
!>    \endverbatim
!>
!>    \param[in] IOut
!>    \verbatim
!>        IOut is Integer(kind=int64) 
!>        The Fortran file number to print to. 
!>    \endverbatim
!>
!>    \param[in] Header
!>    \verbatim
!>        Header is Character(Len=*)
!>        The title to print along with Matrix.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Top
!>    \verbatim
!>        Blank_At_Top is Logical,Optional
!>        = .True.:  print blank line above output
!>        = .False.: do not print blank line above output.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Bottom
!>    \verbatim
!>        Blank_At_Bottom is Logical,Optional
!>        = .True.:  print blank line below output
!>        = .False.: do not print blank line below output.
!>    \endverbatim
!>
!>    \param[in] FormatStr
!>    \verbatim
!>        FormatStr is Character(Len=*),Optional
!>        Formatting statement for printing.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Print_Matrix_Algebra1(Matrix,IOut,Header,Blank_At_Top, &
        Blank_At_Bottom,FormatStr)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64),Intent(In)::IOut
      Class(MQC_Matrix),Intent(In)::Matrix
      Character(Len=*),Intent(In)::Header
      Logical,Intent(In),Optional::Blank_At_Top,Blank_At_Bottom
      Integer(kind=int64)::I,J,II,ILim,NCols,NRows,IFirst,ILast
      Character(Len=*),Intent(In),Optional::FormatStr
      Integer(kind=int64),Parameter::ColWidth=10 
      Character(Len=256)::FormatLine
!
 1000 Format(1x,A)
 1001 Format(5x,10(7x,I7))
 1002 Format(3x,'This is a diagonal matrix, so only diagonal elements are printed')
 1003 Format(10(17x,I7))
 1020 Format( " " )
 1030 Format(3x,A)
 2001 Format(1x,I7,10I14)
 2002 Format(1x,I7,10F14.6)
 2003 Format(1x,I7,10(F12.5,F11.5,"i"))
!
!     Output will depend on matrix packing type (assumed full) or column/row
      NCols = MQC_Matrix_Columns(Matrix)
      NRows = MQC_Matrix_Rows(Matrix)

      If(PRESENT(Blank_At_Top)) then
        If(Blank_At_Top) Write(IOut,1020)
      EndIf
      Write(IOut,1000) TRIM(Header)

!     Printing for full storage
      If(Matrix%Storage.eq.'StorFull') then
        Do IFirst = 1,NCols,ColWidth
          ILast = Min(IFirst+ColWidth-1,NCols)
          If(Matrix%Data_Type.eq.'Complex') then
            Write(IOut,1003) (I,I=IFirst,ILast)
          Else
            Write(IOut,1001) (I,I=IFirst,ILast)
          EndIf
          Do I = 1,NRows
            If(Matrix%Data_Type.eq.'Integer') then
              If(present(FormatStr)) then
                FormatLine = '(1x,I7,2x,10'//trim(FormatStr)//')'
                Write(IOut,trim(FormatLine)) I, (Matrix%MatI(I,J),J=IFirst,ILast)
              Else
                Write(IOut,2001) I, (Matrix%MatI(I,J),J=IFirst,ILast)
              EndIf
            ElseIf(Matrix%Data_Type.eq.'Real') then
              If(present(FormatStr)) then
                FormatLine = '(1x,I7,2x,10'//trim(FormatStr)//')'
                Write(IOut,trim(FormatLine)) I, (Matrix%MatR(I,J),J=IFirst,ILast)
              else
                Write(IOut,2002) I, (Matrix%MatR(I,J),J=IFirst,ILast)
              endIf
            ElseIf(Matrix%Data_Type.eq.'Complex') then
              If(present(FormatStr)) then
                FormatLine = '(1x,I7,2x,10('//trim(FormatStr)//','//trim(FormatStr)//',"i"))'
                Write(IOut,trim(FormatLine)) I, (Matrix%MatC(I,J),J=IFirst,ILast)
              else
                Write(IOut,2003) I, (Matrix%MatC(I,J),J=IFirst,ILast)
              endIf
            Else
              Call MQC_Error_A('Matrix data type unspecified in MQC_Print_Matrix_Algebra1', 6, &
                 'Matrix%Data_Type', Matrix%Data_Type )
            EndIf
          EndDo
        EndDo

!     Printing for Symm storage
      ElseIf(Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorAsym' .or. &
          Matrix%Storage.eq.'StorHerm' .or. Matrix%Storage.eq.'StorAhrm') then
        If(Matrix%Storage.eq.'StorSymm') write(IOut,1030) 'The matrix being printed is symmetric'
        If(Matrix%Storage.eq.'StorAsym') write(IOut,1030) 'The matrix being printed is antisymmetric'
        If(Matrix%Storage.eq.'StorHerm') write(IOut,1030) 'The matrix being printed is hermitian'
        If(Matrix%Storage.eq.'StorAhrm') write(IOut,1030) 'The matrix being printed is anithermitian'
        Do IFirst = 1,NCols,ColWidth
          ILast = Min(IFirst+ColWidth-1,NCols)
          If(Matrix%Data_Type.eq.'Complex') then
            Write(IOut,1003) (I,I=IFirst,ILast)
          Else
            Write(IOut,1001) (I,I=IFirst,ILast)
          EndIf
          Do I = 1,NRows
            If(IFirst.gt.I) Cycle
            ILim = Min(I-IFirst+1,ColWidth)
            II = (I*(I-1))/2 + IFirst
            If(Matrix%Data_Type.eq.'Integer') then
              If(present(FormatStr)) then
                FormatLine = '(1x,I7,2x,10'//trim(FormatStr)//')'
                Write(IOut,trim(FormatLine)) I, (Matrix%MatI(II+J-1,1),J=1,ILim)
              Else
                Write(IOut,2001) I, (Matrix%MatI(II+J-1,1),J=1,ILim)
              EndIf
            ElseIf(Matrix%Data_Type.eq.'Real') then
              If(present(FormatStr)) then
                FormatLine = '(1x,I7,2x,10'//trim(FormatStr)//')'
                Write(IOut,trim(FormatLine)) I, (Matrix%MatR(II+J-1,1),J=1,ILim)
              Else
                Write(IOut,2002) I, (Matrix%MatR(II+J-1,1),J=1,ILim)
              EndIf
            ElseIf(Matrix%Data_Type.eq.'Complex') then
              If(present(FormatStr)) then
                FormatLine = '(1x,I7,2x,10('//trim(FormatStr)//','//trim(FormatStr)//',"i"))'
                Write(IOut,trim(FormatLine)) I, (Matrix%MatC(II+J-1,1),J=1,ILim)
              Else
                Write(IOut,2003) I, (Matrix%MatC(II+J-1,1),J=1,ILim)
              EndIf
            Else
              Call MQC_Error_A('Matrix data type unspecified in MQC_Print_Matrix_Algebra1', 6, &
                 'Matrix%Data_Type', Matrix%Data_Type )
            EndIf
          EndDo
        EndDo

!     Printing for diagonal storage
      ElseIf(Matrix%Storage.eq.'StorDiag') then
        Write(IOut,1002)
        Do I = 1,Min(NRows,NCols)
          If(Matrix%Data_Type.eq.'Integer') then
            If(present(FormatStr)) then
              FormatLine = '(1x,I7,2x,10'//trim(FormatStr)//')'
              Write(IOut,trim(FormatLine)) I, Matrix%MatI(I,1)
            Else
              Write(IOut,2001) I, Matrix%MatI(I,1)
            EndIf
          ElseIf(Matrix%Data_Type.eq.'Real') then
            If(present(FormatStr)) then
              FormatLine = '(1x,I7,2x,10'//trim(FormatStr)//')'
              Write(IOut,trim(FormatLine)) I, Matrix%MatR(I,1)
            Else
              Write(IOut,2002) I, Matrix%MatR(I,1)
            EndIf
          ElseIf(Matrix%Data_Type.eq.'Complex') then
            If(present(FormatStr)) then
              FormatLine = '(1x,I7,2x,10('//trim(FormatStr)//','//trim(FormatStr)//',"i"))'
              Write(IOut,trim(FormatLine)) I, Matrix%MatC(I,1)
            Else
              Write(IOut,2003) I, Matrix%MatC(I,1)
            EndIf
          Else
            Call MQC_Error_A('Matrix data type unspecified in MQC_Print_Matrix_Algebra1', 6, &
                 'Matrix%Data_Type', Matrix%Data_Type )
          EndIf
        EndDo

      Else
        Call MQC_Error_A('Matrix storage type unspecified in MQC_Print_Matrix_Algebra1', 6, &
             'Matrix%Storage', Matrix%Storage )
      EndIf

      If(PRESENT(Blank_At_Bottom)) then
        If(Blank_At_Bottom) Write(IOut,1020)
      EndIf
!
      Return
      End Subroutine MQC_Print_Matrix_Algebra1
!
!
!     PROCEDURE MQC_Matrix_Copy_Int2Real
!
!>    \brief <b> MQC_Matrix_Copy_Int2Real is a subroutine used to copy an integer MQC
!>    matrix into its real space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Copy_Int2Real is a subroutine used to copy an integer MQC matrix 
!>    into its real space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be converted to real.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Matrix_Copy_Int2Real(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::Matrix
!
      If(.not.MQC_Matrix_HaveInteger(Matrix)) Call MQC_Error_L('Incoming matrix not integer in MQC_Matrix_Copy_Int2Real', 6, &
           'MQC_Matrix_HaveInteger(Matrix)', MQC_Matrix_HaveInteger(Matrix) )
      Matrix%MatR = Matrix%MatI
      If(Allocated(Matrix%MatI)) Deallocate(Matrix%MatI)
      Matrix%Data_Type = 'Real'
!
      Return
      End Subroutine MQC_Matrix_Copy_Int2Real
!
!
!     PROCEDURE MQC_Matrix_Copy_Int2Complex
!
!>    \brief <b> MQC_Matrix_Copy_Int2Complex is a subroutine used to copy an integer 
!>    MQC matrix into its complex space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Copy_Int2Complex is a subroutine used to copy an integer MQC matrix 
!>    into its complex space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be converted to complex.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Copy_Int2Complex(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::Matrix
!
      If(.not.MQC_Matrix_HaveInteger(Matrix)) Call MQC_Error_L('Incoming matrix not integer in MQC_Matrix_Copy_Int2Complex', 6, &
           'MQC_Matrix_HaveInteger(Matrix)', MQC_Matrix_HaveInteger(Matrix) )
      Matrix%MatC = Matrix%MatI
      If(Allocated(Matrix%MatI)) Deallocate(Matrix%MatI)
      Matrix%Data_Type = 'Complex'
!
      Return
      End Subroutine MQC_Matrix_Copy_Int2Complex
!
!
!     PROCEDURE MQC_Matrix_Copy_Real2Int
!
!>    \brief <b> MQC_Matrix_Copy_Real2Int is a subroutine used to copy a real MQC
!>    matrix into its integer space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Copy_Real2Int is a subroutine used to copy a real MQC matrix matrix 
!>    into its integer space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be converted to integer.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Matrix_Copy_Real2Int(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::Matrix
!
      If(.not.MQC_Matrix_HaveReal(Matrix)) Call MQC_Error_L('Incoming matrix not real in MQC_Matrix_Copy_Real2Int', 6, &
           'MQC_Matrix_HaveReal(Matrix)', MQC_Matrix_HaveReal(Matrix) )
      Matrix%MatI = Matrix%MatR
      If(Allocated(Matrix%MatR)) Deallocate(Matrix%MatR)
      Matrix%Data_Type = 'Integer'
!
      Return
      End Subroutine MQC_Matrix_Copy_Real2Int
!
!
!     PROCEDURE MQC_Matrix_Copy_Real2Complex
!
!>    \brief <b> MQC_Matrix_Copy_Real2Complex is a subroutine used to copy a real MQC
!>    matrix into its complex space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Copy_Real2Complex is a subroutine used to copy a real MQC matrix 
!>    matrix into its complex space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be converted to complex.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Copy_Real2Complex(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::Matrix
!
      If(.not.MQC_Matrix_HaveReal(Matrix)) Call MQC_Error_L('Incoming matrix not real in MQC_Matrix_Copy_Real2Complex', 6, &
           'MQC_Matrix_HaveReal(Matrix)', MQC_Matrix_HaveReal(Matrix) )
      Matrix%MatC = Matrix%MatR
      If(Allocated(Matrix%MatR)) Deallocate(Matrix%MatR)
      Matrix%Data_Type = 'Complex'
!
      Return
      End Subroutine MQC_Matrix_Copy_Real2Complex
!
!
!     PROCEDURE MQC_Matrix_Copy_Complex2Int
!
!>    \brief <b> MQC_Matrix_Copy_Complex2Int is a subroutine used to copy a complex 
!>    MQC matrix into its integer space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Copy_Complex2Int is a subroutine used to copy a complex MQC matrix 
!>    matrix into its integer space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be converted to integer.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Copy_Complex2Int(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::Matrix
!
      If(.not.MQC_Matrix_HaveComplex(Matrix)) Call MQC_Error_L('Incoming matrix not complex in MQC_Matrix_Copy_Complex2Int', 6, &
           'MQC_Matrix_HaveComplex(Matrix)', MQC_Matrix_HaveComplex(Matrix) )
      Matrix%MatI = Real(Matrix%MatC)
      If(Allocated(Matrix%MatC)) Deallocate(Matrix%MatC)
      Matrix%Data_Type = 'Integer'
!
      Return
      End Subroutine MQC_Matrix_Copy_Complex2Int
!
!
!     PROCEDURE MQC_Matrix_Copy_Complex2Real
!
!>    \brief <b> MQC_Matrix_Copy_Complex2Real is a subroutine used to copy a complex 
!>    MQC matrix into its real space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Copy_Complex2Real is a subroutine used to copy a complex MQC matrix 
!>    matrix into its real space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be converted to real.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Copy_Complex2Real(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::Matrix
!
      If(.not.MQC_Matrix_HaveComplex(Matrix)) Call MQC_Error_L('Incoming matrix not real in MQC_Matrix_Copy_Complex2Real', 6, &
           'MQC_Matrix_HaveComplex(Matrix)', MQC_Matrix_HaveComplex(Matrix) )
      Matrix%MatR = Real(Matrix%MatC)
      If(Allocated(Matrix%MatC)) Deallocate(Matrix%MatC)
      Matrix%Data_Type = 'Real'
!
      Return
      End Subroutine MQC_Matrix_Copy_Complex2Real
!
!
!     PROCEDURE MQC_Matrix_Rows
!
!>    \brief <b> MQC_Matrix_Rows is a function used to return the number of rows of 
!>    an MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Rows is a function used to return the number of rows of an MQC 
!>    matrix. If the matrix is NOT allocated, the number of rows is returned as 0.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Matrix_Rows(Matrix)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64)::MQC_Matrix_Rows
      Type(MQC_Matrix),Intent(In)::Matrix
!
      MQC_Matrix_Rows = Matrix%NRow
!
      Return
      End Function MQC_Matrix_Rows
!
!
!     PROCEDURE MQC_Matrix_Columns
!
!>    \brief <b> MQC_Matrix_Columns is a function used to return the number of 
!>    columns of an MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Columns is a function used to return the number of columns of an MQC 
!>    matrix. If the matrix is NOT allocated, the number of columns is returned as 0.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Matrix_Columns(Matrix)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64)::MQC_Matrix_Columns
      Type(MQC_Matrix),Intent(In)::Matrix
!
      MQC_Matrix_Columns = Matrix%NCol
!
      Return
      End Function MQC_Matrix_Columns
!
!
!     PROCEDURE MQC_Matrix_Size
!
!>    \brief <b> MQC_Matrix_Size is a function used to return the length of the
!>    specified dimension of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Size is a function used to return the length of the specified 
!>    dimension of a MQC matrix. If the matrix is NOT allocated, the number of size 
!>    is returned as 0.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!>
!>    \param[in] Axis
!>    \verbatim
!>        Axis is integer(kind=int64),optional
!>        The axis from which the dimension will be returned.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Matrix_Size(Matrix,Axis)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64)::MQC_Matrix_Size
      Type(MQC_Matrix),Intent(In)::Matrix
      integer(kind=int64),intent(in),optional::axis
      integer(kind=int64)::my_axis
!
      if(present(axis)) then
        my_axis = axis
      else
        my_axis = 1
      endIf

      if(my_axis.eq.1) then
        MQC_Matrix_Size = Matrix%NRow
      elseIf(my_axis.eq.2) then
        MQC_Matrix_Size = Matrix%NCol
      else
        call mqc_error_i('Requested axis not allowed in MQC_Matrix_Size',6,'my_axis',my_axis)
      endIf
!
      Return
      End Function MQC_Matrix_Size
!
!
!     PROCEDURE MQC_Matrix_HaveReal
!
!>    \brief <b> MQC_Matrix_HaveReal is a function used to indicate if an MQC matrix
!>    has an allocated real matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_HaveReal is a function that returns TRUE if an MQC matrix has an 
!>    allocated real matrix and FALSE if it does not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Matrix_HaveReal(Matrix)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Matrix_HaveReal
      Type(MQC_Matrix),Intent(In)::Matrix
!
      MQC_Matrix_HaveReal = Allocated(Matrix%MatR)
!
      Return
      End Function MQC_Matrix_HaveReal
!
!
!     PROCEDURE MQC_Matrix_HaveInteger
!
!>    \brief <b> MQC_Matrix_HaveInteger is a function used to indicate if an MQC 
!>    matrix has an allocated integer matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_HaveInteger is a function that returns TRUE if an MQC matrix has an 
!>    allocated integer matrix and FALSE if it does not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Matrix_HaveInteger(Matrix)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Matrix_HaveInteger
      Type(MQC_Matrix),Intent(In)::Matrix
!
      MQC_Matrix_HaveInteger = Allocated(Matrix%MatI)
!
      Return
      End Function MQC_Matrix_HaveInteger
!
!
!     PROCEDURE MQC_Matrix_HaveComplex
!
!>    \brief <b> MQC_Matrix_HaveComplex is a function used to indicate if an MQC 
!>    matrix has an allocated complex matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_HaveComplex is a function that returns TRUE if an MQC matrix has an 
!>    allocated complex matrix and FALSE if it does not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_HaveComplex(Matrix)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Matrix_HaveComplex
      Type(MQC_Matrix),Intent(In)::Matrix
!
      MQC_Matrix_HaveComplex = Allocated(Matrix%MatC)
!
      Return
      End Function MQC_Matrix_HaveComplex
!
!
!     PROCEDURE MQC_Matrix_HaveFull   
!
!>    \brief <b> MQC_Matrix_HaveFull is a function used to indicate if an MQC 
!>    matrix is stored unpacked</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_HaveFull is a function that returns TRUE if an MQC matrix is stored 
!>    unpacked and FALSE if it is not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_HaveFull(Matrix)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Matrix_HaveFull   
      Type(MQC_Matrix),Intent(In)::Matrix
!
      If(Matrix%Storage.eq.'StorFull') then
        MQC_Matrix_HaveFull = .True. 
      Else
        MQC_Matrix_HaveFull = .False.
      EndIf
!
      Return
      End Function MQC_Matrix_HaveFull   
!
!
!     PROCEDURE MQC_Matrix_HaveSymmetric
!
!>    \brief <b> MQC_Matrix_HaveSymmetric is a function used to indicate if an MQC 
!>    matrix is stored symmetric-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_HaveSymmetric is a function that returns TRUE if an MQC matrix is stored 
!>    symmetric-packed and FALSE if it is not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_HaveSymmetric(Matrix)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Matrix_HaveSymmetric 
      Type(MQC_Matrix),Intent(In)::Matrix
!
      If(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorAsym' .or. &
        Matrix%Storage.eq.'StorHerm' .or. Matrix%Storage.eq.'StorAhrm') then
        MQC_Matrix_HaveSymmetric = .True. 
      Else
        MQC_Matrix_HaveSymmetric = .False.
      EndIf
!
      Return
      End Function MQC_Matrix_HaveSymmetric   
!
!
!     PROCEDURE MQC_Matrix_HaveDiagonal 
!
!>    \brief <b> MQC_Matrix_HaveDiagonal is a function used to indicate if an MQC 
!>    matrix is stored diagonal-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_HaveDiagonal is a function that returns TRUE if an MQC matrix is stored 
!>    diagonal-packed and FALSE if it is not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_HaveDiagonal(Matrix)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_Matrix_HaveDiagonal   
      Type(MQC_Matrix),Intent(In)::Matrix
!
      If(Matrix%Storage.eq.'StorDiag') then
        MQC_Matrix_HaveDiagonal = .True. 
      Else
        MQC_Matrix_HaveDiagonal = .False.
      EndIf
!
      Return
      End Function MQC_Matrix_HaveDiagonal   
!
!
!     PROCEDURE MQC_Matrix_Transpose
!
!>    \brief <b> MQC_Matrix_Transpose is a function that returns the transpose of a
!>    MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Transpose is a function that returns the transpose of a MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be transposed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \author X. Sheng
!>    \date 2016, 2017
!
      Function MQC_Matrix_Transpose(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::MQC_Matrix_Transpose
      Class(MQC_Matrix),Intent(In)::Matrix
      Integer::I
!
      If(MQC_Matrix_HaveReal(Matrix)) then
        Call MQC_Allocate_Matrix(Matrix%NCol,Matrix%NRow,MQC_Matrix_Transpose, &
          'Real',Matrix%Storage)
        If (Matrix%Storage.eq.'StorFull') then
          MQC_Matrix_Transpose%MatR = Transpose(Matrix%MatR)
        ElseIf (Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorHerm' .or. &
            Matrix%Storage.eq.'StorDiag') then
          MQC_Matrix_Transpose%MatR = Matrix%MatR
        ElseIf (Matrix%Storage.eq.'StorAsym' .or. Matrix%Storage.eq.'StorAhrm') then
          MQC_Matrix_Transpose%MatR = (-1)*Matrix%MatR
          Do I = 1, Size(MQC_Matrix_Transpose,1)
            MQC_Matrix_Transpose%MatR(symIndexHash(I,I),1) = (-1)*MQC_Matrix_Transpose%MatR(symIndexHash(I,I),1)
          EndDo
        Else
          Call MQC_Error_A('transposing a triD matrix is not supported yet', 6, &
               'Matrix%Storage', Matrix%Storage )
        EndIf
      ElseIf(MQC_Matrix_HaveInteger(Matrix)) then
        Call MQC_Allocate_Matrix(Matrix%NCol,Matrix%NRow,MQC_Matrix_Transpose, &
          'Integer',Matrix%Storage)
        If (Matrix%Storage.eq.'StorFull') then
          MQC_Matrix_Transpose%MatI = Transpose(Matrix%MatI)
        ElseIf (Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorHerm' .or. &
            Matrix%Storage.eq.'StorDiag') then
          MQC_Matrix_Transpose%MatI = Matrix%MatI
        ElseIf (Matrix%Storage.eq.'StorAsym' .or. Matrix%Storage.eq.'StorAhrm') then
          MQC_Matrix_Transpose%MatI = (-1)*Matrix%MatI
          Do I = 1, Size(MQC_Matrix_Transpose,1)
            MQC_Matrix_Transpose%MatI(symIndexHash(I,I),1) = (-1)*MQC_Matrix_Transpose%MatI(symIndexHash(I,I),1)
          EndDo
        Else
          Call MQC_Error_A('transposing a triD matrix is not supported yet', 6, &
               'Matrix%Storage', Matrix%Storage )
        EndIf
      ElseIf(MQC_Matrix_HaveComplex(Matrix)) then
        Call MQC_Allocate_Matrix(Matrix%NCol,Matrix%NRow,MQC_Matrix_Transpose, &
          'Complex',Matrix%Storage)
        If (Matrix%Storage.eq.'StorFull') then
          MQC_Matrix_Transpose%MatC = Transpose(Matrix%MatC)
        ElseIf (Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorDiag') then
          MQC_Matrix_Transpose%MatC = Matrix%MatC
        ElseIf (Matrix%Storage.eq.'StorAsym') then
          MQC_Matrix_Transpose%MatC = (-1)*Matrix%MatC
          Do I = 1, Size(MQC_Matrix_Transpose,1)
            MQC_Matrix_Transpose%MatC(symIndexHash(I,I),1) = (-1)*MQC_Matrix_Transpose%MatC(symIndexHash(I,I),1)
          EndDo
        ElseIf (Matrix%Storage.eq.'StorHerm') then
          MQC_Matrix_Transpose%MatC = conjg(Matrix%MatC)
          Do I = 1, Size(MQC_Matrix_Transpose,1)
            MQC_Matrix_Transpose%MatC(symIndexHash(I,I),1) = conjg(MQC_Matrix_Transpose%MatC(symIndexHash(I,I),1))
          EndDo
        ElseIf (Matrix%Storage.eq.'StorAhrm') then
          MQC_Matrix_Transpose%MatC = (-1)*conjg(Matrix%MatC)
          Do I = 1, Size(MQC_Matrix_Transpose,1)
            MQC_Matrix_Transpose%MatC(symIndexHash(I,I),1) = (-1)*conjg(MQC_Matrix_Transpose%MatC(symIndexHash(I,I),1))
          EndDo
        Else
          Call MQC_Error_A('transposing a triD matrix is not supported yet', 6, &
          'Matrix%Storage', Matrix%Storage )
        EndIf
      EndIf
!
      Return
      End Function MQC_Matrix_Transpose
!
!
!     PROCEDURE MQC_Matrix_Conjugate_Transpose
!
!>    \brief <b> MQC_Matrix_Conjugate_Transpose is a function that returns the 
!>    conjugate transpose of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Conjugate_Transpose is a function that returns the conjugate 
!>    transpose of a MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be conjugate transposed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Matrix_Conjugate_Transpose(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::MQC_Matrix_Conjugate_Transpose
      Class(MQC_Matrix),Intent(In)::Matrix
      Integer(kind=int64)::I
!
      If(MQC_Matrix_HaveReal(Matrix)) then
        Call MQC_Allocate_Matrix(Matrix%NCol,Matrix%NRow,MQC_Matrix_Conjugate_Transpose, &
          'Real',Matrix%Storage)
        If (Matrix%Storage.eq.'StorFull') then
          MQC_Matrix_Conjugate_Transpose%MatR = Transpose(Matrix%MatR)
        ElseIf (Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorHerm' .or. &
            Matrix%Storage.eq.'StorDiag') then
          MQC_Matrix_Conjugate_Transpose%MatR = Matrix%MatR
        ElseIf (Matrix%Storage.eq.'StorAsym' .or. Matrix%Storage.eq.'StorAhrm') then
          MQC_Matrix_Conjugate_Transpose%MatR = (-1)*Matrix%MatR
          Do I = 1, Size(MQC_Matrix_Conjugate_Transpose,1)
            MQC_Matrix_Conjugate_Transpose%MatR(symIndexHash(I,I),1) = &
              (-1)*MQC_Matrix_Conjugate_Transpose%MatR(symIndexHash(I,I),1)
          EndDo
        Else
          Call MQC_Error_A('Unrecognise matrix storage type in MQC_Matrix_Conjugate_Transpose', 6, &
               'Matrix%Storage', Matrix%Storage )
        EndIf
      ElseIf(MQC_Matrix_HaveInteger(Matrix)) then
        Call MQC_Allocate_Matrix(Matrix%NCol,Matrix%NRow,MQC_Matrix_Conjugate_Transpose, &
          'Integer',Matrix%Storage)
        If (Matrix%Storage.eq.'StorFull') then
          MQC_Matrix_Conjugate_Transpose%MatI = Transpose(Matrix%MatI)
        ElseIf (Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorHerm' .or. &
            Matrix%Storage.eq.'StorDiag') then
          MQC_Matrix_Conjugate_Transpose%MatI = Matrix%MatI
        ElseIf (Matrix%Storage.eq.'StorAsym' .or. Matrix%Storage.eq.'StorAhrm') then
          MQC_Matrix_Conjugate_Transpose%MatI = (-1)*Matrix%MatI
          Do I = 1, Size(MQC_Matrix_Conjugate_Transpose,1)
            MQC_Matrix_Conjugate_Transpose%MatI(symIndexHash(I,I),1) = &
              (-1)*MQC_Matrix_Conjugate_Transpose%MatI(symIndexHash(I,I),1)
          EndDo
        Else
          Call MQC_Error_A('Unrecognise matrix storage type in MQC_Matrix_Conjugate_Transpose', 6, &
               'Matrix%Storage', Matrix%Storage )
        EndIf
      ElseIf(MQC_Matrix_HaveComplex(Matrix)) then
        Call MQC_Allocate_Matrix(Matrix%NCol,Matrix%NRow,MQC_Matrix_Conjugate_Transpose, &
          'Complex',Matrix%Storage)
        If (Matrix%Storage.eq.'StorFull') then
          MQC_Matrix_Conjugate_Transpose%MatC = Transpose(conjg(Matrix%MatC))
        ElseIf (Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorDiag') then
          MQC_Matrix_Conjugate_Transpose%MatC = conjg(Matrix%MatC)
        ElseIf (Matrix%Storage.eq.'StorAsym') then
          MQC_Matrix_Conjugate_Transpose%MatC = (-1)*conjg(Matrix%MatC)
          Do I = 1, Size(MQC_Matrix_Conjugate_Transpose,1)
            MQC_Matrix_Conjugate_Transpose%MatC(symIndexHash(I,I),1) = &
              (-1)*MQC_Matrix_Conjugate_Transpose%MatC(symIndexHash(I,I),1)
          EndDo
        ElseIf (Matrix%Storage.eq.'StorHerm') then
          MQC_Matrix_Conjugate_Transpose%MatC = Matrix%MatC
          Do I = 1, Size(MQC_Matrix_Conjugate_Transpose,1)
            MQC_Matrix_Conjugate_Transpose%MatC(symIndexHash(I,I),1) = &
              conjg(MQC_Matrix_Conjugate_Transpose%MatC(symIndexHash(I,I),1))
          EndDo
        ElseIf (Matrix%Storage.eq.'StorAhrm') then
          MQC_Matrix_Conjugate_Transpose%MatC = (-1)*Matrix%MatC
          Do I = 1, Size(MQC_Matrix_Conjugate_Transpose,1)
            MQC_Matrix_Conjugate_Transpose%MatC(symIndexHash(I,I),1) = &
              (-1)*MQC_Matrix_Conjugate_Transpose%MatC(symIndexHash(I,I),1)
          EndDo
        Else
          Call MQC_Error_A('Unrecognise matrix storage type in MQC_Matrix_Conjugate_Transpose', 6, &
               'Matrix%Storage', Matrix%Storage )
        EndIf
      EndIf
!
      Return
      End Function MQC_Matrix_Conjugate_Transpose
!
!
!     PROCEDURE MQC_Matrix_Symmetrize
!
!>    \brief <b> MQC_Matrix_Symmetrize is a function that returns the symmetric/
!>    antisymmetric/hermitian/antihermitian component of a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Symmetrize is a function that returns the symmetric/antisymmetric/
!>    hermitian/antihermitian component of a MQC matrix. The following optional 
!>    arguments are available:
!>
!>    1. Label = 'symmetrize' returns the symmetric component (default).
!>    2. Label = 'antisymmetrize' returns the antisymmetric component.
!>    3. Label = 'hermitianize' returns the hermitian component.
!>    4. Label = 'anitihermitianize' returns the antihermitian component.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be symmetrized.
!>    \endverbatim
!>
!>    \param[in] Label
!>    \verbatim
!>        Label is Character(len=*),optional
!>        = 'symmetrize':        returns the symmetric component (default).
!>        = 'antisymmetrize':    returns the antisymmetric component.
!>        = 'hermitianize':      returns the hermitian component.
!>        = 'anitihermitianize': returns the antihermitian component.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Matrix_Symmetrize(Matrix,Label)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::MQC_Matrix_Symmetrize
      Type(MQC_Matrix),Intent(In)::Matrix
      Character(len=*),optional::label
      Integer(kind=int64)::I,J
      Real(kind=real64),Parameter::Pt5=0.5
      Character(len=64)::mylabel
!
      if(present(label)) then
        call string_change_case(label,'L',myLabel)
      else
        myLabel = 'symmetrize'
      endIf

      If(.not.Matrix%Storage.eq.'StorFull') Return
      If(Matrix%NCol.ne.Matrix%NRow) Call MQC_Error_I('Only square matricies can be symmetrixed &
     &  in MQC_Matrix_Symmetrize', 6, &
     'Matrix%NCol', Matrix%NCol, &
     'Matrix%NRow', Matrix%NRow )
     MQC_Matrix_Symmetrize = Matrix
     select case(mylabel)
     case ('symmetrize')
       MQC_Matrix_Symmetrize = Pt5*(Matrix+transpose(Matrix))
     case ('antisymmetrize')
       MQC_Matrix_Symmetrize = Pt5*(Matrix-transpose(Matrix))
     case ('hermitianize')
       MQC_Matrix_Symmetrize = Pt5*(Matrix+dagger(Matrix))
     case ('antihermitianize')
       MQC_Matrix_Symmetrize = Pt5*(Matrix-dagger(Matrix))
     case default
       call mqc_error_a('Unrecognized symmetrization type label in in MQC_Matrix_Symmetrize', &
         6,'mylabel',mylabel)
     end select
!
      Return
      End Function MQC_Matrix_Symmetrize
!
!
!     PROCEDURE MQC_Matrix_Full2Symm
!
!>    \brief <b> MQC_Matrix_Full2Symm is a subroutine that converts an unpacked MQC 
!>    matrix to symmetric-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Full2Symm is a subroutine that converts an unpacked MQC matrix to 
!>    symmetric-packed.
!>      TODO: make tests for symmetry more efficient.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be symmetric packed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Matrix_Full2Symm(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::Matrix
      Real(kind=real64),Dimension(:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:),Allocatable::TempC
      Integer(kind=int64)::I,J,II
      Character(len=64)::label
!
      If(.not.Matrix%Storage.eq.'StorFull') Call MQC_Error_A('Input matrix must be full &
     &  packed in MQC_Matrix_Full2Symm', 6, &
     'Matrix%Storage', Matrix%Storage )
      If(MQC_Matrix_Test_Symmetric(Matrix,'symmetric')) then
        label = 'symmetric'
      ElseIf(MQC_Matrix_Test_Symmetric(Matrix,'antisymmetric')) then
        label = 'antisymmetric'
      ElseIf(MQC_Matrix_Test_Symmetric(Matrix,'hermitian')) then
        label = 'hermitian'
      ElseIf(MQC_Matrix_Test_Symmetric(Matrix,'antihermitian')) then
        label = 'antihermitian'
      Else
        Call MQC_Error_L('Input matrix must be symmetric/antisymmetric/hermitian in MQC_Matrix_Full2Symm', 6, &
          'MQC_Matrix_Test_Symmetric(Matrix)', MQC_Matrix_Test_Symmetric(Matrix), &
          "MQC_Matrix_Test_Symmetric(Matrix,'antisymmetric')", MQC_Matrix_Test_Symmetric(Matrix,'antisymmetric'), &
          "MQC_Matrix_Test_Symmetric(Matrix,'hermitian')", MQC_Matrix_Test_Symmetric(Matrix,'hermitian'), &
          "MQC_Matrix_Test_Symmetric(Matrix,'antihermitian')", MQC_Matrix_Test_Symmetric(Matrix,'antihermitian') )
      EndIf
      If(MQC_Matrix_HaveReal(Matrix)) then
        Allocate(Temp(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)))
        Temp = Matrix%MatR
        Call MQC_Deallocate_Matrix(Matrix)
        If(label.eq.'symmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Real','StorSymm')
        ElseIf(label.eq.'antisymmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Real','StorAsym')
        ElseIf(label.eq.'hermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Real','StorHerm')
        ElseIf(label.eq.'antihermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Real','StorAhrm')
        EndIf
        Do I = 1, Size(Temp,1)
          II = (I*(I-1))/2
          Do J = 1, I
            Matrix%MatR(II+J,1) = Temp(I,J)
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_Matrix_HaveInteger(Matrix)) then
        Allocate(Temp(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)))
        Temp = Matrix%MatI
        Call MQC_Deallocate_Matrix(Matrix)
        If(label.eq.'symmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Integer','StorSymm')
        ElseIf(label.eq.'antisymmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Integer','StorAsym')
        ElseIf(label.eq.'hermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Integer','StorHerm')
        ElseIf(label.eq.'antihermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Integer','StorAhrm')
        EndIf
        Do I = 1, Size(Temp,1)
          II = (I*(I-1))/2
          Do J = 1, I
            Matrix%MatI(II+J,1) = Temp(I,J)
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_Matrix_HaveComplex(Matrix)) then
        Allocate(TempC(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)))
        TempC = Matrix%MatC
        Call MQC_Deallocate_Matrix(Matrix)
        If(label.eq.'symmetric') then
          Call MQC_Allocate_Matrix(Size(TempC,1),Size(TempC,2),Matrix,'Complex','StorSymm')
        ElseIf(label.eq.'antisymmetric') then
          Call MQC_Allocate_Matrix(Size(TempC,1),Size(TempC,2),Matrix,'Complex','StorAsym')
        ElseIf(label.eq.'hermitian') then
          Call MQC_Allocate_Matrix(Size(TempC,1),Size(TempC,2),Matrix,'Complex','StorHerm')
        ElseIf(label.eq.'antihermitian') then
          Call MQC_Allocate_Matrix(Size(TempC,1),Size(TempC,2),Matrix,'Complex','StorAhrm')
        EndIf
        Do I = 1, Size(TempC,1)
          II = (I*(I-1))/2
          Do J = 1, I
            Matrix%MatC(II+J,1) = TempC(I,J)
          EndDo
        EndDo
        Deallocate(TempC)
      EndIf
!
      Return
      End Subroutine MQC_Matrix_Full2Symm
!
!
!     PROCEDURE MQC_Matrix_Symm2Full
!
!>    \brief <b> MQC_Matrix_Symm2Full is a subroutine that converts a symmetry-packed 
!>    MQC matrix to unpacked</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Symm2Full is a subroutine that converts a symmetry-packed MQC matrix 
!>    to unpacked.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to unpack.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016, 2018
!
      Subroutine MQC_Matrix_Symm2Full(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::Matrix
      Real(kind=real64),Dimension(:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:),Allocatable::TempC
      Integer(kind=int64)::I,J,II,N,NTT
      Character(len=10)::storage
!
      If(.not.(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorAsym'.or. &
        Matrix%Storage.eq.'StorHerm'.or.Matrix%Storage.eq.'StorAhrm')) &
        Call MQC_Error_A('Input matrix must be lower-triangular packed &
        & in MQC_Matrix_Symm2Full', 6, 'Matrix%Storage', Matrix%Storage )
      N = MQC_Matrix_Columns(Matrix)
      NTT = (N*(N+1))/2
      storage = Matrix%Storage
      If(Matrix%Data_Type.eq.'Real') then
        Allocate(Temp(NTT,1))
        Temp = Matrix%MatR
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(N,N,Matrix,'Real','StorFull')
        Do I = 1, N
          II = (I*(I-1))/2
          Do J = 1,I
            If(storage.eq.'StorAsym'.or.storage.eq.'StorAhrm') then
              Matrix%MatR(J,I) = -Temp(II+J,1)
            ElseIf(storage.eq.'StorSymm'.or.storage.eq.'StorHerm') then
              Matrix%MatR(J,I) = Temp(II+J,1)
            Else
              Call MQC_Error_A('Unrecognized initial matrix storage type in &
                & MQC_Matrix_Symm2Full',6,'storage',storage)
            EndIf
            Matrix%MatR(I,J) = Temp(II+J,1)
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Integer') then
        Allocate(Temp(NTT,1))
        Temp = Matrix%MatI
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(N,N,Matrix,'Integer','StorFull')
        Do I = 1, N
          II = (I*(I-1))/2
          Do J = 1,I
            If(storage.eq.'StorAsym'.or.storage.eq.'StorAhrm') then
              Matrix%MatI(J,I) = -Temp(II+J,1)
            ElseIf(storage.eq.'StorSymm'.or.storage.eq.'StorHerm') then
              Matrix%MatI(J,I) = Temp(II+J,1)
            Else
              Call MQC_Error_A('Unrecognized initial matrix storage type in &
                & MQC_Matrix_Symm2Full',6,'storage',storage)
            EndIf
            Matrix%MatI(I,J) = Temp(II+J,1)
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Complex') then
        Allocate(TempC(NTT,1))
        TempC = Matrix%MatC
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(N,N,Matrix,'Complex','StorFull')
        Do I = 1, N
          II = (I*(I-1))/2
          Do J = 1,I
            If(storage.eq.'StorAsym') then
              Matrix%MatC(J,I) = -TempC(II+J,1)
            ElseIf(storage.eq.'StorAhrm') then
              Matrix%MatC(J,I) = -(1)*conjg(TempC(II+J,1))
            ElseIf(storage.eq.'StorHerm') then
              Matrix%MatC(J,I) = conjg(TempC(II+J,1))
            ElseIf(storage.eq.'StorSymm') then
              Matrix%MatC(J,I) = TempC(II+J,1)
            Else
              Call MQC_Error_A('Unrecognized initial matrix storage type in &
                & MQC_Matrix_Symm2Full',6,'storage',storage)
            EndIf
            Matrix%MatC(I,J) = TempC(II+J,1)
          EndDo
        EndDo
        Deallocate(TempC)
      EndIf
!
      Return
      End Subroutine MQC_Matrix_Symm2Full
!
!
!     PROCEDURE MQC_Matrix_Full2Diag
!
!>    \brief <b> MQC_Matrix_Full2Diag is a subroutine that converts an unpacked MQC 
!>    matrix to diagonal-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Full2Diag is a subroutine that converts an unpacked MQC matrix to 
!>    diagonal-packed.
!>      TODO: make tests for diagonal structure more efficient.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be diagonal packed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Matrix_Full2Diag(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::Matrix
      Real(kind=real64),Dimension(:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:),Allocatable::TempC
      Integer(kind=int64)::I
!
      If(.not.Matrix%Storage.eq.'StorFull') Call MQC_Error_A('Input matrix must be full &
     &  packed in MQC_Matrix_Full2Diag', 6, &
     'Matrix%Storage', Matrix%Storage )
      If(.not.MQC_Matrix_Test_Diagonal(Matrix)) Call MQC_Error_L('Input matrix must be &
     &  diagonal in MQC_Matrix_Full2Diag', 6, &
      'MQC_Matrix_Test_Diagonal(Matrix)', MQC_Matrix_Test_Diagonal(Matrix) )
      If(MQC_Matrix_HaveReal(Matrix)) then
        Allocate(Temp(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)))
        Temp = Matrix%MatR
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Real', &
          'StorDiag')
        Do I = 1, Min(Size(Temp,1),Size(Temp,2))
          Matrix%MatR(I,1) = Temp(I,I)
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_Matrix_HaveInteger(Matrix)) then
        Allocate(Temp(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)))
        Temp = Matrix%MatI
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,2),Matrix,'Integer', &
          'StorDiag')
        Do I = 1, Min(Size(Temp,1),Size(Temp,2))
          Matrix%MatI(I,1) = Temp(I,I)
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_Matrix_HaveComplex(Matrix)) then
        Allocate(TempC(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)))
        TempC = Matrix%MatC
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(Size(TempC,1),Size(TempC,2),Matrix,'Complex', &
          'StorDiag')
        Do I = 1, Min(Size(TempC,1),Size(TempC,2))
          Matrix%MatC(I,1) = TempC(I,I)
        EndDo
        Deallocate(TempC)
      Else
        Call MQC_Error_L('Matrix type not defined in MQC_Matrix_Full2Diag', 6, &
             'MQC_Matrix_HaveReal(Matrix)', MQC_Matrix_HaveReal(Matrix) )
      EndIf
!
      Return
      End Subroutine MQC_Matrix_Full2Diag
!
!
!     PROCEDURE MQC_Matrix_Diag2Full
!
!>    \brief <b> MQC_Matrix_Diag2Full is a subroutine that converts a diagonal-packed 
!>    MQC matrix to unpacked</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Diag2Full is a subroutine that converts a diagonal-packed MQC matrix 
!>    to unpacked.
!>      TODO: make tests for diagonal structure more efficient.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be unpacked.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Diag2Full(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::Matrix
      Real(kind=real64),Dimension(:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:),Allocatable::TempC
      Integer(kind=int64)::I,N,Columns,Rows
!
      If(.not.Matrix%Storage.eq.'StorDiag') Call MQC_Error_A('Input matrix must be &
     &  diagonal packed in MQC_Matrix_Diag2Full',6,'Matrix%Storage', Matrix%Storage )
      If(.not.MQC_Matrix_Test_Diagonal(Matrix)) Call MQC_Error_L('Input matrix must be &
     &  diagonal in MQC_Matrix_Diag2Full', 6, &
      'MQC_Matrix_Test_Diagonal(Matrix)', MQC_Matrix_Test_Diagonal(Matrix) )
      N = Min(MQC_Matrix_Columns(Matrix),MQC_Matrix_Rows(Matrix))
      Columns = MQC_Matrix_Columns(Matrix)
      Rows = MQC_Matrix_Rows(Matrix)
      If(Matrix%Data_Type.eq.'Real') then
        Allocate(Temp(N,1))
        Temp = Matrix%MatR
        Call MQC_Deallocate_Matrix(Matrix)
        Call Matrix%init(Columns,Rows)
        Do I = 1, N
          Matrix%MatR(I,I) = Temp(I,1)
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Integer') then
        Allocate(Temp(N,1))
        Temp = Matrix%MatI
        Call MQC_Deallocate_Matrix(Matrix)
        Call Matrix%init(Columns,Rows,0)
        Do I = 1, N
          Matrix%MatI(I,I) = Temp(I,1)
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Complex') then
        Allocate(TempC(N,1))
        TempC = Matrix%MatC
        Call MQC_Deallocate_Matrix(Matrix)
        Call Matrix%init(Columns,Rows,cmplx(0,0))
        Do I = 1, N
          Matrix%MatC(I,I) = TempC(I,1)
        EndDo
        Deallocate(TempC)
      EndIf
!
      Return
      End Subroutine MQC_Matrix_Diag2Full
!
!
!     PROCEDURE MQC_Matrix_Symm2Diag
!
!>    \brief <b> MQC_Matrix_Symm2Diag is a subroutine that converts a symmetry-packed 
!>    MQC matrix to diagonal-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Symm2Diag is a subroutine that converts a symmetry-packed MQC matrix to 
!>    diagonal-packed.
!>      TODO: make tests for diagonal structure more efficient.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be diagonal packed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Symm2Diag(Matrix)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::Matrix
      Real(kind=real64),Dimension(:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:),Allocatable::TempC
      Integer(kind=int64)::I,II,N,NTT
!
      If(.not.(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorAsym'.or. &
        Matrix%Storage.eq.'StorHerm'.or.Matrix%Storage.eq.'StorAhrm')) &
        Call MQC_Error_A('Input matrix must be lower-triangular packed &
        & in MQC_Matrix_Symm2Diag', 6, 'Matrix%Storage', Matrix%Storage )
      N = MQC_Matrix_Columns(Matrix)
      NTT = (N*(N+1))/2
      If(Matrix%Data_Type.eq.'Real') then
        Allocate(Temp(NTT,1))
        Temp = Matrix%MatR
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(N,N,Matrix,'Real','StorDiag')
        Do I = 1, N
          II = (I*(I-1))/2
          Matrix%MatR(I,1) = Temp(II+I,1)
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Integer') then
        Allocate(Temp(NTT,1))
        Temp = Matrix%MatI
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(N,N,Matrix,'Integer','StorDiag')
        Do I = 1, N
          II = (I*(I-1))/2
          Matrix%MatI(I,1) = Temp(II+I,1)
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Complex') then
        Allocate(TempC(NTT,1))
        TempC = Matrix%MatC
        Call MQC_Deallocate_Matrix(Matrix)
        Call MQC_Allocate_Matrix(N,N,Matrix,'Complex','StorDiag')
        Do I = 1, N
          II = (I*(I-1))/2
          Matrix%MatC(I,1) = TempC(II+I,1)
        EndDo
        Deallocate(TempC)
      EndIf
!
      Return
      End Subroutine MQC_Matrix_Symm2Diag
!
!
!     PROCEDURE MQC_Matrix_Diag2Symm
!
!>    \brief <b> MQC_Matrix_Diag2Symm is a subroutine that converts a diagonal-packed 
!>    MQC matrix to symmetry-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Diag2Symm is a subroutine that converts a diagonal-packed MQC matrix 
!>    to symmetry-packed.!>     The following options are 
!>    available: 
!>
!>    1. Option = 'symmetric' output matrix is labelled symmetric (default).
!>    2. Option = 'antisymmetric' output matrix is labelled antisymmetric.
!>    3. Option = 'hermitian' output matrix is labelled hermitian.
!>    4. Option = 'antihermitian' output matrix is labelled antihermitian.
!>
!>      TODO: make tests for diagonal structure more efficient.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be unpacked.
!>    \endverbatim
!>    
!>    \param[in] Option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'symmetric':     output matrix is labelled symmetric (default)
!>        = 'antisymmetric': output matrix is labelled antisymmetric
!>        = 'hermitian':     output matrix is labelled hermitian
!>        = 'antihermitian': output matrix is labelled antihermitian.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Diag2Symm(Matrix,Option)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(InOut)::Matrix
      Character(len=*),Optional,Intent(In)::Option
      Real(kind=real64),Dimension(:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:),Allocatable::TempC
      Integer(kind=int64)::I,II
      Character(len=64)::myOption
!
      If(Present(Option)) then
        call string_change_case(Option,'l',myOption)
      else
        myOption = 'symmetric'
      endIf
      If(myOption.ne.'symmetric'.and.myOption.ne.'antisymmetric'.and.myOption.ne.'hermitian'.and.&
        myOption.ne.'antihermitian') call mqc_error_a('Unrecognized option in &
        & MQC_Matrix_Scalar_Put',6,'myOption',myOption)
      If(.not.Matrix%Storage.eq.'StorDiag') Call MQC_Error_A('Input matrix must be &
     &  diagonal packed in MQC_Matrix_Diag2Symm', 6, 'Matrix%Storage', Matrix%Storage)
      If(MQC_Matrix_Columns(Matrix).ne.MQC_Matrix_Rows(Matrix)) &
        Call MQC_Error_I('Input matrix must be square in MQC_Matrix_Diag2Symm', 6, &
        'MQC_Matrix_Columns(Matrix)', MQC_Matrix_Columns(Matrix), &
        'MQC_Matrix_Rows(Matrix)', MQC_Matrix_Rows(Matrix) )
      If(Matrix%Data_Type.eq.'Integer') then
        Allocate(Temp(Min(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)),1))
        Temp = Matrix%MatI
        Call MQC_Deallocate_Matrix(Matrix)
        If(myOption.eq.'symmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Integer', &
            'StorSymm')
        elseIf(myOption.eq.'antisymmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Integer', &
            'StorAsym')
        elseIf(myOption.eq.'hermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Integer', &
            'StorHerm')
        elseIf(myOption.eq.'antihermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Integer', &
            'StorAhrm')
        endIf
        Matrix%MatI = 0
        Do I = 1, Size(Temp,1)
          II = (I*(I-1))/2
          Matrix%MatI(II+I,1) = Temp(I,1)
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Real') then
        Allocate(Temp(Min(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)),1))
        Temp = Matrix%MatR
        Call MQC_Deallocate_Matrix(Matrix)
        If(myOption.eq.'symmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Real', &
            'StorSymm')
        elseIf(myOption.eq.'antisymmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Real', &
            'StorAsym')
        elseIf(myOption.eq.'hermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Real', &
            'StorHerm')
        elseIf(myOption.eq.'antihermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Real', &
            'StorAhrm')
        endIf
        Matrix%MatR = 0.0d0
        Do I = 1, Size(Temp,1)
          II = (I*(I-1))/2
          Matrix%MatR(II+I,1) = Temp(I,1)
        EndDo
        Deallocate(Temp)
      ElseIf(Matrix%Data_Type.eq.'Complex') then
        Allocate(TempC(Min(MQC_Matrix_Rows(Matrix),MQC_Matrix_Columns(Matrix)),1))
        TempC = Matrix%MatC
        Call MQC_Deallocate_Matrix(Matrix)
        If(myOption.eq.'symmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Complex', &
            'StorSymm')
        elseIf(myOption.eq.'antisymmetric') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Complex', &
            'StorAsym')
        elseIf(myOption.eq.'hermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Complex', &
            'StorHerm')
        elseIf(myOption.eq.'antihermitian') then
          Call MQC_Allocate_Matrix(Size(Temp,1),Size(Temp,1),Matrix,'Complex', &
            'StorAhrm')
        endIf
        Matrix%MatC = Cmplx(0.0,0.0)
        Do I = 1, Size(TempC,1)
          II = (I*(I-1))/2
          Matrix%MatC(II+I,1) = TempC(I,1)
        EndDo
        Deallocate(TempC)
      EndIf
!
      Return
      End Subroutine MQC_Matrix_Diag2Symm
!
!
!     PROCEDURE MQC_Matrix_Symm2Full_Func
!
!>    \brief <b> MQC_Matrix_Symm2Full_Func is a function that converts a symmetric-
!>    packed MQC matrix to unpacked</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Symm2Full_Func is a function that converts a symmetric-packed MQC matrix 
!>    to unpacked.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to be unpacked.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_Matrix_Symm2Full_Func(Matrix) Result(Temp)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(In)::Matrix
      type(MQC_Matrix)::Temp
      Integer(kind=int64)::I,J,II,N
!
      If(.not.Matrix%Storage.eq.'StorSymm') Call MQC_Error_A('Input matrix must be &
     &  lower-triangular packed in MQC_Matrix_Symm2Full', 6, &
     'Matrix%Storage', Matrix%Storage )
      N = MQC_Matrix_Columns(Matrix)
      Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Temp,Matrix%Data_Type,'StorFull')
      If(Matrix%Data_Type.eq.'Real') then
        Do I = 1, N
          II = (I*(I-1))/2
          Do J = 1,I
            Temp%MatR(I,J) = Matrix%MatR(II+J,1)
            if(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorHerm') then
              Temp%MatR(J,I) = Matrix%MatR(II+J,1)
            elseIf(Matrix%Storage.eq.'StorAsym'.or.Matrix%Storage.eq.'StorAhrm') then
              Temp%MatR(J,I) = (-1)*Matrix%MatR(II+J,1)
            endIf
          EndDo
        EndDo
      ElseIf(Matrix%Data_Type.eq.'Integer') then
        Do I = 1, N
          II = (I*(I-1))/2
          Do J = 1,I
            Temp%MatI(I,J) = Matrix%MatI(II+J,1)
            if(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorHerm') then
              Temp%MatI(J,I) = Matrix%MatI(II+J,1)
            elseIf(Matrix%Storage.eq.'StorAsym'.or.Matrix%Storage.eq.'StorAhrm') then
              Temp%MatI(J,I) = (-1)*Matrix%MatI(II+J,1)
            endIf
          EndDo
        EndDo
      ElseIf(Matrix%Data_Type.eq.'Complex') then
        Do I = 1, N
          II = (I*(I-1))/2
          Do J = 1,I
            Temp%MatC(I,J) = Matrix%MatC(II+J,1)
            if(Matrix%Storage.eq.'StorSymm') then
              Temp%MatC(J,I) = Matrix%MatC(II+J,1)
            elseIf(Matrix%Storage.eq.'StorHerm') then
              Temp%MatC(J,I) = conjg(Matrix%MatC(II+J,1))
            elseIf(Matrix%Storage.eq.'StorAsym') then
              Temp%MatC(J,I) = (-1)*Matrix%MatC(II+J,1)
            elseIf(Matrix%Storage.eq.'StorAhrm') then
              Temp%MatC(J,I) = (-1)*conjg(Matrix%MatC(II+J,1))
            endIf
          EndDo
        EndDo
      EndIf
!
      Return
      End Function MQC_Matrix_Symm2Full_Func
!
!
!     PROCEDURE Matrix_Symm2Sq_Integer
!
!>    \brief <b> Matrix_Symm2Sq_Integer is a subroutine that converts a symmetric-
!>    packed intrinsic integer matrix to a rank-2 intrinsic integer array</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    Matrix_Symm2Sq_Integer is a subroutine that converts a symmetric-packed 
!>    intrinsic integer matrix to a rank-2 integer array.The following options 
!>    are available:
!>      Option = 'symmetric' unpack matrix as symmetric.
!>      Option = 'antisymmetric' unpack matrix as antisymmetric.
!>      Option = 'hermitian' unpack matrix as hermitian.
!>      Option = 'antihermitian' unpack matrix as antihermitian.
!>    TODO: Move this routine to MQC general
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] N
!>    \verbatim
!>        N is Integer(kind=int64)
!>        The leading dimension of symmetric-packed matrix I_Symm.
!>        unpacked.
!>    \endverbatim
!>
!>    \param[in] I_Symm
!>    \verbatim
!>        I_Symm is Integer(kind=int64),Dimension(:)
!>        The symmetric-packed intrinsic integer matrix to be unpacked.
!>    \endverbatim
!>
!>    \param[out] I_Sq
!>    \verbatim
!>        I_Sq is Integer(kind=int64),Dimension(N,N)
!>        The upacked intrinsic integer matrix output.
!>    \endverbatim
!>
!>    \param[in] option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'symmetric':      Unpack matrix as symmetric
!>        = 'antisymmetric':  Unpack matrix as antisymmetric
!>        = 'hermitian':      Unpack matrix as hermitian
!>        = 'antihermitian':  Unpack matrix as antihermitian
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2017
!
      Subroutine Matrix_Symm2Sq_Integer(N,I_Symm,I_Sq,option)
!
      Implicit None
      Integer(kind=int64),Intent(In)::N
      character(len=*),optional,intent(in)::option
      Integer(kind=int64),Dimension(:),Intent(In)::I_Symm
      Integer(kind=int64),Dimension(N,N),Intent(Out)::I_Sq
!
      Integer(kind=int64)::i,j,k
      character(len=64)::myoption
!
!     Do the work...
!
      If(present(option)) then
        call string_change_case(option,'l',myOption)
      else
        myOption = 'symmetric'
      endIf

      k = N*(N+1)/2
      Do j = N,1,-1
        Do i = j,1,-1
          I_Sq(i,j) = I_Symm(k)
          if(myOption.eq.'symmetric'.or.myOption.eq.'hermitian') then
            I_Sq(j,i) = I_Symm(k)
          elseIf(myOption.eq.'antisymmetric'.or.myOption.eq.'antihermitian') then
            I_Sq(j,i) = (-1)*I_Symm(k)
          endIf
          k = k-1
        EndDo
      EndDo
!
      End Subroutine Matrix_Symm2Sq_Integer
!
!
!     PROCEDURE Matrix_Symm2Sq_Real
!
!>    \brief <b> Matrix_Symm2Sq_Real is a subroutine that converts a symmetric-
!>    packed intrinsic real matrix to a rank-2 intrinsic real array</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    Matrix_Symm2Sq_Real is a subroutine that converts a symmetric-packed 
!>    intrinsic real matrix to a rank-2 real array.The following options 
!>    are available:
!>      Option = 'symmetric' unpack matrix as symmetric.
!>      Option = 'antisymmetric' unpack matrix as antisymmetric.
!>      Option = 'hermitian' unpack matrix as hermitian.
!>      Option = 'antihermitian' unpack matrix as antihermitian.
!>    TODO: Move this routine to MQC general
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] N
!>    \verbatim
!>        N is Integer(kind=int64)
!>        The leading dimension of symmetric-packed matrix I_Symm.
!>        unpacked.
!>    \endverbatim
!>
!>    \param[in] A_Symm
!>    \verbatim
!>        A_Symm is Real(kind=real64),Dimension(:)
!>        The symmetric-packed intrinsic real matrix to be unpacked.
!>    \endverbatim
!>
!>    \param[out] A_Sq
!>    \verbatim
!>        A_Sq is Real(kind=real64),Dimension(N,N)
!>        The upacked intrinsic real matrix output.
!>    \endverbatim
!>
!>    \param[in] option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'symmetric':      Unpack matrix as symmetric
!>        = 'antisymmetric':  Unpack matrix as antisymmetric
!>        = 'hermitian':      Unpack matrix as hermitian
!>        = 'antihermitian':  Unpack matrix as antihermitian
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2017
!
      Subroutine Matrix_Symm2Sq_Real(N,A_Symm,A_Sq,option)
!
      Implicit None
      Integer(kind=int64),Intent(In)::N
      character(len=*),optional,intent(in)::option
      Real(kind=real64),Dimension(:),Intent(In)::A_Symm
      Real(kind=real64),Dimension(N,N),Intent(Out)::A_Sq
!
      Integer(kind=int64)::i,j,k
      character(len=64)::myoption
!
!     Do the work...
!
      If(present(option)) then
        call string_change_case(option,'l',myOption)
      else
        myOption = 'symmetric'
      endIf

      k = N*(N+1)/2
      Do j = N,1,-1
        Do i = j,1,-1
          A_Sq(i,j) = A_Symm(k)
          if(myOption.eq.'symmetric'.or.myOption.eq.'hermitian') then
            A_Sq(j,i) = A_Symm(k)
          elseIf(myOption.eq.'antisymmetric'.or.myOption.eq.'antihermitian') then
            A_Sq(j,i) = (-1)*A_Symm(k)
          endIf
          k = k-1
        EndDo
      EndDo
!
      End Subroutine Matrix_Symm2Sq_Real
!
!
!     PROCEDURE Matrix_Symm2Sq_Complex
!
!>    \brief <b> Matrix_Symm2Sq_Complex is a subroutine that converts a symmetric-
!>    packed intrinsic complex matrix to a rank-2 intrinsic complex array</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    Matrix_Symm2Sq_Complex is a subroutine that converts a symmetric-packed 
!>    intrinsic complex matrix to a rank-2 complex array.The following options 
!>    are available:
!>      Option = 'symmetric' unpack matrix as symmetric.
!>      Option = 'antisymmetric' unpack matrix as antisymmetric.
!>      Option = 'hermitian' unpack matrix as hermitian.
!>      Option = 'antihermitian' unpack matrix as antihermitian.
!>    TODO: Move this routine to MQC general
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] N
!>    \verbatim
!>        N is Integer(kind=int64)
!>        The leading dimension of symmetric-packed matrix I_Symm.
!>        unpacked.
!>    \endverbatim
!>
!>    \param[in] A_Symm
!>    \verbatim
!>        A_Symm is Complex(kind=real64),Dimension(:)
!>        The symmetric-packed intrinsic complex matrix to be 
!>        unpacked.
!>    \endverbatim
!>
!>    \param[out] A_Sq
!>    \verbatim
!>        A_Sq is Complex(kind=real64),Dimension(N,N)
!>        The upacked intrinsic complex matrix output.
!>    \endverbatim
!>
!>    \param[in] option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'symmetric':      Unpack matrix as symmetric
!>        = 'antisymmetric':  Unpack matrix as antisymmetric
!>        = 'hermitian':      Unpack matrix as hermitian
!>        = 'antihermitian':  Unpack matrix as antihermitian
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson 
!>    \date 2017
!
      Subroutine Matrix_Symm2Sq_Complex(N,A_Symm,A_Sq,option)
!
      Implicit None
      Integer(kind=int64),Intent(In)::N
      character(len=*),optional,intent(in)::option
      Complex(Kind=real64),Dimension(:),Intent(In)::A_Symm
      Complex(Kind=real64),Dimension(N,N),Intent(Out)::A_Sq
!
      Integer(kind=int64)::i,j,k
      character(len=64)::myoption
!
!     Do the work...
!
      k = N*(N+1)/2
      Do j = N,1,-1
        Do i = j,1,-1
          A_Sq(i,j) = A_Symm(k)
          if(myOption.eq.'symmetric') then
            A_Sq(j,i) = A_Symm(k)
          elseif(myOption.eq.'hermitian') then
            A_Sq(j,i) = conjg(A_Symm(k))
          elseIf(myOption.eq.'antisymmetric') then
            A_Sq(j,i) = (-1)*A_Symm(k)
          elseIf(myOption.eq.'antihermitian') then
            A_Sq(j,i) = (-1)*conjg(A_Symm(k))
          endIf
          k = k-1
        EndDo
      EndDo
!
      End Subroutine Matrix_Symm2Sq_Complex
!
!
!     PROCEDURE MQC_Vector2DiagMatrix
!
!>    \brief <b> MQC_Vector2DiagMatrix is a function that outputs a diagonal MQC 
!>    matrix with elements defined by an MQC vector</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Vector2DiagMatrix is a function that outputs a diagonal MQC matrix with
!>    elements defined by an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Vector
!>    \verbatim
!>        Vector is Class(MQC_Vector)
!>        MQC vector defining diagonal elements of output matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_Vector2DiagMatrix(vector) Result(matrix)
!
      Implicit None
      Type(MQC_Matrix)::matrix
      Class(MQC_Vector),Intent(In)::vector
!
      if (vector%Data_type.eq.'Real') then
        call mqc_allocate_matrix(vector%length,vector%length,matrix,'Real','StorDiag')
        matrix%matR(:,1) = vector%vecR
      elseif (vector%Data_type.eq.'Integer') then
        call mqc_allocate_matrix(vector%length,vector%length,matrix,'Integer','StorDiag')
        matrix%matI(:,1) = vector%vecI
      elseif (vector%Data_type.eq.'Complex') then
        call mqc_allocate_matrix(vector%length,vector%length,matrix,'Complex','StorDiag')
        matrix%matC(:,1) = vector%vecC
      endif
!
      End Function MQC_Vector2DiagMatrix
!
!
!     PROCEDURE MQC_MatrixMatrixSum
!
!>    \brief <b> MQC_MatrixMatrixSum is a function that sums two MQC matrices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixMatrixSum is a function that sums two MQC matrices.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MA
!>    \verbatim
!>        MA is Type(MQC_Matrix)
!>        First MQC matrix to sum.
!>    \endverbatim
!>
!>    \param[in] MB
!>    \verbatim
!>        MB is Type(MQC_Matrix)
!>        Second MQC matrix to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \author L. M. Thompson 
!>    \date 2017, 2018
!
      Function MQC_MatrixMatrixSum(MA,MB) Result(MC)
!
      implicit none
      type(MQC_Matrix),Intent(In)::MA,MB
      type(MQC_Matrix)::MC,Tmp1,Tmp2
      character(len=8)::storage
!
!
      Tmp1 = MA
      Tmp2 = MB
      select case(Tmp1%storage)
      case('StorFull')
        storage = 'StorFull'
        select case(Tmp2%storage)
        case('StorSymm','StorHerm','StorAsym','StorAhrm')
          call MQC_Matrix_Symm2Full(Tmp2)
        case('StorDiag')
          call MQC_Matrix_Diag2Full(Tmp2)
        case('StorFull')
          !-Empty Case-!
        case default
          call mqc_error_A('UNKOWN storage type in MQC_MatrixMatrixSum.', 6, &
               'Tmp2%storage', Tmp2%storage) 
        end select
      case('StorSymm','StorHerm','StorAsym','StorAhrm')
        if(Tmp2%storage.eq.'StorFull') then
          storage = 'StorFull'
          Call MQC_Matrix_Symm2Full(Tmp1)
        elseIf(Tmp2%storage.eq.'StorDiag') then
          storage = Tmp1%storage
          Call MQC_Matrix_Diag2Symm(Tmp2)
        elseIf(Tmp2%storage.ne.Tmp1%storage) then
          storage = 'StorFull'
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
        elseIf(Tmp2%storage.eq.Tmp1%storage) then
          storage = Tmp1%storage
        else
          call mqc_error_A('UNKOWN storage type in MQC_MatrixMatrixSum.', 6, &
               'Tmp2%storage', Tmp2%storage) 
        endIf
      case('StorDiag')
        select case(Tmp2%storage)
        case('StorFull')
          storage = 'StorFull'
          Call MQC_Matrix_Diag2Full(Tmp1)
        case('StorSymm','StorHerm','StorAsym','StorAhrm')
          storage = Tmp2%storage
          Call MQC_Matrix_Diag2Symm(Tmp1)
        case('StorDiag')
          storage = 'StorDiag'
        case default
          call mqc_error_A('UNKOWN storage type in MQC_MatrixMatrixSum.', 6, &
               'Tmp2%storage', Tmp2%storage) 
        end select
      case default
        call mqc_error_A('UNKNOWN storage type in MQC_MatrixMatrixSum.', 6, &
             'Tmp1%storage', Tmp1%storage) 
      end select
!
      select case(Tmp1%data_type)
      case('Real')
        select case(Tmp2%data_type)
        case('Real')
          MC = Tmp2
          MC%MatR = Tmp1%MatR + Tmp2%MatR
        case('Integer')
          MC = Tmp1
          MC%MatR = Tmp1%MatR + Tmp2%MatI
        case('Complex')
          MC = Tmp2
          MC%MatC = Tmp1%MatR + Tmp2%MatC
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSum.', 6, &
               'Tmp2%data_type', Tmp2%data_type) 
        end select
      case('Integer')
        select case(Tmp2%data_type)
        case('Real')
          MC = Tmp2
          MC%MatR = Tmp1%MatI + Tmp2%MatR
        case('Integer')
          MC = Tmp2
          MC%MatI = Tmp1%MatI + Tmp2%MatI
        case('Complex')
          MC = Tmp2
          MC%MatC = Tmp1%MatI + Tmp2%MatC
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSum.', 6, &
               'Tmp2%data_type', Tmp2%data_type) 
        end select
      case('Complex')
        select case(Tmp2%data_type)
        case('Real')
          MC = Tmp1
          MC%MatC = Tmp1%MatC + Tmp2%MatR
        case('Integer')
          MC = Tmp1
          MC%MatC = Tmp1%MatC + Tmp2%MatI
        case('Complex')
          MC = Tmp2
          MC%MatC = Tmp1%MatC + Tmp2%MatC
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSum.', 6, &
               'Tmp2%data_type', Tmp2%data_type) 
        end select
      case default
        call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSum.', 6, &
             'Tmp1%data_type', Tmp1%data_type) 
      end select
      MC%storage = storage
!
      return
      end function MQC_MatrixMatrixSum
!
!
!     PROCEDURE MQC_MatrixMatrixSubtract
!
!>    \brief <b> MQC_MatrixMatrixSubtract is a function that subtracts two MQC 
!>    matrices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixMatrixSubtract is a function that subtracts two MQC matrices.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MA
!>    \verbatim
!>        MA is Type(MQC_Matrix)
!>        The matrix that MB will be subtracted from.
!>    \endverbatim
!>
!>    \param[in] MB
!>    \verbatim
!>        MB is Type(MQC_Matrix)
!>        The matrix that will be subtracted from MA.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author H. P. Hratchian
!>    \date 2017
!
      Function MQC_MatrixMatrixSubtract(MA,MB) Result(MC)
!
      implicit none
      type(MQC_Matrix),Intent(In)::MA,MB
      type(MQC_Matrix)::MC,Tmp1,Tmp2
      character(len=8)::storage

      Tmp1 = MA
      Tmp2 = MB
      select case(Tmp1%storage)
      case('StorFull')
        storage = 'StorFull'
        select case(Tmp2%storage)
        case('StorSymm','StorHerm','StorAsym','StorAhrm')
          call MQC_Matrix_Symm2Full(Tmp2)
        case('StorDiag')
          call MQC_Matrix_Diag2Full(Tmp2)
        case('StorFull')
          !-Empty Case-!
        case default
          call mqc_error_A('UNKNOWN storage type in MQC_MatrixMatrixSubtract.', 6, &
               'Tmp2%storage', Tmp2%storage)
        end select
      case('StorSymm','StorHerm','StorAsym','StorAhrm')
        if(Tmp2%storage.eq.'StorFull') then
          storage = 'StorFull'
          call MQC_Matrix_Symm2Full(Tmp1)
        elseIf(Tmp2%storage.eq.'StorDiag') then
          storage = Tmp1%Storage
          call MQC_Matrix_Diag2Symm(Tmp2)
        elseIf(Tmp2%storage.ne.Tmp1%storage) then
          storage = 'StorFull'
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
        elseIf(Tmp2%storage.eq.Tmp1%storage) then
          storage = Tmp1%Storage
        else
          call mqc_error_A('UNKNOWN storage type in MQC_MatrixMatrixSubtract.', 6, &
               'Tmp2%storage', Tmp2%storage)
        endIf
      case('StorDiag')
        select case(Tmp2%storage)
        case('StorFull')
          storage = 'StorFull'
          call MQC_Matrix_Diag2Full(Tmp1)
        case('StorSymm','StorHerm','StorAsym','StorAhrm')
          storage = Tmp2%storage
          call MQC_Matrix_Diag2Symm(Tmp1)
        case('StorDiag')
          storage = 'StorDiag'
        case default
          call mqc_error_A('UNKNOWN storage type in MQC_MatrixMatrixSubtract.', 6, &
               'Tmp2%storage', Tmp2%storage)
        end select
      case default
        call mqc_error_A('UNKNOWN storage type in MQC_MatrixMatrixSubtract.', 6, &
             'Tmp1%storage', Tmp1%storage)
      end select
!     
!     Do the work.
!
      select case(Tmp1%data_type)
      case('Real')
        select case(Tmp2%data_type)
        case('Real')
          MC = Tmp2
          MC%MatR = Tmp1%MatR - Tmp2%MatR
        case('Integer')
          MC = Tmp1
          MC%MatR = Tmp1%MatR - Tmp2%MatI
        case('Complex')
          MC = Tmp2
          MC%MatC = Tmp1%MatR - Tmp2%MatC
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSubtract.', 6, &
               'Tmp2%data_type', Tmp2%data_type)
        end select
      case('Integer')
        select case(Tmp2%data_type)
        case('Real')
          MC = Tmp2
          MC%MatR = Tmp1%MatI - Tmp2%MatR
        case('Integer')
          MC = Tmp2
          MC%MatI = Tmp1%MatI - Tmp2%MatI
        case('Complex')
          MC = Tmp2
          MC%MatC = Tmp1%MatI - Tmp2%MatC
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSubtract.', 6, &
               'Tmp2%data_type', Tmp2%data_type)
        end select
      case('Complex')
        select case(Tmp2%data_type)
        case('Real')
          MC = Tmp1
          MC%MatC = Tmp1%MatC - Tmp2%MatR
        case('Integer')
          MC = Tmp1
          MC%MatC = Tmp1%MatC - Tmp2%MatI
        case('Complex')
          MC = Tmp2
          MC%MatC = Tmp1%MatC - Tmp2%MatC
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSubtract.', 6, &
               'Tmp2%data_type', Tmp2%data_type)
        end select
      case default
        call mqc_error_A('UNKNOWN matrix type in MQC_MatrixMatrixSubtract.', 6, &
             'Tmp1%data_type', Tmp1%data_type)
      end select
      MC%storage = storage
!
      return
      end function MQC_MatrixMatrixSubtract
!
!
!     PROCEDURE MQC_MatrixMatrixDotProduct
!
!>    \brief <b> MQC_MatrixMatrixDotProduct is a function that computes the inner
!>    product of two MQC matrices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixMatrixDotProduct is a function that computes the inner product of 
!>    two MQC matrices.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MA
!>    \verbatim
!>        MA is Type(MQC_Matrix)
!>        The first MQC matrix.
!>    \endverbatim
!>
!>    \param[in] MB
!>    \verbatim
!>        MB is Type(MQC_Matrix)
!>        The second MQC matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_MatrixMatrixDotProduct(MA,MB) Result(MC)
!
      Implicit None
      Type(MQC_Matrix),Intent(In)::MA,MB
      Type(MQC_Matrix)::MC
      Type(MQC_Matrix)::MAreal,MBreal,Tmp1,Tmp2
      integer(kind=int64)::i,j
 
      If (MA%NCol.eq.0.or.MB%NRow.eq.0) then
          Call MQC_Allocate_Matrix(0,0,MC,'Real','StorFull')
          return
      end if

      If (MA%NCol /= MB%NRow) call MQC_Error_I('The two matrices are not conformable for multiplication', 6, &
           'MA%NCol', MA%NCol, &
           'MB%NRow', MB%NRow )

      If (MQC_Matrix_HaveReal(MA) .and. MQC_Matrix_HaveReal(MB)) then
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          MC%MatR = MatMul(MA%MatR,MB%MatR)
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorSymm') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymm('r','L',MA%NRow,MB%NCol,1.0,Tmp1%MatR,MB%NRow,MA%MatR,MA%NRow,0, &
            MC%MatR,MC%NRow)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorSymm' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymm('l','L',MA%NRow,MB%NCol,1.0,Tmp1%MatR,MA%NRow,MB%MatR,MB%NRow,0, &
            MC%MatR,MC%NRow)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MB%NRow
            MC%matR(i,:) = MA%matR(i,1) * MB%matR(i,:)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorDiag')
          MC%matR = MA%matR * MB%matR
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NCol
            MC%matR(:,i) = MA%matR(:,i) * MB%matR(i,1)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorHerm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MB%NRow
            do j = 1, MB%NCol
              MC%matR(i,j) = MA%matR(i,1) * MB%matR(symIndexHash(i,j),1)
            enddo
          enddo
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorHerm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              MC%matR(i,j) = MA%matR(symIndexHash(i,j),1) * MB%matR(j,1)
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(MA%MatR,Tmp1%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm') .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(Tmp1%MatR,MB%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. & 
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          mc = matmul(Tmp1%MatR,Tmp2%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matR(i,j) = MA%matR(symIndexHash(i,j),1) * MB%matR(j,1)
              elseIf(j.gt.i) then
                MC%matR(i,j) = (-1)*MA%matR(symIndexHash(i,j),1) * MB%matR(j,1)
              endIf
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matR(i,j) = MA%matR(i,1) * MB%matR(symIndexHash(i,j),1) 
              elseIf(j.gt.i) then
                MC%matR(i,j) = MA%matR(i,1) * (-1)*MB%matR(symIndexHash(i,j),1)
              endIf
            enddo
          enddo
        EndIf
      ElseIf (MQC_Matrix_HaveReal(MA) .and. MQC_Matrix_HaveInteger(MB)) then
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          MC%MatR = MatMul(MA%MatR,MB%MatI)
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorSymm') then
          MBreal = MQC_Cast_Real(MB)
          Call MQC_Allocate_Matrix(MA%NRow,MBreal%NCol,MC,'Real','StorFull')
          Call MQC_Matrix_Symm2Full(MBreal)
          Call DSymm('r','L',MA%NRow,MBreal%NCol,1.0,MBreal%MatR,MBreal%NRow,MA%MatR, &
            MA%NRow,0,MC%MatR,MC%NRow)
        ElseIf (MA%Storage.eq.'StorSymm' .and. MBreal%Storage.eq.'StorFull') then
          MBreal = MQC_Cast_Real(MB)
          Call MQC_Allocate_Matrix(MA%NRow,MBreal%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymm('l','L',MA%NRow,MBreal%NCol,1.0,MA%MatR,MA%NRow,MBreal%MatR, &
            MBreal%NRow,0,MC%MatR,MC%NRow)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MB%NRow
            MC%matR(i,:) = MA%matR(i,1) * MB%matI(i,:)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorDiag')
          MC%matR = MA%matR * MB%matI
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NCol
            MC%matR(:,i) = MA%matR(:,i) * MB%matI(i,1)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorHerm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MB%NRow
            do j = 1, MB%NCol
              MC%matR(i,j) = MA%matR(i,1) * MB%matI(symIndexHash(i,j),1)
            enddo
          enddo
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorHerm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              MC%matR(i,j) = MA%matR(symIndexHash(i,j),1) * MB%matI(j,1)
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(MA%MatR,Tmp1%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm') .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(Tmp1%MatR,MB%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. & 
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          mc = matmul(Tmp1%MatR,Tmp2%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matR(i,j) = MA%matR(symIndexHash(i,j),1) * MB%matI(j,1)
              elseIf(j.gt.i) then
                MC%matR(i,j) = (-1)*MA%matR(symIndexHash(i,j),1) * MB%matI(j,1)
              endIf
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matR(i,j) = MA%matR(i,1) * MB%matI(symIndexHash(i,j),1) 
              elseIf(j.gt.i) then
                MC%matR(i,j) = MA%matR(i,1) * (-1)*MB%matI(symIndexHash(i,j),1)
              endIf
            enddo
          enddo
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MA) .and. MQC_Matrix_HaveReal(MB)) then
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Real','StorFull')
          MC%MatR = MatMul(MA%MatI,MB%MatR)
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorSymm') then
          MAreal = MQC_Cast_Real(MA)
          Call MQC_Allocate_Matrix(MAreal%nrow,MB%ncol,MC,'Real','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymm('r','L',MAreal%NRow,MB%NCol,1.0,Tmp1%MatR,MB%NRow,MAreal%MatR, &
            MAreal%NRow,0,MC%MatR,MC%NRow)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorSymm' .and. MB%Storage.eq.'StorFull') then
          MAreal = MQC_Cast_Real(MA)
          Call MQC_Allocate_Matrix(MAreal%nrow,MB%ncol,MC,'Real','StorFull')
          Call MQC_Matrix_Symm2Full(MAreal)
          Call DSymm('l','L',MAreal%NRow,MB%NCol,1.0,MAreal%MatR,MAreal%NRow,MB%MatR, &
            MB%NRow,0,MC%MatR,MC%NRow)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MB%NRow
            MC%matR(i,:) = MA%matI(i,1) * MB%matR(i,:)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorDiag')
          MC%matR = MA%matI * MB%matR
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NCol
            MC%matR(:,i) = MA%matI(:,i) * MB%matR(i,1)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorHerm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MB%NRow
            do j = 1, MB%NCol
              MC%matR(i,j) = MA%matI(i,1) * MB%matR(symIndexHash(i,j),1)
            enddo
          enddo
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorHerm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              MC%matR(i,j) = MA%matI(symIndexHash(i,j),1) * MB%matR(j,1)
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(MA%MatI,Tmp1%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm') .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(Tmp1%MatI,MB%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. & 
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          mc = matmul(Tmp1%MatI,Tmp2%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matR(i,j) = MA%matI(symIndexHash(i,j),1) * MB%matR(j,1)
              elseIf(j.gt.i) then
                MC%matR(i,j) = (-1)*MA%matI(symIndexHash(i,j),1) * MB%matR(j,1)
              endIf
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Real','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matR(i,j) = MA%matI(i,1) * MB%matR(symIndexHash(i,j),1) 
              elseIf(j.gt.i) then
                MC%matR(i,j) = MA%matI(i,1) * (-1)*MB%matR(symIndexHash(i,j),1)
              endIf
            enddo
          enddo
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MA) .and. MQC_Matrix_HaveInteger(MB)) then
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Integer','StorFull')
          MC%MatI = MatMul(MA%MatI,MB%MatI)
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorSymm') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Integer','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatI = MatMul(MA%MatI,Tmp1%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorSymm' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Integer','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatI = MatMul(Tmp1%MatI,MB%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          do i = 1, MB%NRow
            MC%matI(i,:) = MA%matI(i,1) * MB%matI(i,:)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorDiag')
          MC%matI = MA%matI * MB%matI
        ElseIf (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          do i = 1, MA%NCol
            MC%matI(:,i) = MA%matI(:,i) * MB%matI(i,1)
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorHerm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          do i = 1, MB%NRow
            do j = 1, MB%NCol
              MC%matI(i,j) = MA%matI(i,1) * MB%matI(symIndexHash(i,j),1)
            enddo
          enddo
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorHerm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              MC%matI(i,j) = MA%matI(symIndexHash(i,j),1) * MB%matI(j,1)
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(MA%MatI,Tmp1%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm') .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          mc = matmul(Tmp1%MatI,MB%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. & 
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          mc = matmul(Tmp1%MatI,Tmp2%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorAsym' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matI(i,j) = MA%matI(symIndexHash(i,j),1) * MB%matI(j,1)
              elseIf(j.gt.i) then
                MC%matI(i,j) = (-1)*MA%matI(symIndexHash(i,j),1) * MB%matI(j,1)
              endIf
            enddo
          enddo
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%NRow,MB%NCol,MC,'Integer','StorFull')
          do i = 1, MA%NRow
            do j = 1, MA%NCol
              if(i.ge.j) then
                MC%matI(i,j) = MA%matI(i,1) * MB%matI(symIndexHash(i,j),1) 
              elseIf(j.gt.i) then
                MC%matI(i,j) = MA%matI(i,1) * (-1)*MB%matI(symIndexHash(i,j),1)
              endIf
            enddo
          enddo
        EndIf
      ElseIf (MQC_Matrix_HaveComplex(MA) .and. MQC_Matrix_HaveInteger(MB)) then
        Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          MC%MatC = MatMul(MA%MatC,MB%MatI)
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(MA%MatC,Tmp1%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorFull'.and.MB%Storage.eq.'StorDiag') then
          Tmp1 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(MA%MatC,Tmp1%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatC,MB%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatC,MB%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        EndIf
      ElseIf (MQC_Matrix_HaveComplex(MA) .and. MQC_Matrix_HaveReal(MB)) then
        Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          MC%MatC = MatMul(MA%MatC,MB%MatR)
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(MA%MatC,Tmp1%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorFull'.and.MB%Storage.eq.'StorDiag') then
          Tmp1 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(MA%MatC,Tmp1%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatC,MB%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatC,MB%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MA) .and. MQC_Matrix_HaveComplex(MB)) then
        Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          MC%MatC = MatMul(MA%MatI,MB%MatC)
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(MA%MatI,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorFull'.and.MB%Storage.eq.'StorDiag') then
          Tmp1 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(MA%MatI,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatI,MB%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatI,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatI,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatI,MB%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatI,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatI,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        EndIf
      ElseIf (MQC_Matrix_HaveReal(MA) .and. MQC_Matrix_HaveComplex(MB)) then
        Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          MC%MatC = MatMul(MA%MatR,MB%MatC)
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(MA%MatR,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorFull'.and.MB%Storage.eq.'StorDiag') then
          Tmp1 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(MA%MatR,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatR,MB%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatR,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
            MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatR,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Tmp1 = MA
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatR,MB%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
            MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
            MA%Storage.eq.'StorAhrm')) then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatR,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatR,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        EndIf
      ElseIf (MQC_Matrix_HaveComplex(MA) .and. MQC_Matrix_HaveComplex(MB)) then
        If (MA%Storage.eq.'StorFull' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          MC%MatC = MatMul(MA%MatC,MB%MatC)
        ElseIf (MA%Storage.eq.'StorFull' .and. (MB%Storage.eq.'StorSymm' .or. &
          MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
          MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(MA%MatC,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorFull'.and.MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          Tmp1 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(MA%MatC,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
          MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
           MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatC,MB%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
          MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
          (MB%Storage.eq.'StorSymm' .or. MB%Storage.eq.'StorAsym' .or. &
          MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf ((MA%Storage.eq.'StorSymm' .or. MA%Storage.eq.'StorAsym' .or. &
          MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') .and. &
           MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call MQC_Matrix_Diag2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorFull') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          Tmp1 = MA
          Call MQC_Matrix_Diag2Full(Tmp1)
          MC%MatC = MatMul(Tmp1%MatC,MB%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        ElseIf (MA%Storage.eq.'StorDiag' .and. (MB%Storage.eq.'StorSymm' .or. &
          MB%Storage.eq.'StorAsym' .or. MB%Storage.eq.'StorHerm' .or. &
          MA%Storage.eq.'StorAhrm')) then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorFull')
          Tmp1 = MA
          Tmp2 = MB
          Call MQC_Matrix_Diag2Full(Tmp1)
          Call MQC_Matrix_Symm2Full(Tmp2)
          MC%MatC = MatMul(Tmp1%MatC,Tmp2%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
          Call MQC_Deallocate_Matrix(Tmp2)
        ElseIf (MA%Storage.eq.'StorDiag' .and. MB%Storage.eq.'StorDiag') then
          Call MQC_Allocate_Matrix(MA%nrow,MB%ncol,MC,'Complex','StorDiag')
          MC%MatC = MA%matC * MB%matC 
        EndIf
      EndIf

      End Function MQC_MatrixMatrixDotProduct
!
!
!     PROCEDURE MQC_MatrixVectorDotProduct
!
!>    \brief <b> MQC_MatrixVectorDotProduct is a function that computes the inner
!>    product of a MQC matrix and a MQC vector</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixVectorDotProduct is a function that computes the inner product of 
!>    a MQC matrix and a MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MA
!>    \verbatim
!>        MA is Type(MQC_Matrix)
!>        The MQC matrix multiply.
!>    \endverbatim
!>
!>    \param[in] VB
!>    \verbatim
!>        VB is Type(MQC_Vector)
!>        The MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_MatrixVectorDotProduct(MA,VB) Result(VC)
!
      Implicit None
      Type(MQC_Matrix),Intent(In)::MA
      Type(MQC_Vector),Intent(In)::VB
      Type(MQC_Vector)::VC,VBreal
      Type(MQC_Matrix)::MAreal,Tmp1
      Integer(kind=int64),Allocatable::Result(:,:)

      If (.not. VB%Column .or. MA%NCol /= VB%Length) then
        Call MQC_Error_I('Matrix and vector are not conformable for multiplication', 6, &
             'MA%NCol', MA%NCol, &
             'VB%Length', VB%Length)
      EndIf

      If (MQC_Matrix_HaveInteger(MA)) MAreal = MQC_Cast_Real(MA)
      If (MQC_Vector_HaveInteger(VB)) VBreal = MQC_Cast_Real(VB)
      If (MQC_Matrix_HaveReal(MA) .and. MQC_Vector_HaveReal(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Real')
        If (MA%Storage.eq.'StorFull') then
          Call DGemV('N',MA%NRow,MA%NCol,1.0,MA%MatR,MA%NRow,VB%VecR,1,0.0,VC%VecR,1)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymV('L',MA%NRow,1.0,Tmp1%MatR,MA%NRow,VB%VecR,1,0.0,VC%VecR,1)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecR = MA%matR(:,1) * VB%vecR
        EndIf
      ElseIf (MQC_Matrix_HaveReal(MA) .and. MQC_Vector_HaveInteger(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Real')
        If (MA%Storage.eq.'StorFull') then
          Call DGemV('N',MA%NRow,MA%NCol,1.0,MA%MatR,MA%NRow,VBreal%VecR,1,0.0,VC%VecR,1)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymV('L',MA%NRow,1.0,Tmp1%MatR,MA%NRow,VBreal%VecR,1,0.0,VC%VecR,1)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecR = MA%matR(:,1) * VB%vecI
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MA) .and. MQC_Vector_HaveReal(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Real')
        If (MA%Storage.eq.'StorFull') then
          Call DGemV('N',MA%NRow,MA%NCol,1.0,MAreal%MatR,MA%NRow,VB%VecR,1,0.0,VC%VecR,1)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Call MQC_Matrix_Symm2Full(MAreal)
          Call DSymV('L',MA%NRow,1.0,MAreal%MatR,MA%NRow,VB%VecR,1,0.0,VC%VecR,1)
          Call MQC_Matrix_Full2Symm(MAreal)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecR = MA%matI(:,1) * VB%vecR
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MA) .and. MQC_Vector_HaveInteger(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Integer')
        Allocate(Result(MA%NRow,1))
        If (MA%Storage.eq.'StorFull') then
          Result = MatMul(MA%MatI,Reshape(VB%VecI,[MA%NCol,1]))
          VC%VecI = Result(:,1)
          !call dgemv('N',MA%nrow,MA%ncol,1.0,MA%mati,MA%nrow,VB%veci,1,0.0,VC%veci,1)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          Result = MatMul(Tmp1%MatI,Reshape(VB%VecI,[MA%NCol,1]))
          Call MQC_Deallocate_Matrix(Tmp1)
          VC%VecI = Result(:,1)
          !call dsymv('L',MA%nrow,1.0,MQC_Matrix_Symm2Full_func(MA), &
           !MA%nrow,VB%veci,1,0.0,VC%veci,1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecI = MA%matI(:,1) * VB%vecI
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MA) .and. MQC_Vector_HaveComplex(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Complex')
        If (MA%Storage.eq.'StorFull') then
          VC%VecC = MatMul(MA%MatI,VB%VecC)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(Tmp1%MatI,VB%VecC)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecC = MA%matI(:,1) * VB%vecC
        EndIf
      ElseIf (MQC_Matrix_HaveReal(MA) .and. MQC_Vector_HaveComplex(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Complex')
        If (MA%Storage.eq.'StorFull') then
          VC%VecC = MatMul(MA%MatR,VB%VecC)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(Tmp1%MatR,VB%VecC)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecC = MA%matR(:,1) * VB%vecC
        EndIf
      ElseIf (MQC_Matrix_HaveComplex(MA) .and. MQC_Vector_HaveInteger(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Complex')
        If (MA%Storage.eq.'StorFull') then
          VC%VecC = MatMul(MA%MatC,VB%VecI)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(Tmp1%MatC,VB%VecI)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecC = MA%matC(:,1) * VB%vecI
        EndIf
      ElseIf (MQC_Matrix_HaveComplex(MA) .and. MQC_Vector_HaveReal(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Complex')
        If (MA%Storage.eq.'StorFull') then
          VC%VecC = MatMul(MA%MatC,VB%VecR)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(Tmp1%MatC,VB%VecR)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecC = MA%matC(:,1) * VB%vecR
        EndIf
      ElseIf (MQC_Matrix_HaveComplex(MA) .and. MQC_Vector_HaveComplex(VB)) then
        Call MQC_Allocate_Vector(MA%NRow,VC,'Complex')
        If (MA%Storage.eq.'StorFull') then
          VC%VecC = MatMul(MA%MatC,VB%VecC)
        ElseIf (MA%Storage.eq.'StorSymm'.or.MA%Storage.eq.'StorAsym' .or. &
            MA%Storage.eq.'StorHerm' .or. MA%Storage.eq.'StorAhrm') then
          Tmp1 = MA
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(Tmp1%MatC,VB%VecC)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MA%Storage.eq.'StorDiag') then
          VC%vecC = MA%matC(:,1) * VB%vecC
        EndIf
      EndIf

      End Function MQC_MatrixVectorDotProduct
!
!
!     PROCEDURE MQC_VectorMatrixDotProduct
!
!>    \brief <b> MQC_VectorMatrixDotProduct is a function that computes the inner
!>    product of a MQC vector and a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_VectorMatrixDotProduct is a function that computes the inner product of 
!>    a MQC vector and a MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] VA
!>    \verbatim
!>        VA is Type(MQC_Vector)
!>        The MQC vector to multiply.
!>    \endverbatim
!>
!>    \param[in] MB
!>    \verbatim
!>        MB is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_VectormatrixDotProduct(VA,MB) Result(VC)
!
      Implicit None
      Type(MQC_Matrix),Intent(In)::MB
      Type(MQC_Vector),Intent(In)::VA
      Type(MQC_Vector)::VC,VAreal
      Type(MQC_Matrix)::MBreal,Tmp1
      Integer(kind=int64),Allocatable::Result(:,:)

      If (VA%Column .or. VA%Length /= MB%NRow) then
        Call MQC_Error_i('Matrix and vector are not conformable for multiplication', 6, &
             'VA%Length', VA%Length, &
             'MB%NRow', MB%NRow)
      EndIf

      If (MQC_Matrix_HaveReal(MB) .and. MQC_Vector_HaveReal(VA)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Real')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          Call DGemV('T',MB%NRow,MB%NCol,1.0,MB%MatR,MB%NRow,VA%VecR,1,0.0,VC%VecR,1)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymV('L',MB%NRow,1.0,Tmp1%MatR,MB%NRow,VA%VecR,1,0.0,VC%VecR,1)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecR = MB%matR(:,1) * VA%vecR
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MB) .and. MQC_Vector_HaveReal(VA)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Real')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          Call DGemV('T',MB%NRow,MB%NCol,1.0,MBreal%MatR,MB%NRow,VA%VecR,1,0.0,VC%VecR,1)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Call MQC_Matrix_Symm2Full(MBreal)
          Call DSymV('L',MB%NRow,1.0,MBreal%MatR,MB%NRow,VA%VecR,1,0.0,VC%VecR,1)
          Call MQC_Matrix_Full2Symm(MBreal)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecR = MB%matI(:,1) * VA%vecR
        EndIf
      ElseIf (MQC_Matrix_HaveReal(MB) .and. MQC_Vector_HaveInteger(VA)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Real')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          Call DGemV('T',MB%nrow,MB%ncol,1.0,MB%matr,MB%nrow,VAreal%vecr,1,0.0,VC%vecr,1)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Call DSymV('L',MB%NRow,1.0,Tmp1%MatR,MB%NRow,VAreal%VecR,1,0.0,VC%VecR,1)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecR = MB%matR(:,1) * VA%vecI
        EndIf
      ElseIf (MQC_Matrix_HaveInteger(MB) .and. MQC_Vector_HaveInteger(VA)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Integer')
        VC = MQC_Vector_Transpose(VC)
        Allocate(Result(1,MB%NCol))
        If (MB%Storage.eq.'StorFull') then
          Result = MatMul(Reshape(VA%VecI,[1,MB%NRow]),MB%MatI)
          VC%VecI = Result(1,:)
          !call dgemv('T',MB%nrow,MB%ncol,1.0,MB%mati,MB%nrow,VA%veci,1,0.0,VC%veci,1)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          Result = MatMul(Reshape(VA%VecI,[1,MB%NRow]),Tmp1%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
          VC%VecI = Result(1,:)
          !call dsymv('L',MB%nrow,1.0,MQC_matrix_Symm2Full_func(MB), &
           !MB%nrow,VA%veci,1,0.0,VC%veci,1)
        elseif (MB%Storage.eq.'StorDiag') then
         VC%vecI = MB%matI(:,1) * VA%vecI
        EndIf
      ElseIf (MQC_Vector_HaveInteger(VA) .and. MQC_Matrix_HaveComplex(MB)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Complex')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          VC%VecC = MatMul(VA%VecI,MB%MatC)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(VA%VecI,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecC = VA%vecI * MB%matC(:,1) 
        EndIf
      ElseIf (MQC_Vector_HaveReal(VA) .and. MQC_Matrix_HaveComplex(MB)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Complex')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          VC%VecC = MatMul(VA%VecR,MB%MatC)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(VA%VecR,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecC = VA%VecR * MB%matC(:,1)
        EndIf
      ElseIf (MQC_Vector_HaveComplex(VA) .and. MQC_Matrix_HaveInteger(MB)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Complex')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          VC%VecC = MatMul(VA%VecC,MB%MatI)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(VA%VecC,Tmp1%MatI)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecC = VA%vecC * MB%matI(:,1) 
        EndIf
      ElseIf (MQC_Vector_HaveComplex(VA) .and. MQC_Matrix_HaveReal(MB)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Complex')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          VC%VecC = MatMul(VA%VecC,MB%MatR)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(VA%VecC,Tmp1%MatR)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecC = VA%VecC * MB%matR(:,1)
        EndIf
      ElseIf (MQC_Vector_HaveComplex(VA) .and. MQC_Matrix_HaveComplex(MB)) then
        Call MQC_Allocate_Vector(MB%NCol,VC,'Complex')
        VC = MQC_Vector_Transpose(VC)
        If (MB%Storage.eq.'StorFull') then
          VC%VecC = MatMul(VA%VecC,MB%MatC)
        ElseIf (MB%Storage.eq.'StorSymm'.or.MB%Storage.eq.'StorAsym' .or. &
            MB%Storage.eq.'StorHerm' .or. MB%Storage.eq.'StorAhrm') then
          Tmp1 = MB
          Call MQC_Matrix_Symm2Full(Tmp1)
          VC%VecC = MatMul(VA%VecC,Tmp1%MatC)
          Call MQC_Deallocate_Matrix(Tmp1)
        elseif (MB%Storage.eq.'StorDiag') then
          VC%vecC = VA%VecC * MB%matC(:,1)
        EndIf
      EndIf

      End Function MQC_VectorMatrixDotProduct
!
!
!     PROCEDURE MQC_MatrixScalarProduct
!
!>    \brief <b> MQC_MatrixScalarProduct is a function that computes the product of
!>    a MQC scalar and a MQC matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixScalarProduct is a function that computes the inner product of a MQC 
!>    scalar and a MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC scalar to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_MatrixScalarProduct(Matrix,Scalar) Result(Matrix_Res)
!
      Implicit None
      Type(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Integer',Matrix%Storage)
        Matrix_Res%MatI = Scalar%ScaI * Matrix%MatI
      ElseIf (Matrix%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = Scalar%ScaR * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = Scalar%ScaI * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = Scalar%ScaR * Matrix%MatR
      ElseIf (Matrix%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaC * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaC * Matrix%MatR
      ElseIf (Matrix%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaI * Matrix%MatC
      Else If (Matrix%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaR * Matrix%MatC
      Else If (Matrix%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaC * Matrix%MatC
      Else
        Call MQC_Error_A('unrecognised data type in mqc_matrixscalarproduct', 6, &
             'Matrix%Data_Type', Matrix%Data_Type, &
             'Scalar%Data_Type', Scalar%Data_Type )
     EndIf
     

      End Function MQC_MatrixScalarProduct
!
!
!     PROCEDURE MQC_ScalarMatrixProduct
!
!>    \brief <b> MQC_ScalarMatrixProduct is a function that computes the product of
!>    a MQC matrix and a MQC scalar</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarMatrixProduct is a function that computes the product of a MQC matrix
!>    and a MQC scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Type(MQC_Scalar)
!>        The MQC scalar to multiply.
!>    \endverbatim
!>
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2017
!
      Function MQC_ScalarMatrixProduct(Scalar,Matrix) Result(Matrix_Res)
!
      Implicit None
      Type(MQC_Scalar),Intent(In)::Scalar
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Integer',Matrix%Storage)
        Matrix_Res%MatI = Scalar%ScaI * Matrix%MatI
      ElseIf (Matrix%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = Scalar%ScaR * Matrix%MatI
      ElseIf (Matrix%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = Scalar%ScaI * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = Scalar%ScaR * Matrix%MatR
      ElseIf (Matrix%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaC * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaC * Matrix%MatR
      ElseIf (Matrix%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaI * Matrix%MatC
      Else If (Matrix%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaR * Matrix%MatC
      Else If (Matrix%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Scalar%ScaC * Matrix%MatC
      Else
        Call MQC_Error_A('unrecognised data type in mqc_matrixscalarproduct', 6, &
             'Matrix%Data_Type', Matrix%Data_Type, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf

      End Function MQC_ScalarMatrixProduct
!
!
!     PROCEDURE MQC_IntegerMatrixProduct
!
!>    \brief <b> MQC_IntegerMatrixProduct is a function that computes the product of
!>    a MQC matrix and an intrinsic integer</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_IntegerMatrixProduct is a function that computes the product of a MQC matrix
!>    and an intrinsic integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] IntIn
!>    \verbatim
!>        IntIn is Integer(kind=int64) 
!>        The intrinsic int to multiply.
!>    \endverbatim
!>
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_IntegerMatrixProduct(IntIn,Matrix) Result(Matrix_Res)
!
      Implicit None
      integer(kind=int64),Intent(In)::intin
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Integer',Matrix%Storage)
        Matrix_Res%MatR = IntIn * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = IntIn * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = IntIn * Matrix%MatC
      EndIf

      End Function MQC_IntegerMatrixProduct
!
!
!     PROCEDURE MQC_MatrixIntegerProduct
!
!>    \brief <b> MQC_MatrixIntegerProduct is a function that computes the product of
!>    a MQC matrix and an intrinsic integer</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixIntegerProduct is a function that computes the product of a MQC matrix
!>    and an intrinsic integer.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!>
!>    \param[in] IntIn 
!>    \verbatim
!>        IntIn is Integer(kind=int64) 
!>        The intrinsic integer to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_MatrixIntegerProduct(Matrix,IntIn) Result(Matrix_Res)
!
      Implicit None
      Integer(kind=int64),Intent(In)::IntIn
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Integer',Matrix%Storage)
        Matrix_Res%MatR = IntIn * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = IntIn * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = IntIn * Matrix%MatC
      EndIf

      End Function MQC_MatrixIntegerProduct
!
!
!     PROCEDURE MQC_RealMatrixProduct
!
!>    \brief <b> MQC_RealMatrixProduct is a function that computes the product of
!>    a MQC matrix and an intrinsic real</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_RealMatrixProduct is a function that computes the product of a MQC matrix
!>    and an intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RealIn 
!>    \verbatim
!>        RealIn is Real(kind=real64) 
!>        The intrinsic real to multiply.
!>    \endverbatim
!>
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_RealMatrixProduct(RealIn,Matrix) Result(Matrix_Res)
!
      Implicit None
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = RealIn * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = RealIn * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = RealIn * Matrix%MatC
      EndIf

      End Function MQC_RealMatrixProduct
!
!
!     PROCEDURE MQC_MatrixRealProduct
!
!>    \brief <b> MQC_MatrixRealProduct is a function that computes the product of
!>    a MQC matrix and an intrinsic real</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixRealProduct is a function that computes the product of a MQC matrix
!>    and an intrinsic real.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!>
!>    \param[in] RealIn 
!>    \verbatim
!>        RealIn is Real(kind=real64) 
!>        The intrinsic real to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_MatrixRealProduct(Matrix,RealIn) Result(Matrix_Res)
!
      Implicit None
      Real(kind=real64),Intent(In)::RealIn
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = RealIn * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Real',Matrix%Storage)
        Matrix_Res%MatR = RealIn * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = RealIn * Matrix%MatC
      EndIf

      End Function MQC_MatrixRealProduct
!
!
!     PROCEDURE MQC_ComplexMatrixProduct
!
!>    \brief <b> MQC_ComplexMatrixProduct is a function that computes the product of
!>    a MQC matrix and an intrinsic complex</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ComplexMatrixProduct is a function that computes the product of a MQC matrix
!>    and an intrinsic complex.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Comp
!>    \verbatim
!>        Comp is Complex(kind=real64) 
!>        The intrinsic complex to multiply.
!>    \endverbatim
!>
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_ComplexMatrixProduct(Comp,Matrix) Result(Matrix_Res)
!
      Implicit None
      Complex(kind=real64),Intent(In)::Comp
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Comp * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Comp * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Comp * Matrix%MatC
      EndIf

      End Function MQC_ComplexMatrixProduct
!
!
!     PROCEDURE MQC_MatrixComplexProduct
!
!>    \brief <b> MQC_MatrixComplexProduct is a function that computes the product of
!>    a MQC matrix and an intrinsic complex</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixComplexProduct is a function that computes the product of a MQC matrix
!>    and an intrinsic complex.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to multiply.
!>    \endverbatim
!>
!>    \param[in] Comp 
!>    \verbatim
!>        Comp is Complex(kind=real64) 
!>        The intrinsic complex to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_MatrixComplexProduct(Matrix,Comp) Result(Matrix_Res)
!
      Implicit None
      Complex(kind=real64),Intent(In)::Comp
      Type(MQC_Matrix),Intent(In)::Matrix
      Type(MQC_Matrix)::Matrix_Res

      Call MQC_Deallocate_Matrix(Matrix_Res)
      If (Matrix%Data_Type.eq.'Integer') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Comp * Matrix%MatI
      Else If (Matrix%Data_Type.eq.'Real') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Comp * Matrix%MatR
      Else If (Matrix%Data_Type.eq.'Complex') then
        Call MQC_Allocate_Matrix(Matrix%NRow,Matrix%NCol,Matrix_Res,'Complex',Matrix%Storage)
        Matrix_Res%MatC = Comp * Matrix%MatC
      EndIf

      End Function MQC_MatrixComplexProduct
!
!
!     PROCEDURE MQC_MatrixScalarDivide
!
!>    \brief <b> MQC_MatrixScalarDivide is a function that returns a MQC matrix
!>    divided by a MQC scalar</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_MatrixScalarDivide is a function that returns a MQC matrix divided by a 
!>    MQC scalar.  
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC_Matrix to divide.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC_Scalar to divide by.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_MatrixScalarDivide(matrix,scalarIn) Result(matrix_res)
!
      implicit none
      type(mqc_matrix),intent(in)::matrix
      class(*),intent(in)::scalarIn
      type(mqc_scalar)::scalar
      type(mqc_matrix)::matrix_res
      type(mqc_scalar)::zero,neg_one,reciprocal

      select type (scalarIn)
      type is (integer)
        scalar = scalarIn
      type is (real)
        scalar = scalarIn
      type is (complex)
        scalar = scalarIn
      type is (mqc_scalar)
        scalar = scalarIn
      class default
        call mqc_error('ScalarIn data type not recognized in MQC_MatrixScalarDivide')
      end select

      zero = 0.0
      neg_one = -1.0

      if(scalar%abs() .le. zero) then 
        call mqc_error_a('Cannot divide by zero:', 6)
      else
        reciprocal = scalar
        reciprocal = reciprocal ** neg_one
      endif

      matrix_res = MQC_MatrixScalarProduct(matrix,reciprocal)

      End Function MQC_MatrixScalarDivide
!
!
!     PROCEDURE MQC_Matrix_Matrix_Contraction
!
!>    \brief <b> MQC_Matrix_Matrix_Contraction is a function that returns the 
!>    contraction of two MQC matrices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Matrix_Contraction is a function that returns the contraction of two 
!>    MQC matrices.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix1
!>    \verbatim
!>        Matrix1 is Type(MQC_Matrix)
!>        The first MQC matrix to contract.
!>    \endverbatim
!>
!>    \param[in] Matrix2
!>    \verbatim
!>        Matrix2 is Type(MQC_Matrix)
!>        The second MQC matrix to contract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Function MQC_Matrix_Matrix_Contraction(Matrix1,Matrix2) Result(Contraction)
!
!     Variable Declarations.
!
      Implicit None
      Type(MQC_Matrix),Intent(In)::Matrix1,Matrix2
      Type(MQC_Scalar)::Contraction
      Integer(kind=int64)::N,M,i,j
!
      Contraction = 0.0
      N = Min(MQC_Matrix_Rows(Matrix1),MQC_Matrix_Rows(Matrix2))
      M = Min(MQC_Matrix_Columns(Matrix1),MQC_Matrix_Columns(Matrix2))
      Do i = 1,N
        Do j = 1,M
          Contraction = Contraction + Matrix1%at(i,j)*Matrix2%at(i,j)
        EndDo
      EndDo
!
      End Function MQC_Matrix_Matrix_Contraction
!
!
!     PROCEDURE MQC_Matrix_Scalar_Put_Scalar
!
!>    \brief <b> MQC_Matrix_Scalar_Put_Scalar is a subroutine that updates the value 
!>    of the (i,j)th element of a MQC matrix in which the indices are specified as
!>    MQC Scalars</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_Put_Scalar is a subroutine that updates the value of the 
!>    (i,j)th element of a MQC matrix in which the indices are specifed as MQC 
!>    Scalars. If the location of an element is negative then it is counted from the 
!>    end of the MQC matrix row/column. The following options are available: 
!>
!>    1. Option = 'element' adds scalar into specified element only (default).
!>    2. Option = 'symmetric' adds scalar symmetrically.
!>    3. Option = 'antisymmetric' adds scalar antisymmetrically.
!>    4. Option = 'hermitian' adds scalar hermitianally.
!>    5. Option = 'antihermitian' adds scalar antihermitianally.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to update at the (i,j)th element.
!>    \endverbatim
!>
!>    \param[in] ScalarIn 
!>    \verbatim
!>        ScalarIn is Class(*)
!>        The value to update the (i,j)th element of Matrix.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Type(MQC_Scalar) 
!>        The location of the row element in Matrix to update. If 
!>        I is negative it is counted from the last element of 
!>        Matrix. 
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Type(MQC_Scalar) 
!>        The location of the column element in Matrix to update. 
!>        If J is negative it is counted from the last element of 
!>        Matrix.
!>    \endverbatim
!>    
!>    \param[in] Option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'element':       add scalar into specified element 
!>                           only (default)
!>        = 'symmetric':     add scalar symmetrically
!>        = 'antisymmetric': add scalar antisymmetrically
!>        = 'hermitian':     add scalar hermitianally
!>        = 'antihermitian': add scalar antihermitianally.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Recursive Subroutine MQC_Matrix_Scalar_Put_Scalar(Matrix,ScalarIn,I,J,Option)
!
!     Variable Declarations.
!
      Implicit None
      Type(MQC_Scalar),Intent(in)::I,J
      Class(MQC_Matrix),Intent(InOut)::Matrix
      Class(*),Intent(In)::ScalarIn
      Character(len=*),Optional,Intent(In)::Option
      Integer(kind=int64)::IndI,IndJ
      Character(len=64)::myOption

      IndI = I
      IndJ = J
      Call MQC_Matrix_Scalar_Put_Int(Matrix,ScalarIn,IndI,IndJ,Option)

      End Subroutine MQC_Matrix_Scalar_Put_Scalar
!
!
!     PROCEDURE MQC_Matrix_Scalar_Put_ScaInt
!
!>    \brief <b> MQC_Matrix_Scalar_Put_ScaInt is a subroutine that updates the value 
!>    of the (i,j)th element of a MQC matrix in which the indices are specified as
!>    a MQC Scalar and integer</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_Put_ScaInt is a subroutine that updates the value of the 
!>    (i,j)th element of a MQC matrix in which the indices are specifed as a MQC 
!>    Scalar and integer. If the location of an element is negative then it is 
!>    counted from the end of the MQC matrix row/column. The following options are 
!>    available: 
!>
!>    1. Option = 'element' adds scalar into specified element only (default).
!>    2. Option = 'symmetric' adds scalar symmetrically.
!>    3. Option = 'antisymmetric' adds scalar antisymmetrically.
!>    4. Option = 'hermitian' adds scalar hermitianally.
!>    5. Option = 'antihermitian' adds scalar antihermitianally.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to update at the (i,j)th element.
!>    \endverbatim
!>
!>    \param[in] ScalarIn 
!>    \verbatim
!>        ScalarIn is Class(*)
!>        The value to update the (i,j)th element of Matrix.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Type(MQC_Scalar) 
!>        The location of the row element in Matrix to update. If 
!>        I is negative it is counted from the last element of 
!>        Matrix. 
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Integer
!>        The location of the column element in Matrix to update. 
!>        If J is negative it is counted from the last element of 
!>        Matrix.
!>    \endverbatim
!>    
!>    \param[in] Option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'element':       add scalar into specified element 
!>                           only (default)
!>        = 'symmetric':     add scalar symmetrically
!>        = 'antisymmetric': add scalar antisymmetrically
!>        = 'hermitian':     add scalar hermitianally
!>        = 'antihermitian': add scalar antihermitianally.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Recursive Subroutine MQC_Matrix_Scalar_Put_ScaInt(Matrix,ScalarIn,I,J,Option)
!
!     Variable Declarations.
!
      Implicit None
      Type(MQC_Scalar),Intent(in)::I
      Integer,Intent(in)::J
      Class(MQC_Matrix),Intent(InOut)::Matrix
      Class(*),Intent(In)::ScalarIn
      Character(len=*),Optional,Intent(In)::Option
      Integer(kind=int64)::IndI,IndJ
      Character(len=64)::myOption

      IndI = I
      IndJ = J
      Call MQC_Matrix_Scalar_Put_Int(Matrix,ScalarIn,IndI,IndJ,Option)

      End Subroutine MQC_Matrix_Scalar_Put_ScaInt
!
!
!     PROCEDURE MQC_Matrix_Scalar_Put_IntSca
!
!>    \brief <b> MQC_Matrix_Scalar_Put_IntSca is a subroutine that updates the value 
!>    of the (i,j)th element of a MQC matrix in which the indices are specified as an
!>    integer and a MQC Scalar</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_Put_IntSca is a subroutine that updates the value of the 
!>    (i,j)th element of a MQC matrix in which the indices are specifed as an integer
!>    and a MQC Scalar. If the location of an element is negative then it is counted 
!>    from the end of the MQC matrix row/column. The following options are available: 
!>
!>    1. Option = 'element' adds scalar into specified element only (default).
!>    2. Option = 'symmetric' adds scalar symmetrically.
!>    3. Option = 'antisymmetric' adds scalar antisymmetrically.
!>    4. Option = 'hermitian' adds scalar hermitianally.
!>    5. Option = 'antihermitian' adds scalar antihermitianally.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to update at the (i,j)th element.
!>    \endverbatim
!>
!>    \param[in] ScalarIn 
!>    \verbatim
!>        ScalarIn is Class(*)
!>        The value to update the (i,j)th element of Matrix.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer 
!>        The location of the row element in Matrix to update. If 
!>        I is negative it is counted from the last element of 
!>        Matrix. 
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Type(MQC_Scalar) 
!>        The location of the column element in Matrix to update. 
!>        If J is negative it is counted from the last element of 
!>        Matrix.
!>    \endverbatim
!>    
!>    \param[in] Option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'element':       add scalar into specified element 
!>                           only (default)
!>        = 'symmetric':     add scalar symmetrically
!>        = 'antisymmetric': add scalar antisymmetrically
!>        = 'hermitian':     add scalar hermitianally
!>        = 'antihermitian': add scalar antihermitianally.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Recursive Subroutine MQC_Matrix_Scalar_Put_IntSca(Matrix,ScalarIn,I,J,Option)
!
!     Variable Declarations.
!
      Implicit None
      Integer,Intent(in)::I
      Type(MQC_Scalar),Intent(in)::J
      Class(MQC_Matrix),Intent(InOut)::Matrix
      Class(*),Intent(In)::ScalarIn
      Character(len=*),Optional,Intent(In)::Option
      Integer(kind=int64)::IndI,IndJ
      Character(len=64)::myOption

      IndI = I
      IndJ = J
      Call MQC_Matrix_Scalar_Put_Int(Matrix,ScalarIn,IndI,IndJ,Option)

      End Subroutine MQC_Matrix_Scalar_Put_IntSca
!
!
!     PROCEDURE MQC_Matrix_Scalar_Put_Int
!
!>    \brief <b> MQC_Matrix_Scalar_Put_Int is a subroutine that updates the value of 
!>    the (i,j)th element of a MQC matrix with indicies specified as integers</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Scalar_Put_Int is a subroutine that updates the value of the (i,j)th 
!>    element of a MQC matrix with indicies specified as integers. If the location of 
!>    an element is negative then it is counted from the end of the MQC matrix 
!>    row/column. The following options are available: 
!>
!>    1. Option = 'element' adds scalar into specified element only (default).
!>    2. Option = 'symmetric' adds scalar symmetrically.
!>    3. Option = 'antisymmetric' adds scalar antisymmetrically.
!>    4. Option = 'hermitian' adds scalar hermitianally.
!>    5. Option = 'antihermitian' adds scalar antihermitianally.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Type(MQC_Matrix)
!>        The MQC matrix to update at the (i,j)th element.
!>    \endverbatim
!>
!>    \param[in] ScalarIn 
!>    \verbatim
!>        ScalarIn is Class(*)
!>        The value to update the (i,j)th element of Matrix.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer
!>        The location of the row element in Matrix to update. If 
!>        I is negative it is counted from the last element of 
!>        Matrix. 
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Integer
!>        The location of the column element in Matrix to update. 
!>        If J is negative it is counted from the last element of 
!>        Matrix.
!>    \endverbatim
!>    
!>    \param[in] Option
!>    \verbatim
!>        Option is Character(len=*),Optional
!>        = 'element':       add scalar into specified element 
!>                           only (default)
!>        = 'symmetric':     add scalar symmetrically
!>        = 'antisymmetric': add scalar antisymmetrically
!>        = 'hermitian':     add scalar hermitianally
!>        = 'antihermitian': add scalar antihermitianally.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Recursive Subroutine MQC_Matrix_Scalar_Put_Int(Matrix,ScalarIn,I,J,Option)
!
!     Variable Declarations.
!
      Implicit None
      Integer,Intent(in)::I,J
      Class(MQC_Matrix),Intent(InOut)::Matrix
      Class(*),Intent(In)::ScalarIn
      Character(len=*),Optional,Intent(In)::Option
      Type(MQC_Scalar)::Scalar
      Integer(kind=int64)::IndI,IndJ
      Character(len=64)::myOption

      If(Present(Option)) then
        call string_change_case(Option,'l',myOption)
      else
        myOption = 'element'
      endIf
      If(myOption.ne.'element'.and.myOption.ne.'symmetric'.and.myOption.ne.'antisymmetric'.and. &
        myOption.ne.'hermitian'.and.myOption.ne.'antihermitian') call mqc_error_a('Unrecognized &
        & option in MQC_Matrix_Scalar_Put',6,'myOption',myOption)

      IndI = I
      IndJ = J

      Select Type (ScalarIn)
      Type Is (Integer)
        Scalar = ScalarIn
      Type Is (Real)
        Scalar = ScalarIn
      Type Is (Complex)
        Scalar = ScalarIn
      Type Is (MQC_Scalar)
        Scalar = ScalarIn
      Class Default
        Call MQC_Error_I('ScalarIn type not defined in MQC_Matrix_Scalar_Put',6)
      End Select

      If (IndI.lt.0) IndI = Matrix%NRow + IndI + 1
      If (IndJ.lt.0) IndJ = Matrix%NCol + IndJ + 1
      If (IndI.eq.0.or.IndI.gt.Matrix%NRow) Call MQC_Error_I('Index I badly specified in mqc_matrix_scalar_put', 6, &
           'IndI', IndI, &
           'Matrix%NRow', Matrix%NRow )
      If (IndJ.eq.0.or.IndJ.gt.Matrix%NCol) Call MQC_Error_I('Index J badly specified in mqc_matrix_scalar_put', 6, &
           'IndJ', IndJ, &
           'Matrix%NCol', Matrix%NCol )
      If (Matrix%Storage.eq.'StorFull') then 
        If (Matrix%Data_Type.eq.'Integer') then
          If (Scalar%Data_Type.eq.'Integer') then
            Matrix%MatI(IndI,IndJ) = Scalar%ScaI
          ElseIf (Scalar%Data_Type.eq.'Real') then
            Call MQC_Matrix_Copy_Int2Real(Matrix)
            Matrix%MatR(IndI,IndJ) = Scalar%ScaR
          ElseIf (Scalar%Data_Type.eq.'Complex') then
            Call MQC_Matrix_Copy_Int2Complex(Matrix)
            Matrix%MatC(IndI,IndJ) = Scalar%ScaC
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                'Scalar%Data_Type', Scalar%Data_Type ) 
          EndIf
        ElseIf (Matrix%Data_Type.eq.'Real') then
          If (Scalar%Data_Type.eq.'Integer') then
            Matrix%MatR(IndI,IndJ) = Scalar%ScaI
          ElseIf (Scalar%Data_Type.eq.'Real') then
            Matrix%MatR(IndI,IndJ) = Scalar%ScaR
          ElseIf (Scalar%Data_Type.eq.'Complex') then
            Call MQC_Matrix_Copy_Real2Complex(Matrix)
            Matrix%MatC(IndI,IndJ) = Scalar%ScaC
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                'Scalar%Data_Type', Scalar%Data_Type ) 
          EndIf
        ElseIf (Matrix%Data_Type.eq.'Complex') then
          If (Scalar%Data_Type.eq.'Integer') then
            Matrix%MatC(IndI,IndJ) = Scalar%ScaI
          ElseIf (Scalar%Data_Type.eq.'Real') then
            Matrix%MatC(IndI,IndJ) = Scalar%ScaR
          ElseIf (Scalar%Data_Type.eq.'Complex') then
            Matrix%MatC(IndI,IndJ) = Scalar%ScaC
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                 'Scalar%Data_Type', Scalar%Data_Type ) 
          EndIf
        Else
          Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_Put', 6, &
               'Matrix%Data_Type', Matrix%Data_Type )
        EndIf
        If(myOption.eq.'symmetric') then
          call Matrix%put(scalar,IndJ,IndI)
        elseIf(myOption.eq.'antisymmetric') then
          call Matrix%put((-1)*scalar,IndJ,IndI)
        elseIf(myOption.eq.'hermitian') then
          call Matrix%put(conjg(scalar),IndJ,IndI)
        elseIf(myOption.eq.'antihermitian') then
          call Matrix%put((-1)*conjg(scalar),IndJ,IndI)
        endIf
      ElseIf (Matrix%Storage.eq.'StorSymm' .or. Matrix%Storage.eq.'StorAsym' .or. &
          Matrix%Storage.eq.'StorHerm' .or. Matrix%Storage.eq.'StorAhrm') then 
        If(((IndI.ne.IndJ).and.(myOption.eq.'symmetric'.and.Matrix%Storage.ne.'StorSymm')).or. &
          ((IndI.ne.IndJ).and.(myOption.eq.'antisymmetric'.and.Matrix%Storage.ne.'StorAsym')).or. &
          ((IndI.ne.IndJ).and.(myOption.eq.'hermitian'.and.Matrix%Storage.ne.'StorHerm')).or. &
          ((IndI.ne.IndJ).and.(myOption.eq.'antihermitian'.and.Matrix%Storage.ne.'StorAhrm')).or. &
          ((IndI.ne.IndJ).and.(myOption.eq.'element'))) then
          call mqc_matrix_symm2full(Matrix)
          call Matrix%put(scalar,IndI,IndJ)
          If(myOption.eq.'symmetric') then
            call Matrix%put(scalar,IndJ,IndI)
          elseIf(myOption.eq.'antisymmetric') then
            call Matrix%put((-1)*scalar,IndJ,IndI)
          elseIf(myOption.eq.'hermitian') then
            call Matrix%put(conjg(scalar),IndJ,IndI)
          elseIf(myOption.eq.'antihermitian') then
            call Matrix%put((-1)*conjg(scalar),IndJ,IndI)
          endIf
        Else
          If (Matrix%Data_Type.eq.'Integer') then
            If (Scalar%Data_Type.eq.'Integer') then
              Matrix%MatI(symIndexHash(IndI,IndJ),1) = Scalar%ScaI
            ElseIf (Scalar%Data_Type.eq.'Real') then
              Call MQC_Matrix_Copy_Int2Real(Matrix)
              Matrix%MatR(symIndexHash(IndI,IndJ),1) = Scalar%ScaR
            ElseIf (Scalar%Data_Type.eq.'Complex') then
              Call MQC_Matrix_Copy_Int2Complex(Matrix)
              Matrix%MatC(symIndexHash(IndI,IndJ),1) = Scalar%ScaC
            Else
              Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                  'Scalar%Data_Type', Scalar%Data_Type ) 
            EndIf
          ElseIf (Matrix%Data_Type.eq.'Real') then
            If (Scalar%Data_Type.eq.'Integer') then
              Matrix%MatR(symIndexHash(IndI,IndJ),1) = Scalar%ScaI
            ElseIf (Scalar%Data_Type.eq.'Real') then
              Matrix%MatR(symIndexHash(IndI,IndJ),1) = Scalar%ScaR
            ElseIf (Scalar%Data_Type.eq.'Complex') then
              Call MQC_Matrix_Copy_Real2Complex(Matrix)
              Matrix%MatC(symIndexHash(IndI,IndJ),1) = Scalar%ScaC
            Else
              Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                  'Scalar%Data_Type', Scalar%Data_Type ) 
            EndIf
          ElseIf (Matrix%Data_Type.eq.'Complex') then
            If (Scalar%Data_Type.eq.'Integer') then
              Matrix%MatC(symIndexHash(IndI,IndJ),1) = Scalar%ScaI
            ElseIf (Scalar%Data_Type.eq.'Real') then
              Matrix%MatC(symIndexHash(IndI,IndJ),1) = Scalar%ScaR
            ElseIf (Scalar%Data_Type.eq.'Complex') then
              Matrix%MatC(symIndexHash(IndI,IndJ),1) = Scalar%ScaC
            Else
              Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                   'Scalar%Data_Type', Scalar%Data_Type ) 
            EndIf
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_Put', 6, &
                 'Matrix%Data_Type', Matrix%Data_Type )
          EndIf
        EndIf
      ElseIf (Matrix%Storage.eq.'StorDiag') then
        If((IndI.ne.IndJ).and.(myOption.eq.'symmetric'.or.myOption.eq.'antisymmetric'.or. &
          myOption.eq.'hermitian'.or.myOption.eq.'antihermitian'.or.myOption.eq.'element')) then
          If(myOption.eq.'element') then
            call mqc_matrix_diag2full(Matrix)
            call Matrix%put(scalar,IndI,IndJ)
          elseIf(myOption.eq.'symmetric') then
            call mqc_matrix_diag2symm(Matrix,'symmetric')
            call Matrix%put(scalar,IndI,IndJ,'symmetric')
          elseIf(myOption.eq.'antisymmetric') then
            call mqc_matrix_diag2symm(Matrix,'antisymmetric')
            call Matrix%put(scalar,IndI,IndJ,'antisymmetric')
          elseIf(myOption.eq.'hermitian') then
            call mqc_matrix_diag2symm(Matrix,'hermitian')
            call Matrix%put(scalar,IndI,IndJ,'hermitian')
          elseIf(myOption.eq.'antihermitian') then
            call mqc_matrix_diag2symm(Matrix,'antihermitian')
            call Matrix%put(scalar,IndI,IndJ,'antihermitian')
          endIf
        Else
          If (Matrix%Data_Type.eq.'Integer') then
            If (Scalar%Data_Type.eq.'Integer') then
              Matrix%MatI(IndI,1) = Scalar%ScaI
            ElseIf (Scalar%Data_Type.eq.'Real') then
              Call MQC_Matrix_Copy_Int2Real(Matrix)
              Matrix%MatR(IndI,1) = Scalar%ScaR
            ElseIf (Scalar%Data_Type.eq.'Complex') then
              Call MQC_Matrix_Copy_Int2Complex(Matrix)
              Matrix%MatC(IndI,1) = Scalar%ScaC
            Else
              Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                  'Scalar%Data_Type', Scalar%Data_Type ) 
            EndIf
          ElseIf (Matrix%Data_Type.eq.'Real') then
            If (Scalar%Data_Type.eq.'Integer') then
              Matrix%MatR(IndI,1) = Scalar%ScaI
            ElseIf (Scalar%Data_Type.eq.'Real') then
              Matrix%MatR(IndI,1) = Scalar%ScaR
            ElseIf (Scalar%Data_Type.eq.'Complex') then
              Call MQC_Matrix_Copy_Real2Complex(Matrix)
              Matrix%MatC(IndI,1) = Scalar%ScaC
            Else
              Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                  'Scalar%Data_Type', Scalar%Data_Type ) 
            EndIf
          ElseIf (Matrix%Data_Type.eq.'Complex') then
            If (Scalar%Data_Type.eq.'Integer') then
              Matrix%MatC(IndI,1) = Scalar%ScaI
            ElseIf (Scalar%Data_Type.eq.'Real') then
              Matrix%MatC(IndI,1) = Scalar%ScaR
            ElseIf (Scalar%Data_Type.eq.'Complex') then
              Matrix%MatC(IndI,1) = Scalar%ScaC
            Else
              Call MQC_Error_A('Scalar type not defined in MQC_Matrix_Scalar_Put', 6, &
                   'Scalar%Data_Type', Scalar%Data_Type ) 
            EndIf
          Else
            Call MQC_Error_A('Matrix type not defined in MQC_Matrix_Scalar_Put', 6, &
                 'Matrix%Data_Type', Matrix%Data_Type )
          EndIf
        EndIf
      Else
        Call MQC_Error_A('Storage type not defined in MQC_Matrix_Scalar_Put', 6, &
             'Matrix%Storage', Matrix%Storage )
      EndIf

      End Subroutine MQC_Matrix_Scalar_Put_Int
!
!
!     PROCEDURE MQC_Matrix_Initialize
!
!>    \brief <b> MQC_Matrix_Initialize is a subroutine that initializes an MQC matrix
!>    with each element equal to a chosen value</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Initialize is a subroutine that initializes an MQC matrix with each 
!>    element equal to a chosen value. Optional argument Scalar determines the value
!>    of each element, with the default equal to zero. Optional argument Storage 
!>    determines the initial packing of MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix to initialize.
!>    \endverbatim
!>
!>    \param[in] Rows 
!>    \verbatim
!>        Rows is Integer(kind=int64)
!>        The number of rows to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] Columns
!>    \verbatim
!>        Columns is Integer(kind=int64)
!>        The number of columns to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        The value to set each element of Matrix.
!>    \endverbatim
!>
!>    \param[in] Storage
!>    \verbatim
!>        Storage is Character(Len=*),Optional
!>        The initial packing of Matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Initialize(Matrix,Rows,Columns,Scalar,Storage)
!
!     Variable Declarations.
!
      Implicit None
      Real(kind=real64)::Zero=0.0d0
      Integer(kind=int64),Intent(in)::Rows,Columns
      Class(*),Optional::Scalar
      Character(Len=*),Intent(in),OPTIONAL::Storage
      Class(MQC_Matrix),Intent(InOut)::Matrix
      Character(Len=64)::myStorage
!
      if(Present(Storage)) then
        myStorage = TRIM(Storage)
      else
        myStorage = 'StorFull'
      endIf
!
      If(Present(Scalar)) then
        Select Type (Scalar)
        Type is (Integer)
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Integer',TRIM(myStorage))
            Matrix%MatI = Scalar
        Type is (Real)
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Real',TRIM(myStorage))
            Matrix%MatR = Scalar
        Type is (Complex(Kind=real64))
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Complex',TRIM(myStorage))
            Matrix%MatC = Scalar
        Type is (MQC_Scalar)
          If(MQC_Scalar_HaveInteger(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Integer',TRIM(myStorage))
            Matrix%MatI = Scalar%ScaI
          ElseIf(MQC_Scalar_HaveReal(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Real',TRIM(myStorage))
            Matrix%MatR = Scalar%ScaR
          ElseIf(MQC_Scalar_HaveComplex(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Complex',TRIM(myStorage))
            Matrix%MatC = Scalar%ScaC
          Else
            Call MQC_Error_I('Unrecognized MQC scalar Type in MQC_Matrix_Initialize', 6)
          EndIf
        Class Default
          Call MQC_Error_I('Scalar Type not defined in MQC_Matrix_Initialize', 6)
        End Select
      Else
        Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Real',TRIM(myStorage))
        Matrix%MatR = Zero
      EndIf
!
      Return
      End Subroutine MQC_Matrix_Initialize
!
!
!     PROCEDURE MQC_Matrix_Initialize_Func
!
!>    \brief <b> MQC_Matrix_Initialize_Func is a function that returns an MQC matrix
!>    with each element equal to a chosen value</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Initialize_Func is a function that retuns an MQC matrix with each 
!>    element equal to a chosen value. Optional argument Scalar determines the value
!>    of each element, with the default equal to zero. Optional argument Storage 
!>    determines the initial packing of MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Rows 
!>    \verbatim
!>        Rows is Integer(kind=int64)
!>        The number of rows to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] Columns
!>    \verbatim
!>        Columns is Integer(kind=int64)
!>        The number of columns to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        The value to set each element of Matrix.
!>    \endverbatim
!>
!>    \param[in] Storage
!>    \verbatim
!>        Storage is Character(Len=*),Optional
!>        The initial packing of Matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2023
!
      Function MQC_Matrix_Initialize_Func(Rows,Columns,Scalar,Storage) Result(Matrix)
!
!     Variable Declarations.
!
      Implicit None
      Real(kind=real64)::Zero=0.0d0
      Integer(kind=int64),Intent(in)::Rows,Columns
      Class(*),Optional::Scalar
      Character(Len=*),Intent(in),OPTIONAL::Storage
      Type(MQC_Matrix)::Matrix
      Character(Len=64)::myStorage
!
      if(Present(Storage)) then
        myStorage = TRIM(Storage)
      else
        myStorage = 'StorFull'
      endIf
!
      If(Present(Scalar)) then
        Select Type (Scalar)
        Type is (Integer)
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Integer',TRIM(myStorage))
            Matrix%MatI = Scalar
        Type is (Real)
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Real',TRIM(myStorage))
            Matrix%MatR = Scalar
        Type is (Complex(Kind=real64))
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Complex',TRIM(myStorage))
            Matrix%MatC = Scalar
        Type is (MQC_Scalar)
          If(MQC_Scalar_HaveInteger(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Integer',TRIM(myStorage))
            Matrix%MatI = Scalar%ScaI
          ElseIf(MQC_Scalar_HaveReal(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Real',TRIM(myStorage))
            Matrix%MatR = Scalar%ScaR
          ElseIf(MQC_Scalar_HaveComplex(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Complex',TRIM(myStorage))
            Matrix%MatC = Scalar%ScaC
          Else
            Call MQC_Error_I('Unrecognized MQC scalar Type in MQC_Matrix_Initialize', 6)
          EndIf
        Class Default
          Call MQC_Error_I('Scalar Type not defined in MQC_Matrix_Initialize', 6)
        End Select
      Else
        Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Real',TRIM(myStorage))
        Matrix%MatR = Zero
      EndIf
!
      Return
      End Function MQC_Matrix_Initialize_Func
!
!
!     PROCEDURE MQC_Matrix_Identity
!
!>    \brief <b> MQC_Matrix_Identity is a subroutine that initializes an MQC matrix
!>    as an identity matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Identity is a subroutine that initializes an MQC matrix as an  
!>    identity matrix. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix to initialize as the NxM identity 
!>        matrix.
!>    \endverbatim
!>
!>    \param[in] N 
!>    \verbatim
!>        N is Integer(kind=int64)
!>        The number of rows to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] M
!>    \verbatim
!>        M is Integer(kind=int64)
!>        The number of columns to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        The value to set diagonal elements of Matrix. The 
!>        default is 1.0.
!>    \endverbatim
!>
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_Identity(matrix,n,m,scalar)
!
!     Variable Declarations.
!
      implicit none
      class(MQC_Matrix),intent(inOut)::matrix
      integer(kind=int64),intent(in)::n,m
      class(*),optional,intent(in)::scalar
      type(MQC_Scalar)::one

      if(present(scalar)) then
        select type (scalar)
        type is (integer)
          one = scalar
        type is (real)
          one = scalar
        type is (complex(kind=real64))
          one = scalar
        type is (mqc_scalar)
          one = scalar
        class default
          call mqc_error('unrecognized scalar type in mqc_matrix_identity')
        end select
      else
        one = 1.0
      endIf
      call matrix%init(n,m,one,'StorDiag')

      End Subroutine MQC_Matrix_Identity
!
!
!     PROCEDURE MQC_Matrix_Identity_Func
!
!>    \brief <b> MQC_Matrix_Identity_Func is a function that returns an MQC matrix
!>    as an identity matrix</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Identity_Func is a function that returns an MQC matrix as an  
!>    identity matrix. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] N 
!>    \verbatim
!>        N is Integer(kind=int64)
!>        The number of rows to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] M
!>    \verbatim
!>        M is Integer(kind=int64)
!>        The number of columns to initialize Matrix.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        The value to set diagonal elements of Matrix. The 
!>        default is 1.0.
!>    \endverbatim
!>
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2023
!
      Function MQC_Matrix_Identity_Func(n,m,scalar) result(matrix)
!
!     Variable Declarations.
!
      implicit none
      type(MQC_Matrix)::matrix
      integer(kind=int64),intent(in)::n,m
      class(*),optional,intent(in)::scalar
      type(MQC_Scalar)::one

      if(present(scalar)) then
        select type (scalar)
        type is (integer)
          one = scalar
        type is (real)
          one = scalar
        type is (complex(kind=real64))
          one = scalar
        type is (mqc_scalar)
          one = scalar
        class default
          call mqc_error('unrecognized scalar type in mqc_matrix_identity')
        end select
      else
        one = 1.0
      endIf
      call matrix%identity(n,m,one)

      End Function MQC_Matrix_Identity_Func
!
!
!     PROCEDURE MQC_Matrix_Set
!
!>    \brief <b> MQC_Matrix_Set is a subroutine that sets an MQC matrix to a value
!>    without resizing its dimensions</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Set is a subroutine that sets an MQC matrix to a value without
!>    resizing its dimensions. Optional argument scalar specifies the value to set
!>    each element of the matrix, where the default value is 0.0. Optional argument
!>    storage allows the storage of the matrix to be defined, where the default is
!>    unpacked. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix to set values of elements.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        The value to set each element of Matrix. The default
!>        is 0.0.
!>    \endverbatim
!>
!>    \param[in] Storage
!>    \verbatim
!>        Storage is Character(len=*),Optional
!>        The packing of the Matrix. The default is unpacked.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      subroutine MQC_Matrix_Set(matrix,scalar,storage)
!
!     Variable Declarations.
!
      implicit none
      class(MQC_Matrix),intent(inOut)::matrix
      class(*),optional::scalar
      character(len=*),intent(in),optional::storage
      integer(kind=int64)::rows,columns
      character(Len=64)::myStorage
      real(kind=real64)::zero=0.0d0
!
      if(Present(Storage)) then
        myStorage = TRIM(Storage)
      else
        myStorage = 'StorFull'
      endIf

      rows = mqc_matrix_rows(matrix) 
      columns = mqc_matrix_columns(matrix) 
      if(present(scalar)) then
        select type (scalar)
        type is (integer)
            call mqc_allocate_matrix(rows,columns,matrix,'Integer',TRIM(myStorage))
            Matrix%MatI = scalar
        type is (real)
            Call mqc_allocate_matrix(rows,columns,matrix,'Real',TRIM(myStorage))
            Matrix%MatR = scalar
        type is (complex(kind=real64))
            call mqc_allocate_matrix(rows,columns,matrix,'Complex',TRIM(myStorage))
            Matrix%MatC = scalar
        Type is (MQC_Scalar)
          If(MQC_Scalar_HaveInteger(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Integer',TRIM(myStorage))
            Matrix%MatI = Scalar%ScaI
          ElseIf(MQC_Scalar_HaveReal(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Real',TRIM(myStorage))
            Matrix%MatR = Scalar%ScaR
          ElseIf(MQC_Scalar_HaveComplex(Scalar)) then
            Call MQC_Allocate_Matrix(Rows,Columns,Matrix,'Complex',TRIM(myStorage))
            Matrix%MatC = Scalar%ScaC
          Else
            Call MQC_Error_I('Unrecognized MQC scalar Type in MQC_Matrix_Initialize', 6)
          EndIf
        class default
          call mqc_error_i('scalar type not defined in MQC_Matrix_Set', 6)
        end select
      else
        if(Matrix%Data_Type.eq.'Integer') then 
          matrix%MatI = Zero
        elseIf(Matrix%Data_Type.eq.'Real') then 
          matrix%MatR = Zero
        elseIf(Matrix%Data_Type.eq.'Complex') then 
          matrix%MatC = Zero
        endIf
      endIf

      End Subroutine MQC_Matrix_Set
!
!
!     PROCEDURE MQC_Matrix_Norm
!
!>    \brief <b> MQC_Matrix_Norm is a function that returns the norm of an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Norm is a function that returns the norm of an MQC matrix. The 
!>    following options are available:
!>
!>    1. methodIn = 'M' uses the maximum absolute value max(abs(A(i,j))).
!>    2. methodIn = '1' uses the one norm.
!>    3. methodIn = 'I' uses the infinity norm.
!>    4. methodIn = 'F' uses the Frobenius norm (default).
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] MatrixIn
!>    \verbatim
!>        MatrixIn is Class(MQC_Matrix)
!>        The name of the MQC_Matrix variable.
!>    \endverbatim
!>
!>    \param[in] MethodIn
!>    \verbatim
!>        MethodIn is Character(len=1)
!>        = 'M': max(abs(A(i,j)))
!>        = '1': one norm
!>        = 'I': infinity norm
!>        = 'F': Frobenius norm.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_Matrix_Norm(matrixIn,methodIn) result(norm)
!
!     Variable Declarations.
!
      implicit none
      class(MQC_Matrix),intent(in)::matrixIn
      character(len=1),optional,intent(in)::methodIn
      character(len=1)::method
      character(len=64)::StorFlag,TypeFlag
      real(kind=real64),dimension(:),allocatable::work
      real(kind=real64)::dlange,zlange
      real(kind=real64),dimension(:,:),allocatable::temp
      Complex(Kind=real64),dimension(:,:),allocatable::tempC
      Type(MQC_Scalar)::norm
      type(mqc_matrix)::matrix

      matrix = matrixIn
      if(Present(methodIn)) method = methodIn
      if(.not.Present(methodIn)) method = 'F'
      if(method.eq.'I') allocate(work(max(1,MQC_Matrix_Rows(matrix))))
      StorFlag = Matrix%Storage
      TypeFlag = Matrix%Data_Type
      if(Matrix%Storage.eq.'StorDiag') Call MQC_Matrix_Diag2Full(matrix)
      if(Matrix%Storage.eq.'StorSymm'.or.Matrix%Storage.eq.'StorAsym'.or. &
        Matrix%Storage.eq.'StorHerm'.or.Matrix%Storage.eq.'StorAhrm') &
        Call MQC_Matrix_Symm2Full(matrix)
      If(Matrix%Data_Type.eq.'Integer'.or.Matrix%Data_Type.eq.'Real') then 
        If(Matrix%Data_Type.eq.'Integer') Call MQC_Matrix_Copy_Int2Real(matrix)
        allocate(temp(MQC_Matrix_Rows(matrix),MQC_Matrix_Columns(matrix)))
        temp = matrix%matr
        norm = dlange(method,MQC_Matrix_Rows(matrix),MQC_Matrix_Columns(matrix), &
          temp,max(MQC_Matrix_Rows(matrix),1),work)
        if(allocated(work)) deallocate(work)
        if(allocated(temp)) deallocate(temp)
        if(TypeFlag.eq.'Integer') Call MQC_Matrix_Copy_Real2Int(matrix)
      ElseIf(matrix%Data_Type.eq.'Complex') then
        allocate(tempC(MQC_Matrix_Rows(matrix),MQC_Matrix_Columns(matrix)))
        tempC = matrix%matc
        norm = zlange(method,MQC_Matrix_Rows(matrix),MQC_Matrix_Columns(matrix), &
          tempC,max(MQC_Matrix_Rows(matrix),1),work)
        if(allocated(work)) deallocate(work)
        if(allocated(temp)) deallocate(temp)
      Else
        call mqc_error_a('unrecognised data type in mqc_matrix_norm', 6, &
             'matrix%Data_Type', matrix%Data_Type )
      EndIf
      if(StorFlag.eq.'StorDiag') Call MQC_Matrix_Full2Diag(matrix)
      if(StorFlag.eq.'StorSymm'.or.StorFlag.eq.'StorAsym'.or. &
        StorFlag.eq.'StorHerm'.or.StorFlag.eq.'StorAhrm') &
        Call MQC_Matrix_Full2Symm(matrix)

      End Function MQC_Matrix_Norm
!
!
!     PROCEDURE mqc_matrix_determinant
!
!>    \brief <b> MQC_Matrix_Determinant is a function that returns the determinant of 
!>    an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Determinant is a function that returns the determinant of an MQC 
!>    matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix which will be evaluated.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      function mqc_matrix_determinant(a) result(det)
!
!     This function returns the determinant of MQC matrix A.
!
!     Lee M. Thompson, 2016.
!
      implicit none
      class(mqc_matrix)::a
      type(mqc_scalar)::det
      character(len=64)::StorFlag,TypeFlag
      real(kind=real64),dimension(:,:),allocatable::temp
      Complex(Kind=real64),dimension(:,:),allocatable::tempC
      integer(kind=int64)::sgn,rows,cols,minrc,iError,i
      integer(kind=int32),dimension(:),allocatable::iPiv
!
!     Determinant of matrix A.
!
      rows = mqc_matrix_rows(a)
      cols = mqc_matrix_columns(a)
      minrc = min(rows,cols)
      if(minrc.eq.0) then
        det = 1.0
        return
      endIf
      storFlag = a%Storage
      typeFlag = a%Data_Type
      if(a%Storage.eq.'StorDiag') call mqc_matrix_diag2Full(a)
      if(a%Storage.eq.'StorSymm'.or.a%Storage.eq.'StorAsym'.or.&
        a%Storage.eq.'StorHerm'.or.a%Storage.eq.'StorAhrm') &
        call mqc_matrix_symm2Full(a)
      if(a%Data_Type.eq.'Integer'.or.a%Data_Type.eq.'Real') then
        If(a%Data_Type.eq.'Integer') call mqc_matrix_copy_int2Real(a)
        allocate(temp(rows,cols))
        temp = a%matr

        allocate(iPiv(minrc))
        iPiv = 0
        iError = 1
        call dgetrf(rows,cols,temp,rows,iPiv,iError)
        if(iError.lt.0) call mqc_error_i('DGETRF exited with error in mqc_matrix_determinant', 6, &
             'iError', iError )
        det = 1.0
        do i = 1,rows
          det = det%rval()*temp(i,i)
        enddo
        sgn = 1
        do i = 1,rows
          if(iPiv(i).ne.i) then
            sgn = -sgn
          endIf
        endDo
        det = sgn*det%rval()
        if(allocated(iPiv)) deallocate(iPiv)
        if(allocated(temp)) deallocate(temp)
        if(TypeFlag.eq.'Integer') Call MQC_Matrix_Copy_Real2Int(a)
      elseIf(a%Data_Type.eq.'Complex') then
        allocate(tempC(rows,cols))
        tempC = a%matc

        allocate(iPiv(minrc))
        iPiv = 0
        iError = 1
        call zgetrf(rows,cols,tempC,rows,iPiv,iError)
        if(iError.lt.0) call mqc_error_i('ZGETRF exited with error in mqc_matrix_determinant', 6, &
             'iError', iError )
        det = cmplx(1.0,0.0,kind=real64)
        do i = 1,rows
          det = det%cval()*tempC(i,i)
        enddo
        sgn = 1
        do i = 1,rows
          if(iPiv(i).ne.i) then
            sgn = -sgn
          endIf
        endDo
        det = sgn*det%cval()
        if(allocated(iPiv)) deallocate(iPiv)
        if(allocated(tempC)) deallocate(tempC)
      else
        call mqc_error_a('Unrecognized data type in mqc_matrix_determinant',6,'a%Data_Type',a%Data_Type)
      endIf
      if(StorFlag.eq.'StorDiag') Call MQC_Matrix_Full2Diag(a)
      if(StorFlag.eq.'StorSymm'.or.StorFlag.eq.'StorAsym'.or.&
        StorFlag.eq.'StorHerm'.or.StorFlag.eq.'StorAhrm') &
        Call MQC_Matrix_Full2Symm(a)

      end function mqc_matrix_determinant
!
!
!     PROCEDURE mqc_matrix_minor
!
!>    \brief <b> MQC_Matrix_Minor is a function that returns the minor of 
!>    an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Minor is a function that returns the minor of an MQC 
!>    matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix which will be evaluated.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer(kind=int64)
!>        The row index of the minor. A negative
!>        number evaluates from the last index of 
!>        the matrix.
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Integer(kind=int64)
!>        The column index of the minor. A negative
!>        number evaluates from the last index of 
!>        the matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2024
!
      function mqc_matrix_minor(a,i,j) result(minor)
!
      implicit none
      class(mqc_matrix),intent(in)::a
      integer(kind=int64),intent(in)::i,j
      type(mqc_scalar)::minor
!
      integer(kind=int64)::iUse,jUse
      type(mqc_matrix)::tmp
!
      if(abs(i).gt.mqc_matrix_rows(a)) &
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'i',i)
      if(abs(j).gt.mqc_matrix_columns(a)) &
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'j',j)
      if(i.lt.0) then
        iUse = mqc_matrix_rows(a)+i+1
      elseif(i.gt.0) then
        iUse = i
      else
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'i',i)
      endIf
      if(j.lt.0) then
        jUse = mqc_matrix_columns(a)+j+1
      elseif(i.gt.0) then
        jUse = j
      else
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'j',j)
      endIf

      call tmp%init(mqc_matrix_rows(a)-1,mqc_matrix_columns(a)-1)
      if(iUse.gt.1.and.jUse.gt.1) call tmp%mput(a%mat([1,iUse-1],[1,jUse-1]),[1,iUse-1],[1,jUse-1])
      if(iUse.gt.1.and.jUse.lt.mqc_matrix_columns(a)) &
        call tmp%mput(a%mat([1,iUse-1],[jUse+1,-1]),[1,iUse-1],[jUse,-1])
      if(iUse.lt.mqc_matrix_rows(a).and.jUse.gt.1) &
        call tmp%mput(a%mat([iUse+1,-1],[1,jUse-1]),[iUse,-1],[1,jUse-1])
      if(iUse.lt.mqc_matrix_rows(a).and.jUse.lt.mqc_matrix_columns(a)) &
        call tmp%mput(a%mat([iUse+1,-1],[jUse+1,-1]),[iUse,-1],[jUse,-1])
      minor = tmp%det()

      end function mqc_matrix_minor
!
!
!     PROCEDURE mqc_matrix_cofactor
!
!>    \brief <b> MQC_Matrix_Cofactor is a function that returns the cofactor of 
!>    an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Cofactor is a function that returns the cofactor of an MQC 
!>    matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix which will be evaluated.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer(kind=int64)
!>        The row index of the cofactor. A negative
!>        number evaluates from the last index of 
!>        the matrix.
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Integer(kind=int64)
!>        The column index of the cofactor. A negative
!>        number evaluates from the last index of 
!>        the matrix.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2024
!
      function mqc_matrix_cofactor(a,i,j) result(cofactor)
!
      implicit none
      class(mqc_matrix),intent(in)::a
      integer(kind=int64),intent(in)::i,j
      type(mqc_scalar)::cofactor
!
      integer(kind=int64)::iUse,jUse
!
      if(abs(i).gt.mqc_matrix_rows(a)) &
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'i',i)
      if(abs(j).gt.mqc_matrix_columns(a)) &
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'j',j)
      if(i.lt.0) then
        iUse = mqc_matrix_rows(a)+i+1
      elseif(i.gt.0) then
        iUse = i
      else
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'i',i)
      endIf
      if(j.lt.0) then
        jUse = mqc_matrix_columns(a)+j+1
      elseif(i.gt.0) then
        jUse = j
      else
        call mqc_error_i('Badly defined index in mqc_matrix_minor',6,'j',j)
      endIf

      cofactor = (-1)**(iUse+jUse)*a%minor(iUse,jUse)

      end function mqc_matrix_cofactor
!
!
!     PROCEDURE mqc_matrix_inverse
!
!>    \brief <b> MQC_Matrix_Inverse is a function that returns the inverse of an MQC 
!>    matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Inverse is a function that returns the inverse of an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix which will be evaluated.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      function mqc_matrix_inverse(a) result(a_inv)
!
      implicit none
      class(mqc_matrix)::a
      type(mqc_matrix)::a_inv
      character(len=64)::StorFlag,TypeFlag
      real(kind=real64),dimension(:,:),allocatable::temp
      Complex(Kind=real64),dimension(:,:),allocatable::tempC
      Complex(Kind=real64),dimension(:),allocatable::workc
      integer(kind=int64)::iError,nDim1,nDim2
      integer(kind=int32),dimension(:),allocatable::iPiv
      real(kind=real64),dimension(:),allocatable::work
!
!     Inverse of matrix A.
!
      nDim1 = mqc_matrix_rows(a)
      nDim2 = mqc_matrix_columns(a)
      storFlag = a%Storage
      typeFlag = a%Data_Type
      if(a%Storage.eq.'StorDiag') call mqc_matrix_diag2Full(a)
      if(a%Storage.eq.'StorSymm'.or.a%Storage.eq.'StorAsym'.or. &
        a%Storage.eq.'StorHerm'.or.a%Storage.eq.'StorAhrm') &
        call mqc_matrix_symm2Full(a)
      if(a%Data_Type.eq.'Integer'.or.a%Data_Type.eq.'Real') then
        If(a%Data_Type.eq.'Integer') call mqc_matrix_copy_int2Real(a)
        allocate(temp(nDim1,nDim2))
        temp = a%matr

        allocate(iPiv(min(nDim1,nDim2)),work(min(nDim1,nDim2)))
        iPiv = 0
        iError = 0
        call dgetrf(nDim1,nDim2,temp,nDim1,iPiv,iError)
        if (iError.gt.0) then 
          call mqc_error_i('Upper triangular matrix is singular', 6, 'iError', iError)
        else if (iError.lt.0) then
          call mqc_error_i('Illegal value in dgetrf matrix', 6, 'iError', iError)
        else
          call dgetri(NDim1,temp,NDim1,IPIV,Work,NDim1,IError)
          if(iError.gt.0) then
            call mqc_error_i('Matrix is not invertable', 6, 'iError', iError)
          else if (iError.lt.0) then
            call mqc_error_i('Illegal value in dgetri matrix', 6, 'iError', iError)
          end if
        end if
        a_inv = temp
        if(allocated(iPiv)) deallocate(iPiv)
        if(allocated(work)) deallocate(work)
        if(allocated(temp)) deallocate(temp)
        if(TypeFlag.eq.'Integer') Call MQC_Matrix_Copy_Real2Int(a)
      elseIf(a%Data_Type.eq.'Complex') then
        allocate(tempc(nDim1,nDim2))
        tempc = a%matc
        
        allocate(iPiv(min(nDim1,nDim2)),workc(min(nDim1,nDim2)))
        iPiv = 0
        iError = 0
        call zgetrf(nDim1,nDim2,tempc,nDim1,iPiv,iError)
        if (iError.gt.0) then
          call mqc_error_i('Upper triangular matrix is singular', 6, 'iError', iError)
        else if (iError.lt.0) then
          call mqc_error_i('Illegal value in zgetrf matrix', 6, 'iError', iError)
        else
          call zgetri(NDim1,tempC,NDim1,IPIV,WorkC,NDim1,IError)
          if(iError.gt.0) then
            call mqc_error_i('Matrix is not invertable', 6, 'iError', iError)
          else if(iError.lt.0) then
            call mqc_error_i('Illegal value in zgetri matrix', 6, 'iError', iError)
          end if
        end if
        a_inv = tempC
        if(allocated(iPiv)) deallocate(iPiv)
        if(allocated(workc)) deallocate(workc)
        if(allocated(tempC)) deallocate(tempC)
      endIf
      if(StorFlag.eq.'StorDiag') Call MQC_Matrix_Full2Diag(a)
      if(StorFlag.eq.'StorSymm'.or.StorFlag.eq.'StorAsym'.or.&
        StorFlag.eq.'StorHerm'.or.StorFlag.eq.'StorAhrm') &
        Call MQC_Matrix_Full2Symm(a)
!
      end function mqc_matrix_inverse
!
!
!     PROCEDURE mqc_matrix_trace
!
!>    \brief <b> MQC_Matrix_Trace is a function that returns the trace of an MQC 
!>    matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Trace is a function that returns the trace of an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix which will be evaluated.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      function mqc_matrix_trace(matrix) result(trace)
!
!     Variable Declarations...
!
      Implicit None
      class(mqc_matrix),intent(in)::matrix
      type(mqc_scalar)::trace
      integer(kind=int64)::i
!
      trace = 0.0
      do i = 1, min(mqc_matrix_rows(matrix),mqc_matrix_columns(matrix))
        trace = trace + matrix%at(i,i)
      enddo
!
      end function mqc_matrix_trace
!
!
!     PROCEDURE mqc_matrix_diagonal_elements
!
!>    \brief <b> MQC_Matrix_Diagonal_Elements is a function that returns the diagonal 
!>    of an MQC matrix as an MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Diagonal_Elements is a function that returns the diagonal of an MQC 
!>    matrix as an MQC vector. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix
!>    \verbatim
!>        Matrix is Class(MQC_Matrix)
!>        The MQC matrix which will be evaluated.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      function mqc_matrix_diagonal_elements(matrix) result(vector)
!
!     Variable Declarations...
!
      Implicit None
      class(mqc_matrix),intent(in)::matrix
      type(mqc_vector)::vector
      integer(kind=int64)::i
!
      call vector%init(min(size(matrix,1),size(matrix,2)))
      do i = 1, min(size(matrix,1),size(matrix,2))
        call vector%put(matrix%at(i,i),i)
      enddo
!
      end function mqc_matrix_diagonal_elements
!
!
!     PROCEDURE mqc_matrix_generalized_eigensystem
!
!>    \brief <b> MQC_Matrix_Generalized_Eigensystem is a subroutine that takes a MQC 
!>    matrix and a metric and returns eigenvalues and eigenvectors</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Generalized_Eigensystem is a subroutine that takes a MQC matrix and
!>    an optional metric (also as an MQC matrix) and optionally returns eigenvalues 
!>    to a MQC vector and/or left and/or right eigenvectors to an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to diagonalize. 
!>    \endverbatim
!>
!>    \param[in] BIn
!>    \verbatim
!>        BIn is Type(MQC_Matrix),Optional
!>        The metric. 
!>    \endverbatim
!>
!>    \param[out] Eigenvals
!>    \verbatim
!>        Eigenvals is Type(MQC_Vector),Optional
!>        Optional MQC vector containing the eigenvalues.
!>    \endverbatim
!>
!>    \param[out] REigenvecs
!>    \verbatim
!>        REigenvecs is Type(MQC_Matrix),Optional
!>        Optional MQC matrix containing the right eigenvectors.
!>    \endverbatim
!>
!>    \param[out] LEigenvecs
!>    \verbatim
!>        LEigenvecs is Type(MQC_Matrix),Optional
!>        Optional MQC matrix containing the left eigenvectors.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      subroutine mqc_matrix_generalized_eigensystem(a,bIn,eigenvals,reigenvecs,leigenvecs)
!
      implicit none
      class(mqc_matrix),intent(inOut)::a
      type(mqc_matrix),intent(inOut),optional::bIn
      type(mqc_matrix)::b
      type(mqc_vector),intent(out),optional::eigenvals
      type(mqc_matrix),intent(out),optional::reigenvecs,leigenvecs
      real(kind=real64),dimension(:,:),allocatable::tempA,tempB,rightvecs,leftvecs
      real(kind=real64),dimension(:),allocatable::eValsOut,work,eValsReal,eValsImag
      Complex(Kind=real64),dimension(:,:),allocatable::tempAC,tempBC,rightCvecs,leftCvecs
      Complex(Kind=real64),dimension(:),allocatable::eValsA,eValsB,workC
      integer(kind=int64)::iError=0,lWork,nDim1A,nDim2A,nDim1B,nDim2B,ilaenv,i,npdFlag
      character(len=64)::StorFlagA,StorFlagB,TypeFlagA,TypeFlagB
      type(mqc_vector)::tmp_vec
!
!     Generalized eigensystem solver.
!
      nDim1A = mqc_matrix_rows(a)
      nDim2A = mqc_matrix_columns(a)
      if(present(bIn)) then
        b = bIn
      else
        call b%identity(nDim1A,nDim2A)
      endIf
      nDim1B = mqc_matrix_rows(b)
      nDim2B = mqc_matrix_columns(b)
      if(nDim1A.ne.nDim1B) call mqc_error_I('Order of matrices A and B is different in mqc_matrix_generalized_eigensystem', 6, &
           'nDim1A', nDim1A, &
           'nDim1B', nDim1B )
      if(nDim1A.ne.nDim2A) call mqc_error_i('Matrix A is not square in mqc_matrix_generalized_eigensystem', 6, &
           'nDim1A', nDim1A, &
           'nDim2A', nDim2A )
      if(nDim1B.ne.nDim2B) call mqc_error_i('Matrix B is not square in mqc_matrix_generalized_eigensystem', 6, &
           'nDim1B', nDim1B, &
           'nDim2B', nDim2B )
      storFlagA = a%Storage
      storFlagB = b%Storage
      typeFlagA = a%Data_Type
      typeFlagB = b%Data_Type
      if(a%Storage.eq.'StorDiag') call mqc_matrix_diag2Full(a)
      if(b%Storage.eq.'StorDiag') call mqc_matrix_diag2Full(b)
      if(a%Storage.eq.'StorSymm'.or.a%Storage.eq.'StorAsym'.or. &
        a%Storage.eq.'StorHerm'.or.a%Storage.eq.'StorAhrm') &
        call mqc_matrix_symm2Full(a)
      if(b%Storage.eq.'StorSymm'.or.b%Storage.eq.'StorAsym'.or. &
        b%Storage.eq.'StorHerm'.or.b%Storage.eq.'StorAhrm') &
        call mqc_matrix_symm2Full(b)
      If(a%Data_Type.eq.'Integer') call mqc_matrix_copy_int2Real(a)
      If(b%Data_Type.eq.'Integer') call mqc_matrix_copy_int2Real(b)
      If(a%Data_Type.eq.'Complex'.and.b%Data_Type.ne.'Complex') call mqc_matrix_copy_real2Complex(b)
      If(a%Data_Type.ne.'Complex'.and.b%Data_Type.eq.'Complex') call mqc_matrix_copy_real2Complex(a)
      npdFlag = 0

      if(MQC_Matrix_Test_Symmetric(a).and.MQC_Matrix_Test_Symmetric(b).and.a%Data_Type.eq.'Real' &
        .and.b%Data_Type.eq.'Real') then
        allocate(tempA(nDim1A,nDim2A),tempB(nDim1B,nDim2B))
        tempA = a%matR
        tempB = b%matR
        lWork = -1
        allocate(eValsOut(nDim2A),work(1))
        if(present(reigenvecs).or.present(leigenvecs)) then
          call dsygv(1,'V','L',nDim2A,tempA,nDim1A,tempB,nDim1B,eValsOut,work,lWork,iError)
          if(iError.ne.0) call mqc_error_i('Failure in SSYGV memory evaluation in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
          lWork = work(1)
          deallocate(work)
          allocate(work(lWork))
          call dsygv(1,'V','L',nDim2A,tempA,nDim1A,tempB,nDim1B,eValsOut,work,lWork,iError)
          if(iError.lt.0) call mqc_error_i('Failure in SSYGV routine in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
          if(iError.gt.0) then
            npdFlag = 1
          else
            if(present(reigenvecs)) reigenvecs = tempA
            if(present(leigenvecs)) leigenvecs = tempA
          endIf
        else
          call dsygv(1,'N','L',nDim2A,tempA,nDim1A,tempB,nDim1B,eValsOut,work,lWork,iError)
          if(iError.ne.0) call mqc_error_i('Failure in SSYGV memory evaluation in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
          lWork = work(1)
          deallocate(work)
          allocate(work(lWork))
          call dsygv(1,'N','L',nDim2A,tempA,nDim1A,tempB,nDim1B,eValsOut,work,lWork,iError)
          if(iError.lt.0) call mqc_error_i('Failure in SSYGV routine in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
          if(iError.gt.0) npdFlag = 1
        endIf
        if(iError.eq.0.and.present(eigenvals)) eigenvals = eValsOut
        if(allocated(eValsOut)) deallocate(eValsOut)
        if(allocated(work)) deallocate(work)
        if(allocated(tempA)) deallocate(tempA)
        if(allocated(tempB)) deallocate(tempB)
      endIf
      
      if(.not.MQC_Matrix_Test_Symmetric(a).or..not.MQC_Matrix_Test_Symmetric(b).or.a%Data_Type.ne.'Real' &
        .or.b%Data_Type.ne.'Real'.or.npdFlag.eq.1) then
        if(a%Data_Type.eq.'Real'.and.b%Data_Type.eq.'Real') then
          allocate(tempA(nDim1A,nDim2A),tempB(nDim1B,nDim2B))
          tempA = a%matR
          tempB = b%matR
          lWork = -1
          allocate(eValsOut(nDim2A),work(1))
          allocate(eValsReal(nDim2A),eValsImag(NDim2A))
          if(present(reigenvecs).or.present(leigenvecs)) then
            allocate(rightvecs(nDim2A,nDim2A),leftvecs(nDim2A,nDim2A))
            call dggev('V','V',nDim2A,tempA,nDim1A,tempB,NDim1B,eValsReal,eValsImag,eValsOut,leftvecs,NDim2A, &
              rightvecs,nDim2A,work,lWork,iError)
            if(iError.ne.0) call mqc_error_i('Failure in DGGEV memory evaluation in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
            lWork = work(1)
            deallocate(work)
            allocate(work(lWork))
            call dggev('V','V',nDim2A,tempA,nDim1A,tempB,NDim1B,eValsReal,eValsImag,eValsOut,leftvecs,nDim2A, &
              rightvecs,nDim2A,work,lWork,iError)
            if(iError.ne.0) call mqc_error_i('Failure in DGGEV routine in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
            if(present(reigenvecs)) reigenvecs = rightvecs
            if(present(leigenvecs)) leigenvecs = leftvecs
            do i = 1, NDim2A
              if(eValsImag(i).ne.0.0) then
                if(eValsImag(i-1).ne.0.0) cycle
                if(present(reigenvecs)) then
                  tmp_vec = cmplx(rightvecs(:,i),rightvecs(:,i+1),kind=real64)
                  call reigenvecs%vput(tmp_vec,[0],[i])
                  tmp_vec = cmplx(rightvecs(:,i),-rightvecs(:,i+1),kind=real64)
                  call reigenvecs%vput(tmp_vec,[0],[i+1])
                endIf
                if(present(leigenvecs)) then
                  tmp_vec = cmplx(leftvecs(:,i),leftvecs(:,i+1),kind=real64)
                  call leigenvecs%vput(tmp_vec,[0],[i])
                  tmp_vec = cmplx(leftvecs(:,i),-leftvecs(:,i+1),kind=real64)
                  call leigenvecs%vput(tmp_vec,[0],[i+1])
                endIf
              endIf
            endDo
          else
            allocate(leftvecs(1,1),rightvecs(1,1))
            call dggev('N','N',nDim2A,tempA,nDim1A,tempB,NDim1B,eValsReal,eValsImag,eValsOut,leftvecs,1, &
              rightvecs,1,work,lWork,iError)
            if(iError.ne.0) call mqc_error_i('Failure in DGGEV memory evaluation in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
            lWork = work(1)
            deallocate(work)
            allocate(work(lwork))
            call dggev('N','N',nDim2A,tempA,nDim1A,tempB,NDim1B,eValsReal,eValsImag,eValsOut,leftvecs,1, &
              rightvecs,1,work,lwork,iError)
            if(iError.ne.0) call mqc_error_i('Failure in DGGEV routine in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
          endIf
          if(present(eigenvals)) eigenvals = cmplx(eValsReal/eValsOut,eValsImag/eValsOut,kind=real64)
          if(allocated(eValsReal)) deallocate(eValsReal)
          if(allocated(eValsImag)) deallocate(eValsImag)
          if(allocated(rightvecs)) deallocate(rightvecs)
          if(allocated(leftvecs)) deallocate(leftvecs)
          if(allocated(eValsOut)) deallocate(eValsOut)
          if(allocated(work)) deallocate(work)
          if(allocated(tempA)) deallocate(tempA)
          if(allocated(tempB)) deallocate(tempB)
        elseIf(a%Data_Type.eq.'Complex'.and.b%Data_Type.eq.'Complex') then
          allocate(tempAC(nDim1A,nDim2A),tempBC(nDim1B,nDim2B))
          tempAC = a%matC
          tempBC = b%matC
          lWork  = -1
          allocate(eValsA(nDim2A),eValsB(NDim2A),workC(1),work(8*NDim2A))
          if(present(reigenvecs).or.present(leigenvecs)) then
            allocate(rightCvecs(nDim2A,nDim2A),leftCvecs(nDim2A,nDim2A))
            call zggev('V','V',nDim2A,tempAC,nDim1A,tempBC,NDim1B,eValsA,eValsB,leftCvecs,nDim2A, &
              rightCvecs,nDim2A,workC,lWork,work,iError)
            if(iError.ne.0) call mqc_error_i('Failure in ZGGEV memory evaluation in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
            lWork = workC(1)
            deallocate(workC)
            allocate(workC(lWork))
            call zggev('V','V',nDim2A,tempAC,nDim1A,tempBC,NDim1B,eValsA,eValsB,leftCvecs,nDim2A, &
              rightCvecs,nDim2A,workC,lWork,work,iError)
            if(iError.ne.0) call mqc_error_i('Failure in ZGGEV routine in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
            if(present(reigenvecs)) reigenvecs = rightCvecs
            if(present(leigenvecs)) leigenvecs = leftCvecs
          else
            allocate(rightCvecs(1,1),leftCvecs(1,1))
            call zggev('N','N',nDim2A,tempAC,nDim1A,tempBC,NDim1B,eValsA,eValsB,leftCvecs,1, &
              rightCvecs,1,workC,lWork,work,iError)
            if(iError.ne.0) call mqc_error_i('Failure in ZGGEV memory evaluation in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
            lWork = workC(1)
            deallocate(workC)
            allocate(workC(lWork))
            call zggev('N','N',nDim2A,tempAC,nDim1A,tempBC,NDim1B,eValsA,eValsB,leftCvecs,1, &
              rightCvecs,1,workC,lWork,work,iError)
            if(iError.ne.0) call mqc_error_i('Failure in ZGGEV routine in mqc_matrix_generalized_eigensystem', 6, &
                 'iError', iError)
          endIf
          if(present(eigenvals)) eigenvals = eValsA/eValsB
          if(allocated(eValsA)) deallocate(eValsA)
          if(allocated(eValsB)) deallocate(eValsB)
          if(allocated(rightCvecs)) deallocate(rightCvecs)
          if(allocated(leftCvecs)) deallocate(leftCvecs)
          if(allocated(workC)) deallocate(workC)
          if(allocated(work)) deallocate(work)
          if(allocated(tempAC)) deallocate(tempAC)
          if(allocated(tempBC)) deallocate(tempBC)
        else
          call mqc_error_A('Incompatible data types in mqc_matrix_generalized_eigensystem',6,'a%Data_Type',a%Data_Type, &
            'b%Data_Type',b%Data_Type)
        endIf
      endIf

      if(typeFlagA.eq.'Integer') Call MQC_Matrix_Copy_Real2Int(a)
      if(typeFlagB.eq.'Integer') Call MQC_Matrix_Copy_Real2Int(b)
      if(typeFlagA.eq.'Real'.and.a%Data_Type.eq.'Complex') Call MQC_Matrix_Copy_Complex2Real(a)
      if(typeFlagB.eq.'Real'.and.b%Data_Type.eq.'Complex') Call MQC_Matrix_Copy_Complex2Real(b)
      if(storFlagA.eq.'StorDiag') Call MQC_Matrix_full2Diag(a)
      if(storFlagB.eq.'StorDiag') Call MQC_Matrix_full2Diag(b)
      if(storFlagA.eq.'StorSymm'.or.storFlagA.eq.'StorAsym'.or. &
        storFlagA.eq.'StorHerm'.or.storFlagA.eq.'StorAhrm') &
        Call MQC_Matrix_full2Symm(a)
      if(storFlagB.eq.'StorSymm'.or.storFlagB.eq.'StorAsym'.or. &
        storFlagB.eq.'StorHerm'.or.storFlagB.eq.'StorAhrm') &
        Call MQC_Matrix_full2Symm(b)
!
      end subroutine mqc_matrix_generalized_eigensystem
!
!
!     PROCEDURE MQC_Matrix_SVD
!
!>    \brief <b> MQC_Matrix_SVD is a subroutine that computes the singular value 
!>    decomposition of a MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_SVD is a subroutine that computes the singular value decomposition 
!>    of a MQC matrix.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to decompose.
!>    \endverbatim
!>
!>    \param[in,out] EVals
!>    \verbatim
!>        Eigenvals is Type(MQC_Vector),Optional
!>        Optional MQC vector containing the singular values.
!>    \endverbatim
!>
!>    \param[in,out] EUVecs
!>    \verbatim
!>        EUVecs is Type(MQC_Matrix),Optional
!>        Optional MQC matrix containing the U vectors.
!>    \endverbatim
!>
!>    \param[out] EVVecs
!>    \verbatim
!>        EVVecs is Type(MQC_Matrix),Optional
!>        Optional MQC matrix containing the V vectors.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_SVD(A,EVals,EUVecs,EVVecs)
!
      Implicit None
      Class(MQC_Matrix),Intent(InOut)::A
      Type(MQC_Matrix),Optional,Intent(InOut)::EUVecs
      Type(MQC_Matrix),Optional,Intent(InOut)::EVVecs
      Type(MQC_Vector),Optional,Intent(InOut)::EVals
!
      Integer(kind=int64)::NDim1=0,NDim2=0,Work_Length=-1,IError=1
      Real(kind=real64),Dimension(:),Allocatable::A_SVals,Work
      Complex(Kind=real64),Dimension(:),Allocatable::WorkC
      Real(kind=real64),Dimension(:,:),Allocatable::A_Temp,A_UVecs,A_VVecs
      Complex(Kind=real64),Dimension(:,:),Allocatable::AC_Temp,AC_UVecs,AC_VVecs
      Character(len=64)::typeFlag,storFlag
!
      NDim1 = MQC_Matrix_Rows(A)
      NDim2 = MQC_Matrix_Columns(A)
      typeFlag = A%Data_Type
      storFlag = A%Storage
 1050 Format( A, I10 )
!
      if(storFlag.eq.'StorDiag') call mqc_matrix_diag2Full(A)
      if(storFlag.eq.'StorSymm'.or.storFlag.eq.'StorAsym'.or.&
        storFlag.eq.'StorHerm'.or.storFlag.eq.'StorAhrm') &
        call mqc_matrix_symm2Full(A)
      if(typeFlag.eq.'Real'.or.typeFlag.eq.'Integer') then
        if(typeFlag.eq.'Integer') call mqc_matrix_copy_int2Real(A)
        Allocate(A_Temp(NDim1,NDim2),A_SVals(Min(NDim1,NDim2)),A_UVecs(NDim1,NDim1), &
          A_VVecs(NDim2,NDim2),Work(1))
        A_Temp = A
        Call DGESVD('A','A',NDim1,NDim2,A_Temp,NDim1,A_SVals,A_UVecs,NDim1,A_VVecs, &
          NDim2,Work,Work_Length,IError)
        Work_Length = Int(Work(1))
        DeAllocate(Work)
        Allocate(Work(Work_Length))
        Call DGESVD('A','A',NDim1,NDim2,A_Temp,NDim1,A_SVals,A_UVecs,NDim1,A_VVecs, &
          NDim2,Work,Work_Length,IError)
        If(IError.ne.0) Write(*,1050)' SVD FAILED: IError = ',IError
        DeAllocate(Work)
        Work_Length = -1
      elseIf(typeFlag.eq.'Complex') then
        Allocate(AC_Temp(NDim1,NDim2),A_SVals(Min(NDim1,NDim2)),AC_UVecs(NDim1,NDim1), &
          AC_VVecs(NDim2,NDim2),WorkC(1),Work(5*min(NDim1,NDim2)))
        AC_Temp = A
        Call ZGESVD('A','A',NDim1,NDim2,AC_Temp,NDim1,A_SVals,AC_UVecs,NDim1,AC_VVecs, &
          NDim2,WorkC,Work_Length,Work,IError)
        Work_Length = Int(WorkC(1))
        DeAllocate(WorkC)
        Allocate(WorkC(Work_Length))
        Call ZGESVD('A','A',NDim1,NDim2,AC_Temp,NDim1,A_SVals,AC_UVecs,NDim1,AC_VVecs, &
          NDim2,WorkC,Work_Length,Work,IError)
        If(IError.ne.0) Write(*,1050)' SVD FAILED: IError = ',IError
        DeAllocate(WorkC,Work)
        Work_Length = -1
      else
        call mqc_error_a('typeFlag not recognised in mqc_matrix_svd', 6, &
             'typeFlag', typeFlag )
      endIf
!
      if(present(EVals)) EVals = A_SVals
      if(present(EUVecs)) then
        if(allocated(A_UVecs)) EUVecs = A_UVecs
        if(allocated(AC_UVecs)) EUVecs = AC_UVecs
      endIf
      if(present(EVVecs)) then
        if(allocated(A_VVecs)) EVVecs = A_VVecs
        if(allocated(AC_VVecs)) EVVecs = AC_VVecs
      endIf
      if(allocated(A_SVals)) deallocate(A_SVals)
      if(allocated(A_UVecs)) deallocate(A_UVecs)
      if(allocated(AC_UVecs)) deallocate(AC_UVecs)
      if(allocated(A_VVecs)) deallocate(A_VVecs)
      if(allocated(AC_VVecs)) deallocate(AC_VVecs)
      if(allocated(A_Temp)) deallocate(A_Temp)
      if(allocated(AC_Temp)) deallocate(AC_Temp)
!
      if(typeFlag.eq.'Integer') call mqc_matrix_copy_real2Int(A)
      if(storFlag.eq.'StorSymm'.or.storFlag.eq.'StorAsym'.or.&
        storFlag.eq.'StorHerm'.or.storFlag.eq.'StorAhrm') &
        call mqc_matrix_full2Symm(A)
      if(storFlag.eq.'StorDiag') call mqc_matrix_full2diag(A)
!
      Return
      End Subroutine MQC_Matrix_SVD
!
!
!     PROCEDURE MQC_Matrix_RMS_Max
!
!>    \brief <b> MQC_Matrix_RMS_Max is a subroutine that returns the RMS and maximum 
!>    values of a MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_RMS_Max is a subroutine that returns the RMS and maximum values of a 
!>    MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to evaluate.
!>    \endverbatim
!>
!>    \param[out] RMS_A
!>    \verbatim
!>        RMS_A is Type(MQC_Scalar)
!>        Returns the RMS value of matrix A.
!>    \endverbatim
!>
!>    \param[out] Max_A
!>    \verbatim
!>        Max_A is Type(MQC_Scalar)
!>        Returns the maximum value of matrix A.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_Matrix_RMS_Max(A,rms_A,max_A)
!
      Implicit None
      Class(MQC_Matrix),Intent(InOut)::A
      Real(kind=real64),Dimension(:,:),Allocatable::A_Temp
      Complex(Kind=real64),Dimension(:,:),Allocatable::AC_Temp
      Type(MQC_Scalar),Intent(Out)::rms_A,max_A
!
      Integer(kind=int64)::N
      Character(len=64)::typeFlag,storFlag
!
!     Do the work.
!
      typeFlag = A%Data_Type
      storFlag = A%Storage
      N = MQC_Matrix_Rows(A)*MQC_Matrix_Columns(A)
      if(storFlag.eq.'StorDiag') call mqc_matrix_diag2Full(A) 
      if(storFlag.eq.'StorSymm'.or.storFlag.eq.'StorAsym'.or.&
        storFlag.eq.'StorHerm'.or.storFlag.eq.'StorAhrm') &
        call mqc_matrix_symm2Full(A)
      if(storFlag.eq.'StorFull') then
        if(typeFlag.eq.'Real'.or.typeFlag.eq.'Integer') then
          if(typeFlag.eq.'Integer') call mqc_matrix_copy_int2Real(A)
          allocate(A_Temp(MQC_Matrix_Rows(A),MQC_Matrix_Columns(A)))
          rms_A = sqrt(dot_product(Reshape(A_Temp,[N]),Reshape(A_Temp,[N]))/N)
          max_A = maxval(abs(A_Temp))
          deallocate(A_Temp)
        elseIf(typeFlag.eq.'Complex') then
          allocate(AC_Temp(MQC_Matrix_Rows(A),MQC_Matrix_Columns(A)))
          rms_A = sqrt(dot_product(Reshape(AC_Temp,[N]),Reshape(AC_Temp,[N]))/N)
          max_A = real(maxval(abs(AC_Temp)))
          deallocate(AC_Temp)
        else
          call mqc_error_a('Unrecognised type in mqc_matrix_rms_max', 6, &
               'typeFlag', typeFlag )
        endIf
      else
        call mqc_error_a('storFlag not recognised in mqc_matrix_rms_max', 6, &
             'storFlag', storFlag )
      endIf
!
      if(typeFlag.eq.'Integer') call mqc_matrix_copy_real2Int(A)
      if(storFlag.eq.'StorSymm'.or.storFlag.eq.'StorAsym'.or.&
        storFlag.eq.'StorHerm'.or.storFlag.eq.'StorAhrm') &
        call mqc_matrix_full2Symm(A)
      if(storFlag.eq.'StorDiag') call mqc_matrix_full2Diag(A)
!
      Return
      End Subroutine MQC_Matrix_RMS_Max
!
!
!     PROCEDURE MQC_Matrix_Sqrt
!
!>    \brief <b> MQC_Matrix_Sqrt is a subroutine that returns the square root of a 
!>    MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Sqrt is a subroutine that returns the square root of a MQC matrix.
!>    Note that the matrix has to be symmetric or hermitian. Optionally, eigenvalues 
!>    and/or eigenvectors are returned.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to evaluate.
!>    \endverbatim
!>
!>    \param[in,out] EVals
!>    \verbatim
!>        EVals is Type(MQC_Vector),Optional
!>        The eigenvalues of matrix A.
!>    \endverbatim
!>
!>    \param[out] EVecs
!>    \verbatim
!>        EVecs is Type(MQC_Matrix)
!>        The eigenvectors of matrix A.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      subroutine mqc_matrix_sqrt(A,eVals,eVecs)
!
      Implicit None
      class(mqc_matrix),intent(inOut)::A
      type(mqc_matrix),optional,intent(inOut)::eVecs
      type(mqc_vector),optional,intent(inOut)::eVals
      type(mqc_matrix)::tmpMat
      type(mqc_vector)::tmpVec
      integer(kind=int64)::i
!
!     Do the work.
!
      call A%diag(tmpVec,tmpMat)
      if(present(eVals)) eVals = tmpVec 
      if(present(eVecs)) eVecs = tmpMat 
      call A%set()
      do i=1,MQC_Length_Vector(tmpVec)
        call A%put(sqrt(tmpVec%at(i)),i,i)
      endDo
      A = matmul(matmul(tmpMat,A),transpose(tmpMat))
!
      end subroutine mqc_matrix_sqrt
!
!
!     PROCEDURE MQC_Matrix_Sqrt_Func
!
!>    \brief <b> MQC_Matrix_Sqrt_Func is a function that returns the square root of a 
!>    MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Sqrt_Func is a function that returns the square root of a MQC matrix.
!>    Note that the matrix has to be symmetric or hermitian. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to evaluate.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      function mqc_matrix_sqrt_func(A) result(sqrtA)
!
      Implicit None
      class(mqc_matrix),intent(in)::A
      type(mqc_matrix)::sqrtA,tmpMat
      type(mqc_vector)::tmpVec
      integer(kind=int64)::i
!
!     Do the work.
!
      call A%diag(tmpVec,tmpMat)
      sqrtA = A
      call sqrtA%set()
      do i=1,MQC_Length_Vector(tmpVec)
        call sqrtA%put(sqrt(tmpVec%at(i)),i,i)
      endDo
      sqrtA = matmul(matmul(tmpMat,sqrtA),transpose(tmpMat))
!
      end function mqc_matrix_sqrt_func
!
!
!     PROCEDURE MQC_Matrix_Exp 
!
!>    \brief <b> MQC_Matrix_Exp is a subroutine that returns the exponential of a 
!>    MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Exp is a subroutine that returns the exponential of a MQC matrix.
!>    Note that the matrix has to be symmetric or hermitian. Optionally, eigenvalues 
!>    and/or eigenvectors are returned.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to evaluate.
!>    \endverbatim
!>
!>    \param[in,out] EVals
!>    \verbatim
!>        EVals is Type(MQC_Vector),Optional
!>        The eigenvalues of matrix A.
!>    \endverbatim
!>
!>    \param[out] EVecs
!>    \verbatim
!>        EVecs is Type(MQC_Matrix)
!>        The eigenvectors of matrix A.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      subroutine mqc_matrix_exp(A,eVals,eVecs)
!
      Implicit None
      class(mqc_matrix),intent(inOut)::A
      type(mqc_matrix),optional,intent(inOut)::eVecs
      type(mqc_vector),optional,intent(inOut)::eVals
      type(mqc_matrix)::tmpMat
      type(mqc_vector)::tmpVec
      integer(kind=int64)::i
!
!     Do the work.
!
      call A%diag(tmpVec,tmpMat)
      if(present(eVals)) eVals = tmpVec 
      if(present(eVecs)) eVecs = tmpMat 
      call A%set()
      do i=1,MQC_Length_Vector(tmpVec)
        call A%put(exp(tmpVec%at(i)),i,i)
      endDo
      A = matmul(matmul(tmpMat,A),dagger(tmpMat))
!
      end subroutine mqc_matrix_exp
!
!
!     PROCEDURE MQC_Matrix_Exp_Func 
!
!>    \brief <b> MQC_Matrix_Exp is a function that returns the exponential of a 
!>    MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Exp is a function that returns the exponential of a MQC matrix.
!>    Note that the matrix has to be symmetric or hermitian.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to evaluate.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      function mqc_matrix_exp_func(A) result(expA)
!
      Implicit None
      class(mqc_matrix),intent(in)::A
      type(mqc_matrix)::expA,tmpMat
      type(mqc_vector)::tmpVec
      integer(kind=int64)::i
!
!     Do the work.
!
      call A%diag(tmpVec,tmpMat)
      expA = A
      call expA%set()
      do i=1,MQC_Length_Vector(tmpVec)
        call expA%put(exp(tmpVec%at(i)),i,i)
      endDo
      expA = matmul(matmul(tmpMat,expA),dagger(tmpMat))
!
      end function mqc_matrix_exp_func
!
!
!     PROCEDURE MQC_Givens_Matrix
!
!>    \brief <b> MQC_Givens_Matrix is a function that outputs a Givens rotation matrix 
!>    of specified angle and vector pair as an MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Givens_Matrix is a function that outputs a Givens rotation matrix of 
!>    specified angle and vector pair as an MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] M_Size
!>    \verbatim
!>        M_Size is integer(kind=int64)
!>        The dimension of the Givens matrix.
!>    \endverbatim
!>
!>    \param[in] Angle
!>    \verbatim
!>        Angle is real(kind=real64)
!>        The angle of rotation in radians.
!>    \endverbatim
!>
!>    \param[in] P
!>    \verbatim
!>        P is integer(kind=int64)
!>        The first vector to rotate.
!>    \endverbatim
!>
!>    \param[in] Q
!>    \verbatim
!>        Q is integer(kind=int64)
!>        The second vector to rotate.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author A. D. Mahler  
!>    \date 2019
!
      Function MQC_Givens_Matrix(m_size,angle,p,q)
!
!     Variable Declarations.
      Implicit None
      integer(kind=int64),intent(in)::m_size,p,q
      real(kind=real64),intent(in)::angle
      type(mqc_scalar)::cos_angle,sin_angle,nsin_angle
      type(mqc_matrix)::mqc_givens_matrix
!
      call mqc_givens_matrix%identity(m_size,m_size)
      cos_angle = cos(angle)
      sin_angle = sin(angle)
      nsin_angle = (-1)*sin(angle)
!
      call mqc_givens_matrix%put(cos_angle,p,p)
      call mqc_givens_matrix%put(cos_angle,q,q)
      call mqc_givens_matrix%put(sin_angle,q,p)
      call mqc_givens_matrix%put(nsin_angle,p,q)
!
      return
      End Function
!
!
!     PROCEDURE MQC_Matrix_Matrix_Outer
!
!>    \brief <b> MQC_Matrix_Matrix_Outer is a function that returns the rank-4
!>    tensor containing the outer product of two MQC matrices</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Matrix_Outer is a function that returns the rank-4 tensor containing 
!>    the outer product of two MQC matrices.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix1
!>    \verbatim
!>        Matrix1 is type(mqc_matrix)
!>        The first matrix in the outer product.
!>    \endverbatim
!>
!>    \param[in] Matrix2
!>    \verbatim
!>        Matrix2 is type(mqc_matrix)
!>        The second matrix in the outer product.
!>    \endverbatim
!>
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_Matrix_Matrix_Outer(matrix1,matrix2) result(outer)
!
!     Variable Declarations.
      Implicit None
      type(mqc_r4tensor)::outer
      type(mqc_matrix),intent(in)::matrix1,matrix2
      integer(kind=int64)::M,N,O,P,i,j,k,l
      
      M = size(matrix1,1)
      N = size(matrix1,2)
      O = size(matrix2,1)
      P = size(matrix2,2)
      
      call outer%init(M,N,O,P)
      
      do i = 1,M
        do j = 1,N
          do k = 1,O
            do l = 1,P
              call outer%put(matrix1%at(i,j)*matrix2%at(k,l),i,j,k,l)
            endDo
          endDo
        endDo
      endDo

      end function MQC_Matrix_Matrix_Outer


!
!
!     PROCEDURE MQC_Matrix_Matrix_Cross_Outer
!
!>    \brief <b> MQC_Matrix_Matrix_Cross_Outer is similar to
!>    MQC_Matrix_Matrix_Outer but returns a rank-4 with swapped indexes
!>    M1(i,l)xM(k,j) instead of M1(i,j)xM2(k,l)</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Matrix_Cross_Outer is a function that returns the rank-4 tensor containing 
!>    the  M1(i,l)xM(k,j) outer product of two MQC matrices </b>.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix1
!>    \verbatim
!>        Matrix1 is type(mqc_matrix)
!>        The first matrix in the outer product.
!>    \endverbatim
!>
!>    \param[in] Matrix2
!>    \verbatim
!>        Matrix2 is type(mqc_matrix)
!>        The second matrix in the outer product.
!>    \endverbatim
!>
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2024
!
      Function MQC_Matrix_Matrix_Cross_Outer(matrix1,matrix2) result(outer)
!
!     Variable Declarations.
      Implicit None
      type(mqc_r4tensor)::outer
      type(mqc_matrix),intent(in)::matrix1,matrix2
      integer(kind=int64)::M,N,O,P,i,j,k,l

      M = size(matrix1,1)
      N = size(matrix1,2)
      O = size(matrix2,1)
      P = size(matrix2,2)

      call outer%init(M,P,O,N)

      do i = 1,M
        do j = 1,N
          do k = 1,O
            do l = 1,P
              call outer%put(matrix1%at(i,j)*matrix2%at(k,l),i,l,k,j)
            endDo
          endDo
        endDo
      endDo

      end function MQC_Matrix_Matrix_Cross_Outer


!
!
!     PROCEDURE MQC_Matrix_Complex_RealPart
!
!>    \brief <b> MQC_Matrix_Complex_RealPart is a function that returns a MQC matrix
!>    with elements containing the real part of elements of another MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Complex_RealPart is a function that returns a MQC matrix with 
!>    elements containing the real part of elements of another MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The name of the MQC_Matrix variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_matrix_complex_realPart(A) result(output)
!
      Implicit None
      class(mqc_matrix),intent(in)::A
      type(mqc_matrix)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      output = A
      if(A%Data_Type.eq.'Complex') then
        call MQC_Matrix_Copy_Complex2Real(output)
        if(output%Storage.eq.'StorHerm') then
          output%Storage = 'StorSymm'
        elseIf(output%Storage.eq.'StorAhrm') then
          output%Storage = 'StorAsym'
        endIf
      endIf
!
      end function mqc_matrix_complex_realPart
!
!
!     PROCEDURE MQC_Matrix_Complex_ImagPart
!
!>    \brief <b> MQC_Matrix_Complex_ImagPart is a function that returns a MQC matrix
!>    with elements containing the imaginary part of elements of another MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Complex_ImagPart is a function that returns a MQC matrix with 
!>    elements containing the imaginary part of elements of another MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Vector)
!>        The name of the MQC_Vector variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      function mqc_matrix_complex_imagPart(A) result(output)
!
      Implicit None
      class(mqc_matrix),intent(in)::A
      type(mqc_matrix)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      output = A
      select case (A%Data_Type)
      case('Integer')
        output%matI = 0
      case('Real')
        output%matR = 0.0
      case('Complex')
        output = A
        call MQC_Matrix_Copy_Complex2Real(output)
        output%matR = aimag(A%matC)
        if(output%Storage.eq.'StorHerm') then
          output%Storage = 'StorAsym'
        elseIf(output%Storage.eq.'StorAhrm') then
          output%Storage = 'StorSymm'
        endIf
      case default
        call mqc_error_a('Unrecognized MQC_Matrix data type in mqc_matrix_complex_realPart',&
          6,'A%Data_Type',A%Data_Type)
      end select
!
      end function mqc_matrix_complex_imagPart
!
!
!     PROCEDURE MQC_Matrix_Cmplx
!
!>    \brief <b> MQC_Matrix_Cmplx is a function that takes a MQC matrix representing 
!>    the real part and a MQC matrix representing the imaginary part and combines
!>    them into another MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Cmplx is a function that takes a MQC matrix representing the real 
!>    part and a MQC matrix representing the imaginary part and combines them into 
!>    another MQC matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Matrix1
!>    \verbatim
!>        Matrix1 is Type(MQC_Matrix)
!>        The MQC matrix containing the real part.
!>    \endverbatim
!>
!>    \param[in] Matrix2
!>    \verbatim
!>        Matrix2 is Type(MQC_Matrix)
!>        The MQC matrix containing the imaginary part.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_Matrix_Cmplx(Matrix1,Matrix2)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix)::MQC_Matrix_Cmplx
      Type(MQC_Matrix),Intent(In)::Matrix1,Matrix2
      Type(MQC_Matrix)::Tmp1,Tmp2
      Character(len=8)::Storage
!
      If(Size(Matrix1,1).ne.Size(Matrix2,1).or.Size(Matrix1,2).ne.Size(Matrix2,2)) &
        call mqc_error_i('Input matrix sizes do not conform in MQC_Matrix_Cmplx', 6, &
        'Size(Matrix1,1)',Size(Matrix1,1),'Size(Matrix2,1)',Size(Matrix2,1), &
        'Size(Matrix1,2)',Size(Matrix1,2),'Size(Matrix2,2)',Size(Matrix2,2))

      if(Matrix1%Data_Type.eq.'Complex'.or.Matrix2%Data_Type.eq.'Complex') &
        call mqc_error_a('Complex MQC matrix cannot be set as real/imaginary part in MQC_Matrix_Cmplx', &
        6,'Matrix1%Data_Type',Matrix1%Data_Type,'Matrix2%Data_Type',Matrix2%Data_Type)

      If(Matrix1%Storage.eq.'StorFull'.or.Matrix2%Storage.eq.'StorFull') then
        Storage = 'StorFull'
      ElseIf(Matrix1%Storage.eq.'StorSymm'.and.Matrix2%Storage.eq.'StorSymm') then
        Storage = 'StorSymm'
      ElseIf(Matrix1%Storage.eq.'StorSymm'.and.Matrix2%Storage.eq.'StorAsym') then
        Storage = 'StorHerm'
      ElseIf(Matrix1%Storage.eq.'StorSymm'.and.Matrix2%Storage.eq.'StorHerm') then
        Storage = 'StorSymm'
      ElseIf(Matrix1%Storage.eq.'StorSymm'.and.Matrix2%Storage.eq.'StorAhrm') then
        Storage = 'StorHerm'
      ElseIf(Matrix1%Storage.eq.'StorAsym'.and.Matrix2%Storage.eq.'StorSymm') then
        Storage = 'StorAhrm'
      ElseIf(Matrix1%Storage.eq.'StorAsym'.and.Matrix2%Storage.eq.'StorAsym') then
        Storage = 'StorAsym'
      ElseIf(Matrix1%Storage.eq.'StorAsym'.and.Matrix2%Storage.eq.'StorHerm') then
        Storage = 'StorAhrm'
      ElseIf(Matrix1%Storage.eq.'StorAsym'.and.Matrix2%Storage.eq.'StorAhrm') then
        Storage = 'StorAsym'
      ElseIf(Matrix1%Storage.eq.'StorHerm'.and.Matrix2%Storage.eq.'StorSymm') then
        Storage = 'StorSymm'
      ElseIf(Matrix1%Storage.eq.'StorHerm'.and.Matrix2%Storage.eq.'StorAsym') then
        Storage = 'StorHerm'
      ElseIf(Matrix1%Storage.eq.'StorHerm'.and.Matrix2%Storage.eq.'StorHerm') then
        Storage = 'StorSymm'
      ElseIf(Matrix1%Storage.eq.'StorHerm'.and.Matrix2%Storage.eq.'StorAhrm') then
        Storage = 'StorHerm'
      ElseIf(Matrix1%Storage.eq.'StorAhrm'.and.Matrix2%Storage.eq.'StorSymm') then
        Storage = 'StorAhrm'
      ElseIf(Matrix1%Storage.eq.'StorAhrm'.and.Matrix2%Storage.eq.'StorAsym') then
        Storage = 'StorAsym'
      ElseIf(Matrix1%Storage.eq.'StorAhrm'.and.Matrix2%Storage.eq.'StorHerm') then
        Storage = 'StorAhrm'
      ElseIf(Matrix1%Storage.eq.'StorAhrm'.and.Matrix2%Storage.eq.'StorAhrm') then
        Storage = 'StorAsym'
      ElseIf(Matrix1%Storage.eq.'StorDiag'.and.Matrix2%Storage.eq.'StorDiag') then
        Storage = 'StorDiag'
      ElseIf(Matrix1%Storage.eq.'StorDiag') then
        Storage = Matrix2%Storage
      ElseIf(Matrix2%Storage.eq.'StorDiag') then
        Storage = Matrix1%Storage
      Else
        Call MQC_Error('MQC_Matrix_Cmplx is confused')
      EndIf
        
      call mqc_allocate_matrix(Size(Matrix1,1),Size(Matrix1,2),MQC_Matrix_Cmplx, &
        'Complex',Storage)

      Tmp1 = Matrix1
      Tmp2 = Matrix2

      if(Tmp1%Storage.eq.'StorFull') then
        if(Tmp2%Storage.eq.'StorSymm'.or.Tmp2%Storage.eq.'StorAsym'.or. &
          Tmp2%Storage.eq.'StorHerm'.or.Tmp2%Storage.eq.'StorAhrm') &
          call mqc_matrix_symm2full(Tmp2)
        if(Tmp2%Storage.eq.'StorDiag') &
          call mqc_matrix_diag2full(Tmp2)
      elseIf(Tmp1%Storage.eq.'StorSymm'.or.Tmp1%Storage.eq.'StorAsym'.or. &
        Tmp1%Storage.eq.'StorHerm'.or.Tmp1%Storage.eq.'StorAhrm') then
        if(Tmp2%Storage.eq.'StorFull') &
          call mqc_matrix_symm2full(Tmp1)
        if(Tmp2%Storage.eq.'StorDiag') &
          call mqc_matrix_diag2symm(Tmp2)
      elseIf(Tmp1%Storage.eq.'StorDiag') then
        if(Tmp2%Storage.eq.'StorFull') &
          call mqc_matrix_diag2full(Tmp1)
        if(Tmp2%Storage.eq.'StorSymm'.or.Tmp2%Storage.eq.'StorAsym'.or. &
          Tmp2%Storage.eq.'StorHerm'.or.Tmp2%Storage.eq.'StorAhrm') &
          call mqc_matrix_diag2symm(Tmp1)
      endIf

      if(Tmp1%Data_Type.eq.'Integer') then
        if(Tmp2%Data_Type.eq.'Integer') then
          MQC_Matrix_Cmplx%MatC = cmplx(Tmp1%MatI,Tmp2%MatI)
        elseIf(Tmp2%Data_Type.eq.'Real') then
#ifdef PGI
          MQC_Matrix_Cmplx%MatC = cmplx(dfloat(Tmp1%MatI),Tmp2%MatR)
#else
          MQC_Matrix_Cmplx%MatC = cmplx(float(Tmp1%MatI),Tmp2%MatR)
#endif
        endIf
      elseIf(Tmp1%Data_Type.eq.'Real') then
        if(Tmp2%Data_Type.eq.'Integer') then
#ifdef PGI
          MQC_Matrix_Cmplx%MatC = cmplx(Tmp1%MatR,dfloat(Tmp2%MatI))
#else
          MQC_Matrix_Cmplx%MatC = cmplx(Tmp1%MatR,float(Tmp2%MatI))
#endif
        elseIf(Tmp2%Data_Type.eq.'Real') then
          MQC_Matrix_Cmplx%MatC = cmplx(Tmp1%MatR,Tmp2%MatR)
        endIf
      endIf
!
      Return
      End Function MQC_Matrix_Cmplx
!
!
!     PROCEDURE MQC_Matrix_Complex_Conjugate
!
!>    \brief <b> MQC_Matrix_Complex_Conjugate is a function that returns the complex conjugate 
!>    of an MQC_Matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Complex_Conjugate is a function that returns the complex conjugate of an 
!>    MQC_Matrix. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MatrixIn
!>    \verbatim
!>        MatrixIn is Type(MQC_Matrix)
!>        The MQC_Matrix input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_Matrix_Complex_Conjugate(MatrixIn) Result(MatrixOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(In)::MatrixIn
      Type(MQC_Matrix)::MatrixOut
!
      MatrixOut = MatrixIn
      If(MatrixIn%Data_Type.eq.'Complex') MatrixOut%MatC = conjg(MatrixIn%MatC)
!
      Return
      End Function MQC_Matrix_Complex_Conjugate
!
!
!     PROCEDURE MQC_Matrix_Reshape_Vector
!
!>    \brief <b> MQC_Matrix_Reshape_Vector is a function that reshapes an MQC matrix as an
!>    MQC vector</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Matrix_Reshape_Vector is a function that reshapes an MQC matrix as an MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] MatrixIn
!>    \verbatim
!>        MatrixIn is Type(MQC_Matrix)
!>        The MQC_Matrix input variable.
!>    \endverbatim
!>
!>    \param[in] DimArr
!>    \verbatim
!>        DimArr is Type(MQC_Vector)
!>        The dimensions of the MQC Vector output.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_Matrix_Reshape_Vector(MatrixIn,DimArr) Result(VectorOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_Matrix),Intent(In)::MatrixIn
      Integer(kind=int64),dimension(1),intent(in)::DimArr
      type(MQC_Vector)::VectorOut
      integer(kind=int64),dimension(:,:),allocatable::intMatrix
      real(kind=real64),dimension(:,:),allocatable::realMatrix
      complex(kind=real64),dimension(:,:),allocatable::compMatrix
!
      If((Size(MatrixIn,1)*Size(MatrixIn,2)).gt.DimArr(1)) Call MQC_Error_I('Matrix not conformable &
        &with requested dimensions',6,'Size(MatrixIn,1)*Size(MatrixIn,2)',Size(MatrixIn,1)*Size(MatrixIn,2), &
        'DimArr(1)',DimArr(1))
!
      select case(MatrixIn%Data_Type)
      case('Integer')
        intMatrix = MatrixIn
        VectorOut = reshape(intMatrix,[DimArr(1)]) 
      case('Real')
        realMatrix = MatrixIn
        VectorOut = reshape(realMatrix,[DimArr(1)]) 
      case('Complex')
        compMatrix = MatrixIn
        VectorOut = reshape(compMatrix,[DimArr(1)]) 
      case default
        call mqc_error_a('Unrecognized data type in MatrixIn in MQC_Matrix_Reshape_Vector',6,&
          'MatrixIn%Data_Type',MatrixIn%Data_Type)
      end select
!
      Return
      End Function MQC_Matrix_Reshape_Vector
!
!
!     PROCEDURE MQC_Matrix_MPInv
!
!>    \brief <b> MQC_Matrix_MPInv is a function that returns the Moore-Penrose 
!>    psuedoinverse of a MQC matrix</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_MPInv is a function that returns the Moore-Penrose psuedoinverse 
!>    of a MQC matrix.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A 
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The MQC matrix to psuedoinvert.
!>    \endverbatim
!>
!>    \param[in] tol
!>    \verbatim
!>        Tol is Class(*),Optional
!>        Tolerance used for zero threshold. The default value is 
!>        eps*max(size(A,1),size(A,2))*max(SMat) suggested in
!>        Klimczak, M.; Cecot, W. Math. Probl. Eng. 2019, 2019(3), 
!>        5060397. 
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_Matrix_MPInv(A,tol) Result(PInv)
!
      Implicit None
      Class(MQC_Matrix)::A
!
      Type(MQC_Matrix)::EUVecs,EVVecs,SMat
      Type(MQC_Vector)::EVals
      Type(MQC_Matrix)::PInv
      Type(MQC_Scalar)::Thresh,Zero
      class(*),optional::tol
      Integer(kind=int64)::I
!
      call A%SVD(EVals,EUVecs,EVVecs)
      if(present(tol)) then
        select type (tol)
        type is (integer)
          thresh = tol
        type is (real)
          thresh = tol
        type is (complex)
          thresh = tol
        type is (mqc_scalar)
          thresh = tol
        class default
          call mqc_error('Tolerance type not defined in MQC_Matrix_MPInv')
        end select
      else
        thresh = evals%maxval()*epsilon(1.0e0)*max(size(A,1),size(A,2))
      endif
      Zero = 0.0e0

      Do I = 1, Size(EVals)
        If(EVals%at(I).gt.Thresh) then
          call EVals%put(1.0/EVals%at(I),I)
        else
          call EVals%put(zero,I)
        endIf
      EndDo
      call EVals%diag(SMat)
      PInv = matmul(matmul(dagger(EVVecs),SMat),dagger(EUVecs))
!      
      Return
      End Function MQC_Matrix_MPInv
!
!
!     PROCEDURE MQC_Matrix_Sum
!
!>    \brief <b> MQC_Matrix_Sum is a function that returns the sum of all elements 
!>    of an MQC matrix</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Sum is a function that returns the sum of all elements of an MQC
!>    matrix.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The name of the MQC_Matrix variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      function mqc_matrix_sum(A) result(output)
!
      Implicit None
      class(mqc_matrix),intent(in)::A
      type(mqc_scalar)::output
      integer(kind=int64)::i,j
!
!     Do the work.
!
      output = 0.0
      do i=1,size(A,1)
        do j=1,size(A,2)
          output = output + A%at(i,j)
        endDo
      endDo
!
      end function mqc_matrix_sum

!
!
!     PROCEDURE MQC_Matrix_Partial_Sum
!
!>    \brief <b> MQC_Matrix_Partial_Sum is a function that returns the sum of all 
!>    rows or columns elemente of an MQC matrix and returns a MQC vector.</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Partial_Sum is a function that returns the sum of all 
!>    rows or columns elemente of an MQC matrix and returns a MQC vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The name of the MQC_Matrix variable.
!>    \endverbatim
!>    \param[in] indexnum
!>    \verbatim
!>        indexnum is integer(kind=int64),optional
!>        The index that will be summed over (1 or 2).
!>        default=1
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2024
!
      function mqc_matrix_partial_sum(A,indexnum) result(output)
!
      Implicit None
      class(mqc_matrix),intent(in)::A
      integer(kind=int64),optional::indexnum
      type(mqc_vector)::output
      integer(kind=int64)::i,j,ind

      ind = 1
      if(present(indexnum)) ind = indexnum
        
      if (ind.eq.1) then
        call output%init(size(A,2))
        do j=1,size(A,2)
          do i=1,size(A,1)
            call output%put(output%at(j) + A%at(i,j) , j)
          endDo
        endDo
      else if (ind.eq.2) then
        call output%init(size(A,1))
        do j=1,size(A,1)
          do i=1,size(A,2)
            call output%put(output%at(j) + A%at(j,i) , j)
          endDo
        endDo
      else
        Call MQC_Error_I('Index out of range MQC_Matrix_Partial_Sum', 6, &
                         'index', ind )
      end if
!
      end function mqc_matrix_partial_sum

!
!
!     PROCEDURE MQC_Matrix_Power
!
!>    \brief <b> MQC_Matrix_Power is a function that returns the value of a
!>    MQC matrix raised to a power</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Matrix_Power is a function that returns the value of a MQC matrix raised
!>    to a power. The power can be integer, real, complex or an MQC scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] A
!>    \verbatim
!>        A is Class(MQC_Matrix)
!>        The name of the MQC_Matrix variable.
!>    \endverbatim
!>
!>    \param[in] P
!>    \verbatim
!>        P is Class(*)
!>        The power to raise elements of the MQC vector.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      subroutine mqc_matrix_power(A,P)
!
      Implicit None
      class(mqc_matrix),intent(inOut)::A
      class(*)::P
      type(mqc_vector)::sVals
      type(mqc_matrix)::uMatrix
      type(mqc_scalar)::scalar
!
!     Do the work.
!
      select type(P)
      type is (integer)
        scalar = P
      type is (real)
        scalar = P
      type is (complex)
        scalar = P
      type is (mqc_scalar)
        scalar = P
      class default
        call mqc_error_I('P type not defined in MQC_Vector_Power',6)
      end select
!
      call A%eigensys(eigenvals=sVals,reigenvecs=uMatrix)
!      call A%diag(evals=sVals,evecs=uMatrix)
      call sVals%power(scalar)
      call sVals%diag(A)
      A = matmul(matmul(uMatrix,A),dagger(uMatrix))
!
      end subroutine mqc_matrix_power
!
!
!----------------------------------------------------------------
!                                                               |
!     R4TENSOR PROCEDURES                                       |
!                                                               |
!----------------------------------------------------------------
!
!
!     PROCEDURE MQC_Allocate_R4Tensor
!
!>    \brief <b> MQC_Allocate_R4Tensor is used to allocate a rank-4 tensor type 
!>    variable of the MQC_R4Tensor class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Allocate_R4Tensor is a subroutine used to allocate a rank-4 tensor type 
!>    variable of the MQC_R4Tensor class. The following options are available:
!>
!>    1. Data_Type = 'Real' declares the MQC_R4Tensor variable to be of real type. 
!>    2. Data_Type = 'Integer' declares the MQC_R4Tensor variable to be of integer type.
!>    3. Data_Type = 'Complex' declares the MQC_R4Tensor variable to be of complex type.
!>    4. Storage = 'StorFull' declares the MQC_R4Tensor variable to be unpacked.
!>    5. Storage = 'StorSymm' declares the MQC_R4Tensor variable to be symmetric packed.
!>
!>    TODO: Extend storage types for R4Tensor
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] I
!>    \verbatim
!>        I is Integer(kind=int64)
!>        I is the first dimension of Tensor. 
!>    \endverbatim
!>    
!>    \param[in] J
!>    \verbatim
!>        J is Integer(kind=int64)
!>        J is the second dimension of Tensor.
!>    \endverbatim
!>    
!>    \param[in] K
!>    \verbatim
!>        K is Integer(kind=int64)
!>        K is the second dimension of Tensor.
!>    \endverbatim
!>    
!>    \param[in] L
!>    \verbatim
!>        L is Integer(kind=int64)
!>        L is the second dimension of Tensor.
!>    \endverbatim
!>    
!>    \param[in,out] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be allocated.
!>    \endverbatim
!>
!>    \param[in] Data_Type
!>    \verbatim
!>        Data_Type is Character(Len=*)
!>        = 'Real':    the MQC_R4Tensor is real
!>        = 'Integer': the MQC_R4Tensor is integer
!>        = 'Complex': the MQC_R4Tensor is complex.
!>    \endverbatim
!>
!>    \param[in] Storage  
!>    \verbatim
!>        Storage is Character(Len=*)
!>        = 'StorFull': the MQC_R4Tensor is unpacked
!>        = 'StorSymm': the MQC_R4Tensor is symmetric-packed
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2016
!
      Subroutine MQC_Allocate_R4Tensor(I,J,K,L,Tensor,Data_Type,Storage)
!
      Implicit None
      Integer(kind=int64),Intent(In)::I,J,K,L
      Character(Len=*),Intent(In)::Data_Type,Storage
      Type(MQC_R4Tensor),Intent(InOut)::Tensor
      Integer(kind=int64)::ICur,JCur,KCur,LCur

      If (I.lt.0 .or. J.lt.0 .or. K.lt.0 .or. L.lt.0) then
        Call MQC_Error_I('Dimensions less than zero in MQC_Allocate_R4Tensor', 6, &
             'I', I, &
             'J', J, &
             'K', K, &
             'L', L )
      EndIf

      Call MQC_Deallocate_R4Tensor(Tensor)

      If(Storage.eq.'StorFull' .or. Storage.eq.'Full' .or. Storage.eq.'full' .or. Storage.eq.'storfull') then
        Tensor%Storage = 'StorFull'
        ICur = I
        JCur = J
        KCur = K
        LCur = L
      ElseIf(Storage.eq.'StorSymm' .or. Storage.eq.'Symm' .or. Storage.eq.'symm' .or. Storage.eq.'storsymm') then
        If(I.ne.J.and.I.ne.K.and.I.ne.L) Call MQC_Error_I('Attempting to assign rank-4 tensor of variable dimensions to &
     &    symmetric form in MQC_Allocate_R4Tensor', 6, 'I', I, 'J', J, 'K', K, 'L', L)
        Tensor%Storage = 'StorSymm'
        ICur = (I**4+2*I**3+3*I**2+2*I)/8
        JCur = 1
        KCur = 1
        LCur = 1
      Else
        Call MQC_Error_A('Storage type not recognised in MQC_Allocate_R4Tensor', 6, &
             'Storage', Storage)
      EndIf

      If(Data_Type.eq.'Integer' .or. Data_Type.eq.'integer' .or. Data_Type.eq.'Int' .or. Data_Type.eq.'int') then
        Tensor%Data_Type = 'Integer'
        If(Allocated(Tensor%ITen)) Deallocate(Tensor%ITen)
        Allocate(Tensor%ITen(ICur,JCur,KCur,LCur))
      ElseIf(Data_Type.eq.'Real' .or. Data_Type.eq.'real') then
        Tensor%Data_Type = 'Real'
        If(Allocated(Tensor%RTen)) Deallocate(Tensor%RTen)
        Allocate(Tensor%RTen(ICur,JCur,KCur,LCur))
      ElseIf(Data_Type.eq.'Complex' .or. Data_Type.eq.'complex') then
        Tensor%Data_Type = 'Complex'
        If(Allocated(Tensor%CTen)) Deallocate(Tensor%CTen)
        Allocate(Tensor%CTen(ICur,JCur,KCur,LCur))
      EndIf

      Tensor%I = I
      Tensor%J = J
      Tensor%K = K
      Tensor%L = L

      End Subroutine mqc_allocate_r4tensor
!
!
!     PROCEDURE MQC_Deallocate_R4Tensor
!
!>    \brief <b> MQC_Deallocate_R4Tensor is used to deallocate a rank-4 tensor type 
!>    variable of the MQC_R4Tensor class</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Deallocate_R4Tensor is a subroutine used to deallocate a rank-4 tensor type 
!>    variable of the MQC_R4Tensor class. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be deallocated.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author X. Sheng
!>    \date 2016
!
      Subroutine MQC_Deallocate_R4Tensor(Tensor)
!
!     This subroutine deallocates an MQC_R4Tensor rank-4 tensor.
!
      Implicit None
      Type(MQC_R4Tensor),Intent(InOut)::Tensor
!
      If(Allocated(Tensor%ITen)) Deallocate(Tensor%ITen)
      If(Allocated(Tensor%RTen)) Deallocate(Tensor%RTen)
      If(Allocated(Tensor%CTen)) Deallocate(Tensor%CTen)
      Tensor%Data_Type = ''
      Tensor%Storage = ''
      Tensor%I = 0
      Tensor%J = 0
      Tensor%K = 0
      Tensor%L = 0

      End Subroutine MQC_Deallocate_R4Tensor
!
!
!     PROCEDURE MQC_R4Tensor_At_Scalar
!
!>    \brief <b> MQC_R4Tensor_At_Scalar is a function that returns the value of an  
!>    element of a MQC rank-4 tensor using MQC Scalar indices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_At_Scalar is a function that returns the value of (I,J,K,L)th 
!>    element of a MQC rank-4 tensor as an MQC scalar using MQC Scalar indices. 
!>    If I, J, K or L is negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to return the value of the 
!>        (I,J,K,L)th element.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Type(MQC_Scalar)
!>        The first dimension of the element in MQC rank-4 tensor
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Type(MQC_Scalar)
!>        The second dimension of the element in MQC rank-4 tensor
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] K  
!>    \verbatim
!>        K is Type(MQC_Scalar)
!>        The third dimension of the element in MQC rank-4 tensor
!>          If K>0 row count is from first index
!>          If K<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] L  
!>    \verbatim
!>        L is Type(MQC_Scalar)
!>        The fourth dimension of the element in MQC rank-4 tensor
!>          If L>0 row count is from first index
!>          If L<0 row count is from last index.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Function MQC_R4Tensor_At_Scalar(Tensor,I,J,K,L) Result(Element)
!
      Implicit None
      Class(MQC_R4Tensor),Intent(In)::Tensor
      Type(MQC_Scalar)::Element
      Type(MQC_Scalar),Intent(In)::I,J,K,L
      Integer(kind=int64)::IndI,IndJ,IndK,IndL

      IndI = I
      IndJ = J
      IndK = K
      IndL = L
      Element = MQC_R4Tensor_At_Int(Tensor,IndI,IndJ,IndK,IndL) 

      End Function MQC_R4Tensor_At_Scalar
!
!     PROCEDURE MQC_R4Tensor_At_Int
!
!>    \brief <b> MQC_R4Tensor_At_Int is a function that returns the value of an  
!>    element of a MQC rank-4 tensor using integer indices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_At_Int is a function that returns the value of (I,J,K,L)th element 
!>    of a MQC rank-4 tensor as an MQC scalar using integer indices. If I, J, K or L 
!>    is negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to return the value of the 
!>        (I,J,K,L)th element.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Integer
!>        The first dimension of the element in MQC rank-4 tensor
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Integer
!>        The second dimension of the element in MQC rank-4 tensor
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] K  
!>    \verbatim
!>        K is Integer
!>        The third dimension of the element in MQC rank-4 tensor
!>          If K>0 row count is from first index
!>          If K<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] L  
!>    \verbatim
!>        L is Integer
!>        The fourth dimension of the element in MQC rank-4 tensor
!>          If L>0 row count is from first index
!>          If L<0 row count is from last index.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Function MQC_R4Tensor_At_int(Tensor,I,J,K,L) Result(Element)
!
      Implicit None
      Class(MQC_R4Tensor),Intent(In)::Tensor
      Type(MQC_Scalar)::Element
      Integer,Intent(In)::I,J,K,L
      Integer(kind=int64)::IndI,IndJ,IndK,IndL

      IndI = I
      IndJ = J
      IndK = K
      IndL = L

      If (IndI.lt.0) IndI = Tensor%I + IndI + 1
      If (IndJ.lt.0) IndJ = Tensor%J + IndJ + 1
      If (IndK.lt.0) IndK = Tensor%K + IndK + 1
      If (IndL.lt.0) IndL = Tensor%L + IndL + 1

      If (IndI.eq.0.or.IndI.gt.Tensor%I) Call MQC_Error_I('Index I badly specified in mqc_r4tensor_at', 6, &
           'IndI', IndI, &
           'Tensor%I', Tensor%I )
      If (IndJ.eq.0.or.IndJ.gt.Tensor%J) Call MQC_Error_I('Index J badly specified in mqc_r4tensor_at', 6, &
           'IndJ', IndJ, &
           'Tensor%J', Tensor%J )
      If (IndK.eq.0.or.IndK.gt.Tensor%K) Call MQC_Error_I('Index K badly specified in mqc_r4tensor_at', 6, &
           'IndK', IndK, &
           'Tensor%K', Tensor%K )
      If (IndL.eq.0.or.IndL.gt.Tensor%L) Call MQC_Error_I('Index L badly specified in mqc_r4tensor_at', 6, &
           'IndL', IndL, &
           'Tensor%L', Tensor%L )
      
      If(Tensor%Storage.eq.'StorFull') then
        If(Tensor%Data_Type.eq.'Integer') then
          Element = (Tensor%ITen(IndI,IndJ,IndK,IndL))
        ElseIf(Tensor%Data_Type.eq.'Real') then
          Element = (Tensor%RTen(IndI,IndJ,IndK,IndL))
        ElseIf(Tensor%Data_Type.eq.'Complex') then
          Element = (Tensor%CTen(IndI,IndJ,IndK,IndL))
        Else
          Call MQC_Error_A('Tensor type not defined in MQC_R4Tensor_At', 6, &
               'Tensor%Data_Type', Tensor%Data_Type )
        EndIf
      ElseIf(Tensor%Storage.eq.'StorSymm') then
        If(Tensor%Data_Type.eq.'Integer') then
          Element = Tensor%ITen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1)
        ElseIf(Tensor%Data_Type.eq.'Real') then
          Element = Tensor%RTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1)
        ElseIf(Tensor%Data_Type.eq.'Complex') then
          Element = Tensor%CTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1)
        Else
          Call MQC_Error_A('Tensor type not defined in MQC_R4Tensor_At', 6, &
            'Tensor%Data_Type', Tensor%Data_Type )
        EndIf
      Else
        Call MQC_Error_A('Storage type not defined in MQC_R4Tensor_At', 6, &
          'Tensor%Storage', Tensor%Storage )
      EndIf

      End Function MQC_R4Tensor_At_Int
!
!
!     PROCEDURE MQC_R4Tensor_Put_Scalar
!
!>    \brief <b> MQC_R4Tensor_Put_Scalar is a subroutine that updates the value of an  
!>    element of a MQC rank-4 tensor using MQC Scalar indices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Put_Scalar is a subroutine that updates the value of (I,J,K,L)th 
!>    element of a MQC rank-4 tensor using MQC_Scalar indices. If I, J, K or L is 
!>    negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to update at the (I,J,K,L)th 
!>        element.
!>    \endverbatim
!>    
!>    \param[in] ElementIn
!>    \verbatim
!>        Element is Class(*)
!>        The value to update the specified element of Tensor.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Type(MQC_Scalar)
!>        The first dimension of the element in MQC rank-4 tensor
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Type(MQC_Scalar)
!>        The second dimension of the element in MQC rank-4 tensor
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] K  
!>    \verbatim
!>        K is Type(MQC_Scalar)
!>        The third dimension of the element in MQC rank-4 tensor
!>          If K>0 row count is from first index
!>          If K<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] L  
!>    \verbatim
!>        L is Type(MQC_Scalar)
!>        The fourth dimension of the element in MQC rank-4 tensor
!>          If L>0 row count is from first index
!>          If L<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] SymmFlag  
!>    \verbatim
!>        SymmFlag is Character(Len=*),Optional
!>        Whether to add value to tensor symmetrically
!>        = 'no symm': do not add symmetrically
!>        = 'symm:' add value in 8-fold symmetry locations.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2021
!
      Subroutine MQC_R4Tensor_Put_Scalar(Tensor,ElementIn,I,J,K,L,SymmFlag)
!
      Implicit None
      Type(MQC_Scalar),Intent(In)::I,J,K,L
      Class(MQC_R4Tensor),Intent(InOut)::Tensor
      Class(*),Intent(In)::ElementIn
      Integer(kind=int64)::IndI,IndJ,IndK,IndL
      Character(Len=*),Intent(In),Optional::SymmFlag

      IndI = I
      IndJ = J
      IndK = K
      IndL = L
      Call MQC_R4Tensor_Put_Int(Tensor,ElementIn,IndI,IndJ,IndK,IndL,SymmFlag)

      End Subroutine MQC_R4Tensor_Put_Scalar
!
!
!     PROCEDURE MQC_R4Tensor_Put_Int
!
!>    \brief <b> MQC_R4Tensor_Put_Int is a subroutine that updates the value of an  
!>    element of a MQC rank-4 tensor unsing integer indices</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Put_Int is a subroutine that updates the value of (I,J,K,L)th 
!>    element of a MQC rank-4 tensor using integer indices. If I, J, K or L is 
!>    negative, the (N-I+1)th index is selected.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to update at the (I,J,K,L)th 
!>        element.
!>    \endverbatim
!>    
!>    \param[in] ElementIn
!>    \verbatim
!>        Element is Class(*)
!>        The value to update the specified element of Tensor.
!>    \endverbatim
!>    
!>    \param[in] I  
!>    \verbatim
!>        I is Integer
!>        The first dimension of the element in MQC rank-4 tensor
!>          If I>0 row count is from first index
!>          If I<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] J  
!>    \verbatim
!>        J is Integer
!>        The second dimension of the element in MQC rank-4 tensor
!>          If J>0 row count is from first index
!>          If J<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] K  
!>    \verbatim
!>        K is Integer
!>        The third dimension of the element in MQC rank-4 tensor
!>          If K>0 row count is from first index
!>          If K<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] L  
!>    \verbatim
!>        L is Integer
!>        The fourth dimension of the element in MQC rank-4 tensor
!>          If L>0 row count is from first index
!>          If L<0 row count is from last index.
!>    \endverbatim
!>    
!>    \param[in] SymmFlag  
!>    \verbatim
!>        SymmFlag is Character(Len=*),Optional
!>        Whether to add value to tensor symmetrically
!>        = 'no symm': do not add symmetrically
!>        = 'symm:' add value in 8-fold symmetry locations.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_R4Tensor_Put_Int(Tensor,ElementIn,I,J,K,L,SymmFlag)
!
      Implicit None
      Integer,Intent(In)::I,J,K,L
      Class(MQC_R4Tensor),Intent(InOut)::Tensor
      Class(*),Intent(In)::ElementIn
      Type(MQC_Scalar)::Element
      Integer(kind=int64)::IndI,IndJ,IndK,IndL
      Character(Len=*),Intent(In),Optional::SymmFlag
      Character(Len=64)::my_SymmFlag

      IndI = I
      IndJ = J
      IndK = K
      IndL = L

      Select Type (ElementIn)
      Type Is (Integer)
        Element = ElementIn
      Type Is (Real)
        Element = ElementIn
      Type Is (Complex)
        Element = ElementIn
      Type Is (MQC_Scalar)
        Element = ElementIn
      Class Default
        Call MQC_Error_I('ElementIn type not defined in MQC_R4Tensor_Put',6)
      End Select

      If(Present(SymmFlag)) then
        my_SymmFlag = SymmFlag
      Else
        my_SymmFlag = 'no symm'
      EndIf
      If(my_SymmFlag.ne.'no symm'.and.my_SymmFlag.ne.'symm') Call MQC_Error_A('Unrecognized symmetry flag in &
    &   mqc_r4tensor_put',6,'my_SymmFlag',my_SymmFlag)

      If (IndI.lt.0) IndI = Tensor%I + IndI + 1
      If (IndJ.lt.0) IndJ = Tensor%J + IndJ + 1
      If (IndK.lt.0) IndK = Tensor%K + IndI + 1
      If (IndL.lt.0) IndL = Tensor%L + IndJ + 1
      If (IndI.eq.0.or.IndI.gt.Tensor%I) Call MQC_Error_I('Index I badly specified in mqc_r4tensor_put', 6, &
           'IndI', IndI, &
           'Tensor%I', Tensor%I)
      If (IndJ.eq.0.or.IndJ.gt.Tensor%J) Call MQC_Error_I('Index J badly specified in mqc_r4tensor_put', 6, &
           'IndJ', IndJ, &
           'Tensor%J', Tensor%J)
      If (IndK.eq.0.or.IndK.gt.Tensor%K) Call MQC_Error_I('Index K badly specified in mqc_r4tensor_put', 6, &
           'IndK', IndK, &
           'Tensor%K', Tensor%K)
      If (IndL.eq.0.or.IndL.gt.Tensor%L) Call MQC_Error_I('Index L badly specified in mqc_r4tensor_put', 6, &
           'IndL', IndL, &
           'Tensor%L', Tensor%L)


      If(my_SymmFlag.eq.'no symm'.and.MQC_R4Tensor_HaveSymmetric(Tensor).and. &
        .not.((IndI.eq.IndJ).and.(IndI.eq.IndK).and.(IndI.eq.IndL))) &
        Call MQC_R4Tensor_Symm2Full(Tensor) 


      If(MQC_R4Tensor_HaveFull(Tensor)) then
        If (Tensor%Data_Type.eq.'Integer') then
          If (Element%Data_Type.eq.'Integer') then
            If(my_SymmFlag.eq.'no symm') then
              Tensor%ITen(IndI,IndJ,IndK,IndL) = Element%ScaI
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%ITen(IndI,IndJ,IndK,IndL) = Element%ScaI
              Tensor%ITen(IndJ,IndI,IndK,IndL) = Element%ScaI
              Tensor%ITen(IndI,IndJ,IndL,IndK) = Element%ScaI
              Tensor%ITen(IndJ,IndI,IndL,IndK) = Element%ScaI
              Tensor%ITen(IndK,IndL,IndI,IndJ) = Element%ScaI
              Tensor%ITen(IndL,IndK,IndI,IndJ) = Element%ScaI
              Tensor%ITen(IndK,IndL,IndJ,IndI) = Element%ScaI
              Tensor%ITen(IndL,IndK,IndJ,IndI) = Element%ScaI
            EndIf
          ElseIf (Element%Data_Type.eq.'Real') then
            Call MQC_R4Tensor_Copy_Int2Real(Tensor)  
            If(my_SymmFlag.eq.'no symm') then
              Tensor%RTen(IndI,IndJ,IndK,IndL) = Element%ScaR
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%RTen(IndI,IndJ,IndK,IndL) = Element%ScaR
              Tensor%RTen(IndJ,IndI,IndK,IndL) = Element%ScaR
              Tensor%RTen(IndI,IndJ,IndL,IndK) = Element%ScaR
              Tensor%RTen(IndJ,IndI,IndL,IndK) = Element%ScaR
              Tensor%RTen(IndK,IndL,IndI,IndJ) = Element%ScaR
              Tensor%RTen(IndL,IndK,IndI,IndJ) = Element%ScaR
              Tensor%RTen(IndK,IndL,IndJ,IndI) = Element%ScaR
              Tensor%RTen(IndL,IndK,IndJ,IndI) = Element%ScaR
            EndIf
          ElseIf (Element%Data_Type.eq.'Complex') then
            Call MQC_R4Tensor_Copy_Int2Complex(Tensor)  
            If(my_SymmFlag.eq.'no symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaC
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaC
              Tensor%CTen(IndJ,IndI,IndK,IndL) = Element%ScaC
              Tensor%CTen(IndI,IndJ,IndL,IndK) = Element%ScaC
              Tensor%CTen(IndJ,IndI,IndL,IndK) = Element%ScaC
              Tensor%CTen(IndK,IndL,IndI,IndJ) = Element%ScaC
              Tensor%CTen(IndL,IndK,IndI,IndJ) = Element%ScaC
              Tensor%CTen(IndK,IndL,IndJ,IndI) = Element%ScaC
              Tensor%CTen(IndL,IndK,IndJ,IndI) = Element%ScaC
            EndIf
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_R4Tensor_Put', 6, &
                 'Element%Data_Type', Element%Data_Type, &
                 'Tensor%Data_Type', Tensor%Data_Type )
          EndIf
        ElseIf (Tensor%Data_Type.eq.'Real') then
          If (Element%Data_Type.eq.'Integer') then
            If(my_SymmFlag.eq.'no symm') then
              Tensor%RTen(IndI,IndJ,IndK,IndL) = Element%ScaI
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%RTen(IndI,IndJ,IndK,IndL) = Element%ScaI
              Tensor%RTen(IndJ,IndI,IndK,IndL) = Element%ScaI
              Tensor%RTen(IndI,IndJ,IndL,IndK) = Element%ScaI
              Tensor%RTen(IndJ,IndI,IndL,IndK) = Element%ScaI
              Tensor%RTen(IndK,IndL,IndI,IndJ) = Element%ScaI
              Tensor%RTen(IndL,IndK,IndI,IndJ) = Element%ScaI
              Tensor%RTen(IndK,IndL,IndJ,IndI) = Element%ScaI
              Tensor%RTen(IndL,IndK,IndJ,IndI) = Element%ScaI
            EndIf
          ElseIf (Element%Data_Type.eq.'Real') then
            If(my_SymmFlag.eq.'no symm') then
              Tensor%RTen(IndI,IndJ,IndK,IndL) = Element%ScaR
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%RTen(IndI,IndJ,IndK,IndL) = Element%ScaR
              Tensor%RTen(IndJ,IndI,IndK,IndL) = Element%ScaR
              Tensor%RTen(IndI,IndJ,IndL,IndK) = Element%ScaR
              Tensor%RTen(IndJ,IndI,IndL,IndK) = Element%ScaR
              Tensor%RTen(IndK,IndL,IndI,IndJ) = Element%ScaR
              Tensor%RTen(IndL,IndK,IndI,IndJ) = Element%ScaR
              Tensor%RTen(IndK,IndL,IndJ,IndI) = Element%ScaR
              Tensor%RTen(IndL,IndK,IndJ,IndI) = Element%ScaR
            EndIf
          ElseIf (Element%Data_Type.eq.'Complex') then
            Call MQC_R4Tensor_Copy_Real2Complex(Tensor)  
            If(my_SymmFlag.eq.'no symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaC
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaC
              Tensor%CTen(IndJ,IndI,IndK,IndL) = Element%ScaC
              Tensor%CTen(IndI,IndJ,IndL,IndK) = Element%ScaC
              Tensor%CTen(IndJ,IndI,IndL,IndK) = Element%ScaC
              Tensor%CTen(IndK,IndL,IndI,IndJ) = Element%ScaC
              Tensor%CTen(IndL,IndK,IndI,IndJ) = Element%ScaC
              Tensor%CTen(IndK,IndL,IndJ,IndI) = Element%ScaC
              Tensor%CTen(IndL,IndK,IndJ,IndI) = Element%ScaC
            EndIf
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_R4Tensor_Put', 6, &
                 'Element%Data_Type', Element%Data_Type, &
                 'Tensor%Data_Type', Tensor%Data_Type )
          EndIf
        ElseIf (Tensor%Data_Type.eq.'Complex') then
          If (Element%Data_Type.eq.'Integer') then
            If(my_SymmFlag.eq.'no symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaI
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaI
              Tensor%CTen(IndJ,IndI,IndK,IndL) = Element%ScaI
              Tensor%CTen(IndI,IndJ,IndL,IndK) = Element%ScaI
              Tensor%CTen(IndJ,IndI,IndL,IndK) = Element%ScaI
              Tensor%CTen(IndK,IndL,IndI,IndJ) = Element%ScaI
              Tensor%CTen(IndL,IndK,IndI,IndJ) = Element%ScaI
              Tensor%CTen(IndK,IndL,IndJ,IndI) = Element%ScaI
              Tensor%CTen(IndL,IndK,IndJ,IndI) = Element%ScaI
            EndIf
          ElseIf (Element%Data_Type.eq.'Real') then
            If(my_SymmFlag.eq.'no symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaR
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaR
              Tensor%CTen(IndJ,IndI,IndK,IndL) = Element%ScaR
              Tensor%CTen(IndI,IndJ,IndL,IndK) = Element%ScaR
              Tensor%CTen(IndJ,IndI,IndL,IndK) = Element%ScaR
              Tensor%CTen(IndK,IndL,IndI,IndJ) = Element%ScaR
              Tensor%CTen(IndL,IndK,IndI,IndJ) = Element%ScaR
              Tensor%CTen(IndK,IndL,IndJ,IndI) = Element%ScaR
              Tensor%CTen(IndL,IndK,IndJ,IndI) = Element%ScaR
            EndIf
          ElseIf (Element%Data_Type.eq.'Complex') then
            If(my_SymmFlag.eq.'no symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaC
            ElseIf(my_SymmFlag.eq.'symm') then
              Tensor%CTen(IndI,IndJ,IndK,IndL) = Element%ScaC
              Tensor%CTen(IndJ,IndI,IndK,IndL) = Element%ScaC
              Tensor%CTen(IndI,IndJ,IndL,IndK) = Element%ScaC
              Tensor%CTen(IndJ,IndI,IndL,IndK) = Element%ScaC
              Tensor%CTen(IndK,IndL,IndI,IndJ) = Element%ScaC
              Tensor%CTen(IndL,IndK,IndI,IndJ) = Element%ScaC
              Tensor%CTen(IndK,IndL,IndJ,IndI) = Element%ScaC
              Tensor%CTen(IndL,IndK,IndJ,IndI) = Element%ScaC
            EndIf
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_R4Tensor_Put', 6, &
                 'Element%Data_Type', Element%Data_Type, &
                 'Tensor%Data_Type', Tensor%Data_Type )
          EndIf
        Else
          Call MQC_Error_A('Tensor type not defined in MQC_R4Tensor_Put', 6, &
               'Tensor%Data_Type', Tensor%Data_Type )
        EndIf
      ElseIf(MQC_R4Tensor_HaveSymmetric(Tensor)) then
        If (Tensor%Data_Type.eq.'Integer') then
          If (Element%Data_Type.eq.'Integer') then
            Tensor%ITen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaI
          ElseIf (Element%Data_Type.eq.'Real') then
            Tensor%ITen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaR
          ElseIf (Element%Data_Type.eq.'Complex') then
            Tensor%ITen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaC
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_R4Tensor_Put', 6, &
                 'Element%Data_Type', Element%Data_Type, &
                 'Tensor%Data_Type', Tensor%Data_Type )
          EndIf
        ElseIf (Tensor%Data_Type.eq.'Real') then
          If (Element%Data_Type.eq.'Integer') then
            Tensor%RTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaI
          ElseIf (Element%Data_Type.eq.'Real') then
            Tensor%RTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaR
          ElseIf (Element%Data_Type.eq.'Complex') then
            Tensor%RTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaC
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_R4Tensor_Put', 6, &
                 'Element%Data_Type', Element%Data_Type, &
                 'Tensor%Data_Type', Tensor%Data_Type )
          EndIf
        ElseIf (Tensor%Data_Type.eq.'Complex') then
          If (Element%Data_Type.eq.'Integer') then
            Tensor%CTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaI
          ElseIf (Element%Data_Type.eq.'Real') then
            Tensor%CTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaR
          ElseIf (Element%Data_Type.eq.'Complex') then
            Tensor%CTen(symIndexHash(IndI,IndJ,IndK,IndL),1,1,1) = Element%ScaC
          Else
            Call MQC_Error_A('Scalar type not defined in MQC_R4Tensor_Put', 6, &
                 'Element%Data_Type', Element%Data_Type, &
                 'Tensor%Data_Type', Tensor%Data_Type )
          EndIf
        Else
          Call MQC_Error_A('Tensor type not defined in MQC_R4Tensor_Put', 6, &
               'Tensor%Data_Type', Tensor%Data_Type )
        EndIf
      Else
        Call MQC_Error_A('Unrecognized storage type in MQC_R4Tensor_Put', &
          6, 'Tensor%Storage', Tensor%Storage)
      EndIf

      End Subroutine MQC_R4Tensor_Put_Int
!
!
!     PROCEDURE MQC_Print_R4Tensor_Algebra1
!
!>    \brief <b> MQC_Print_R4Tensor_Algebra1 is a subroutine used to print an MQC
!>    rank-4 tensor</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_Print_R4Tensor_Algebra1 is a subroutine used to print an MQC rank-4 tensor. 
!>    Blank_At_Top and Blank_At_Bottom are optional logical arguments to print blank
!>    lines before or after output.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_Tensor)
!>        The variable to be printed.
!>    \endverbatim
!>
!>    \param[in] IOut
!>    \verbatim
!>        IOut is Integer(kind=int64) 
!>        The Fortran file number to print to. 
!>    \endverbatim
!>
!>    \param[in] Header
!>    \verbatim
!>        Header is Character(Len=*)
!>        The title to print along with Tensor.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Top
!>    \verbatim
!>        Blank_At_Top is Logical,Optional
!>        = .True.:  print blank line above output
!>        = .False.: do not print blank line above output.
!>    \endverbatim
!>
!>    \param[in] Blank_At_Bottom
!>    \verbatim
!>        Blank_At_Bottom is Logical,Optional
!>        = .True.:  print blank line below output
!>        = .False.: do not print blank line below output.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016
!
      Subroutine MQC_Print_R4Tensor_Algebra1(Tensor,IOut,Header,blank_at_top,blank_at_bottom)
!
      Implicit None
      Integer(kind=int64),Intent(In)::IOut
      Class(MQC_R4Tensor),Intent(In)::Tensor
      Integer(kind=int64)::I,J,K,L
      Character(Len=*),intent(in),optional::Header
      Logical,Optional::blank_at_top,blank_at_bottom

 1000 Format(1x,A)
 1020 Format( " " )
 1100 Format(1x,'(',I3,',',I3,'|',I3,',',I3,') = ',I10)
 1200 Format(1x,'(',I3,',',I3,'|',I3,',',I3,') = ',F15.8)
 1300 Format(1x,'(',I3,',',I3,'|',I3,',',I3,') = ',F12.5,F11.5,"i")

      If(Present(blank_at_top)) then
        If(blank_at_top) Write(IOut,1020)
      EndIf
      If(Present(Header)) Write(IOut,1000) Trim(Header)
      If(MQC_R4Tensor_HaveFull(Tensor)) then
        Do I = 1, Tensor%I
          Do J = 1, Tensor%J
            Do K = 1, Tensor%K
              Do l = 1, Tensor%L
                If(Tensor%Data_Type.eq.'Integer') then
                  Write(IOut,1100) I,J,K,L,Tensor%ITen(I,J,K,L)
                ElseIf(Tensor%Data_Type.eq.'Real') then
                  Write(IOut,1200) I,J,K,L,Tensor%RTen(I,J,K,L)
                ElseIf(Tensor%Data_Type.eq.'Complex') then
                  Write(IOut,1300) I,J,K,L,Tensor%CTen(I,J,K,L)
                EndIf
              EndDo
            EndDo
          EndDo
        EndDo
      ElseIf(MQC_R4Tensor_HaveSymmetric(Tensor)) then
        Do I = 1, Tensor%I
          Do J = 1, Tensor%J
            Do K = 1, Tensor%K
              Do l = 1, Tensor%L
                If(Tensor%Data_Type.eq.'Integer') then
                  Write(IOut,1100) I,J,K,L,Tensor%ITen(symIndexHash(I,J,K,L),1,1,1)
                ElseIf(Tensor%Data_Type.eq.'Real') then
                  Write(IOut,1200) I,J,K,L,Tensor%RTen(symIndexHash(I,J,K,L),1,1,1)
                ElseIf(Tensor%Data_Type.eq.'Complex') then
                  Write(IOut,1300) I,J,K,L,Tensor%CTen(symIndexHash(I,J,K,L),1,1,1)
                EndIf
              EndDo
            EndDo
          EndDo
        EndDo
      Else
        Call MQC_Error_A('Unrecognized storage type in MQC_Print_R4Tensor_Algebra1', &
          6, 'Tensor%Storage', Tensor%Storage)
      EndIf
      If(present(blank_at_bottom)) then
        If(blank_at_bottom) Write(IOut,1020)
      EndIf

      End Subroutine MQC_Print_R4Tensor_Algebra1
!
!
!     PROCEDURE MQC_Set_IntegralArray2Tensor
!
!>    \brief <b> MQC_Set_IntegralArray2Tensor is a subroutine that sets an MQC rank-4 
!>    tensor equal to an intrinsic integral rank-4 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_IntegralArray2Tensor is a subroutine that sets an MQC rank-4 equal to 
!>    an intrinsic integral rank-4 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] TensorOut
!>    \verbatim
!>        TensorOut is Type(MQC_Matrix)
!>        The MQC rank-4 tensor to be set equal to the array.
!>    \endverbatim
!>
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayIn is Integer(kind=int64),Dimension(:,:,:,:)
!>        The array to be input into TensorOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016, 2017
!
      Subroutine MQC_Set_IntegerArray2Tensor(TensorOut,ArrayIn)
!
      Implicit None
      Integer(kind=int64),Dimension(:,:,:,:),Intent(In)::ArrayIn
      Type(MQC_R4Tensor),Intent(InOut)::TensorOut

      Call MQC_Deallocate_R4Tensor(TensorOut)
      Call MQC_Allocate_R4Tensor(Size(ArrayIn,1),Size(ArrayIn,2),Size(ArrayIn,3), &
        Size(ArrayIn,4),TensorOut,'Integer','StorFull')
      TensorOut%ITen = Arrayin

      End Subroutine MQC_Set_IntegerArray2Tensor
!
!
!     PROCEDURE MQC_Set_RealArray2Tensor
!
!>    \brief <b> MQC_Set_RealArray2Tensor is a subroutine that sets an MQC rank-4 
!>    tensor equal to an intrinsic real rank-4 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_RealArray2Tensor is a subroutine that sets an MQC rank-4 equal to an 
!>    intrinsic real rank-4 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] TensorOut
!>    \verbatim
!>        TensorOut is Type(MQC_Matrix)
!>        The MQC rank-4 tensor to be set equal to the array.
!>    \endverbatim
!>
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayIn is Real(kind=real64),Dimension(:,:,:,:)
!>        The array to be input into TensorOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016, 2017
!
      Subroutine MQC_Set_RealArray2Tensor(TensorOut,ArrayIn)
!
      Implicit None
      Real(kind=real64),Dimension(:,:,:,:),Intent(In)::ArrayIn
      Type(MQC_R4Tensor),Intent(InOut)::TensorOut

      Call MQC_Deallocate_R4Tensor(TensorOut)
      Call MQC_Allocate_R4Tensor(Size(ArrayIn,1),Size(ArrayIn,2),Size(ArrayIn,3), &
        Size(ArrayIn,4),TensorOut,'Real','StorFull')
      TensorOut%RTen = ArrayIn

      End Subroutine MQC_Set_RealArray2Tensor
!
!
!     PROCEDURE MQC_Set_ComplexArray2Tensor
!
!>    \brief <b> MQC_Set_ComplexArray2Tensor is a subroutine that sets an MQC rank-4 
!>    tensor equal to an intrinsic complex rank-4 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_ComplexArray2Tensor is a subroutine that sets an MQC rank-4 equal to an 
!>    intrinsic complex rank-4 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] TensorOut
!>    \verbatim
!>        TensorOut is Type(MQC_Matrix)
!>        The MQC rank-4 tensor to be set equal to the array.
!>    \endverbatim
!>
!>    \param[in] ArrayIn
!>    \verbatim
!>        ArrayIn is Complex(kind=real64),Dimension(:,:,:,:)
!>        The array to be input into TensorOut.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2016, 2017
!
      Subroutine MQC_Set_ComplexArray2Tensor(TensorOut,ArrayIn)
!
      Implicit None
      Complex(kind=real64),Dimension(:,:,:,:),Intent(In)::ArrayIn
      Type(MQC_R4Tensor),Intent(InOut)::TensorOut

      Call MQC_Deallocate_R4Tensor(TensorOut)
      Call MQC_Allocate_R4Tensor(Size(ArrayIn,1),Size(ArrayIn,2),Size(ArrayIn,3), &
        Size(ArrayIn,4),TensorOut,'Complex','StorFull')
      TensorOut%CTen = ArrayIn

      End Subroutine MQC_Set_ComplexArray2Tensor
!
!
!     PROCEDURE MQC_Set_Tensor2IntegerArray
!
!>    \brief <b> MQC_Set_Tensor2IntegerArray is a subroutine that outputs an MQC rank-4 
!>    tensor to an intrinsic integer rank-4 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_Tensor2IntegerArray is a subroutine that outputs an MQC rank-4 tensor to 
!>    an intrinsic integer rank-4 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Integer(kind=int64),Dimension(:,:,:,:)
!>        The array to be set equal to TensorIn.
!>    \endverbatim
!>
!>    \param[in] TensorIn
!>    \verbatim
!>        TensorIn is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be output to the array.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Subroutine MQC_Set_Tensor2IntegerArray(ArrayOut,TensorIn)
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::TensorIn
      Integer(kind=int64),Dimension(:,:,:,:),Allocatable,Intent(InOut)::ArrayOut

      if(allocated(ArrayOut)) deallocate(ArrayOut)

      If(MQC_R4Tensor_HaveInteger(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%ITen,1),Size(TensorIn%ITen,2),&
          Size(TensorIn%ITen,3),Size(TensorIn%ITen,4)))
        ArrayOut = TensorIn%ITen
      ElseIf(MQC_R4Tensor_HaveReal(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%ITen,1),Size(TensorIn%ITen,2),&
          Size(TensorIn%ITen,3),Size(TensorIn%ITen,4)))
        ArrayOut = TensorIn%RTen
      ElseIf(MQC_R4Tensor_HaveComplex(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%ITen,1),Size(TensorIn%ITen,2),&
          Size(TensorIn%ITen,3),Size(TensorIn%ITen,4)))
        ArrayOut = TensorIn%CTen
      Else
        Call MQC_Error_A('TensorIn type unknown in MQC_Tensor2IntegerArray', 6, &
             'TensorIn%Data_Type', TensorIn%Data_Type )
      EndIf

      End Subroutine MQC_Set_Tensor2IntegerArray
!
!
!     PROCEDURE MQC_Set_Tensor2RealArray
!
!>    \brief <b> MQC_Set_Tensor2RealArray is a subroutine that outputs an MQC rank-4 
!>    tensor to an intrinsic real rank-4 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_Tensor2RealArray is a subroutine that outputs an MQC rank-4 tensor to 
!>    an intrinsic real rank-4 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Real(kind=real64),Dimension(:,:,:,:)
!>        The array to be set equal to TensorIn.
!>    \endverbatim
!>
!>    \param[in] TensorIn
!>    \verbatim
!>        TensorIn is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be output to the array.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Subroutine MQC_Set_Tensor2RealArray(ArrayOut,TensorIn)
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::TensorIn
      Real(kind=real64),Dimension(:,:,:,:),Allocatable,Intent(InOut)::ArrayOut

      if(allocated(ArrayOut)) deallocate(ArrayOut)

      If(MQC_R4Tensor_HaveInteger(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%ITen,1),Size(TensorIn%ITen,2),&
          Size(TensorIn%ITen,3),Size(TensorIn%ITen,4)))
        ArrayOut = TensorIn%ITen
      ElseIf(MQC_R4Tensor_HaveReal(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%RTen,1),Size(TensorIn%RTen,2),&
          Size(TensorIn%RTen,3),Size(TensorIn%RTen,4)))
        ArrayOut = TensorIn%RTen
      ElseIf(MQC_R4Tensor_HaveComplex(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%CTen,1),Size(TensorIn%CTen,2),&
          Size(TensorIn%CTen,3),Size(TensorIn%CTen,4)))
        ArrayOut = TensorIn%CTen
      Else
        Call MQC_Error_A('TensorIn type unknown in MQC_Tensor2RealArray', 6, &
             'TensorIn%Data_Type', TensorIn%Data_Type )
      EndIf

      End Subroutine MQC_Set_Tensor2RealArray
!
!
!     PROCEDURE MQC_Set_Tensor2ComplexArray
!
!>    \brief <b> MQC_Set_Tensor2ComplexArray is a subroutine that outputs an MQC rank-4 
!>    tensor to a complex real rank-4 array</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_Set_Tensor2ComplexArray is a subroutine that outputs an MQC rank-4 tensor to 
!>    an intrinsic complex rank-4 array.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] ArrayOut
!>    \verbatim
!>        ArrayOut is Complex(kind=real64),Dimension(:,:,:,:)
!>        The array to be set equal to TensorIn.
!>    \endverbatim
!>
!>    \param[in] TensorIn
!>    \verbatim
!>        TensorIn is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be output to the array.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Subroutine MQC_Set_Tensor2ComplexArray(ArrayOut,TensorIn)
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::TensorIn
      Complex(kind=real64),Dimension(:,:,:,:),Allocatable,Intent(InOut)::ArrayOut

      if(allocated(ArrayOut)) deallocate(ArrayOut)

      If(MQC_R4Tensor_HaveInteger(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%ITen,1),Size(TensorIn%ITen,2),&
          Size(TensorIn%ITen,3),Size(TensorIn%ITen,4)))
        ArrayOut = TensorIn%ITen
      ElseIf(MQC_R4Tensor_HaveReal(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%RTen,1),Size(TensorIn%RTen,2),&
          Size(TensorIn%RTen,3),Size(TensorIn%RTen,4)))
        ArrayOut = TensorIn%RTen
      ElseIf(MQC_R4Tensor_HaveComplex(TensorIn)) then
        allocate(ArrayOut(Size(TensorIn%CTen,1),Size(TensorIn%CTen,2),&
          Size(TensorIn%CTen,3),Size(TensorIn%CTen,4)))
        ArrayOut = TensorIn%CTen
      Else
        Call MQC_Error_A('TensorIn type unknown in MQC_Tensor2ComplexArray', 6, &
             'TensorIn%Data_Type', TensorIn%Data_Type )
      EndIf

      End Subroutine MQC_Set_Tensor2ComplexArray
!
!
!     PROCEDURE MQC_R4Tensor_Initialize
!
!>    \brief <b> MQC_R4Tensor_Initialize is a subroutine that initializes an MQC 
!>    rank-4 tensor with each element equal to a chosen value</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Initialize is a subroutine that initializes an MQC rank-4 tensor 
!>    with each element equal to a chosen value. Optional argument Scalar determines 
!>    the value of each element, with the default equal to zero. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] R4Tensor
!>    \verbatim
!>        R4Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to initialize.
!>    \endverbatim
!>
!>    \param[in] I
!>    \verbatim
!>        I is Integer(kind=int64)
!>        The number of the first dimension to initialize 
!>        R4Tensor.
!>    \endverbatim
!>
!>    \param[in] J
!>    \verbatim
!>        J is Integer(kind=int64)
!>        The number of the second dimension to initialize 
!>        R4Tensor.
!>    \endverbatim
!>
!>    \param[in] K
!>    \verbatim
!>        K is Integer(kind=int64)
!>        The number of the third dimension to initialize 
!>        R4Tensor.
!>    \endverbatim
!>
!>    \param[in] L
!>    \verbatim
!>        L is Integer(kind=int64)
!>        The number of the fourth dimension to initialize 
!>        R4Tensor.
!>    \endverbatim
!>
!>    \param[in] Scalar
!>    \verbatim
!>        Scalar is Class(*),Optional
!>        The value to set each element of R4Tensor.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2017
!
      Subroutine MQC_R4Tensor_Initialize(R4Tensor,I,J,K,L,Scalar)
!
      Implicit None
      Real(kind=real64)::Zero=0.0d0
      Integer(kind=int64),Intent(In)::I,J,K,L
      Class(*),Optional::Scalar
      Class(MQC_R4Tensor),Intent(InOut)::R4Tensor

      If(Present(Scalar)) then
        Select Type (Scalar)
        Type is (Integer)
          Call MQC_Allocate_R4Tensor(I,J,K,L,R4Tensor,'Integer','StorFull')
          R4Tensor%ITen = Scalar
        Type is (Real)
          Call MQC_Allocate_R4Tensor(I,J,K,L,R4Tensor,'Real','StorFull')
          R4Tensor%RTen = Scalar
        Type is (Complex(Kind=real64))
          Call MQC_Allocate_R4Tensor(I,J,K,L,R4Tensor,'Complex','StorFull')
          R4Tensor%CTen = Scalar
        Class Default
          Call MQC_Error_I('Scalar Type not defined in MQC_R4Tensor_Initialize', 6)
        End Select
      Else
        Call MQC_Allocate_R4Tensor(I,J,K,L,R4Tensor,'Real','StorFull')
        R4Tensor%RTen = Zero
      EndIf

      End Subroutine MQC_R4Tensor_Initialize
!
!     PROCEDURE MQC_Matrix_SymmSymmR4Tensor_Put_Real
!
!>    \brief <b> MQC_R4Tensor_SymmSymmMatrix_Put_Real is a subroutine that returns a 
!>    MQC rank-4 tensor with elements defined by values in an intrinsic real vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_SymmSymmMatrix_Put_Real is a subroutine that returns a MQC rank-4
!>    tensor with elements defined by values in an intrinsic real vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] R4Tensor
!>    \verbatim
!>        R4Tensor is class(MQC_R4Tensor)
!>        MQC rank-4 tensor to overwrite with output rank-4 tensor.
!>    \endverbatim
!>
!>    \param[in] SymmSymmMatrixIn
!>    \verbatim
!>        SymmSymmMatrixIn is real(kind=real64),dimension(:)
!>        Intrinsic real vector to write as rank-4 tensor.
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson 
!>    \date 2017
!
      Subroutine MQC_Matrix_SymmSymmR4Tensor_Put_Real(r4Tensor,symmSymmMatrixIn)
!
      implicit none
      class(MQC_R4Tensor),intent(inOut)::r4Tensor
      real(kind=real64),dimension(:),intent(in)::symmSymmMatrixIn
      integer(kind=int64)::n,nSymm
!
      nSymm = SIZE(symmSymmMatrixIn)
      n = 0.5*(sqrt(4.0*sqrt(8.0*nSymm+1)-3)-1)
      call mqc_allocate_r4tensor(n,n,n,n,r4tensor,'real','symm')
      r4tensor%rten(:,1,1,1) = symmSymmMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_SymmSymmR4Tensor_Put_Real
!
!
!     PROCEDURE MQC_Matrix_SymmSymmR4Tensor_Put_Complex
!
!>    \brief <b> MQC_R4Tensor_SymmSymmMatrix_Put_Complex is a subroutine that returns 
!>    a MQC rank-4 tensor with elements defined by values in an intrinsic complex 
!>    vector</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_SymmSymmMatrix_Put_Complex is a subroutine that returns a MQC 
!>    rank-4 tensor with elements defined by values in an intrinsic complex vector.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in,out] R4Tensor
!>    \verbatim
!>        R4Tensor is class(MQC_R4Tensor)
!>        MQC rank-4 tensor to overwrite with output rank-4 tensor.
!>    \endverbatim
!>
!>    \param[in] SymmSymmMatrixIn
!>    \verbatim
!>        SymmSymmMatrixIn is complex(kind=real64),dimension(:)
!>        Intrinsic complex vector to write as rank-4 tensor.
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson 
!>    \date 2017
!
      Subroutine MQC_Matrix_SymmSymmR4Tensor_Put_Complex(r4Tensor,symmSymmMatrixIn)
!
      implicit none
      class(MQC_R4Tensor),intent(inOut)::r4Tensor
      complex(kind=real64),dimension(:),intent(in)::symmSymmMatrixIn
      integer(kind=int64)::n,nSymm
!
      nSymm = SIZE(symmSymmMatrixIn)
      n = 0.5*(sqrt(4.0*sqrt(8.0*nSymm+1)-3)-1)
      call mqc_allocate_r4tensor(n,n,n,n,r4tensor,'complex','symm')
      r4tensor%cten(:,1,1,1) = symmSymmMatrixIn(:)
!
      return
      end subroutine MQC_Matrix_SymmSymmR4Tensor_Put_Complex
!
!
!     PROCEDURE MQC_R4Tensor_HaveInteger
!
!>    \brief <b> MQC_R4Tensor_HaveInteger is a function used to indicate if an MQC 
!>    rank-4 tensor has an allocated integer array</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_HaveInteger is a function that returns TRUE if an MQC rank-4 tensor 
!>    has an allocated integer array and FALSE if it does not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4Tensor
!>    \verbatim
!>        R4Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_HaveInteger(R4Tensor)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_R4Tensor_HaveInteger
      Type(MQC_R4Tensor),Intent(In)::R4Tensor
!
      MQC_R4Tensor_HaveInteger = Allocated(R4Tensor%ITen)
!
      Return
      End Function MQC_R4Tensor_HaveInteger
!
!
!     PROCEDURE MQC_R4Tensor_HaveReal
!
!>    \brief <b> MQC_R4Tensor_HaveReal is a function used to indicate if an MQC 
!>    rank-4 tensor has an allocated real array</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_HaveReal is a function that returns TRUE if an MQC rank-4 tensor 
!>    has an allocated real array and FALSE if it does not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4Tensor
!>    \verbatim
!>        R4Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_HaveReal(R4Tensor)
!
      Implicit None
      Logical::MQC_R4Tensor_HaveReal
      Type(MQC_R4Tensor),Intent(In)::R4Tensor
!
      MQC_R4Tensor_HaveReal = Allocated(R4Tensor%RTen)
!
      Return
      End Function MQC_R4Tensor_HaveReal
!
!
!     PROCEDURE MQC_R4Tensor_HaveComplex
!
!>    \brief <b> MQC_R4Tensor_HaveComplex is a function used to indicate if an MQC 
!>    rank-4 tensor has an allocated complex array</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_HaveComplex is a function that returns TRUE if an MQC rank-4 tensor 
!>    has an allocated complex array and FALSE if it does not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4Tensor
!>    \verbatim
!>        R4Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_HaveComplex(R4Tensor)
!
      Implicit None
      Logical::MQC_R4Tensor_HaveComplex
      Type(MQC_R4Tensor),Intent(In)::R4Tensor
!
      MQC_R4Tensor_HaveComplex = Allocated(R4Tensor%CTen)
!
      Return
      End Function MQC_R4Tensor_HaveComplex
!
!
!     PROCEDURE MQC_R4Tensor_HaveFull   
!
!>    \brief <b> MQC_R4Tensor_HaveFull is a function used to indicate if an MQC 
!>    rank-4 tensor is stored unpacked</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_HaveFull is a function that returns TRUE if an MQC rank-4 tensor 
!>    is stored unpacked and FALSE if it is not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_HaveFull(Tensor)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_R4Tensor_HaveFull   
      Type(MQC_R4Tensor),Intent(In)::Tensor
!
      If(Tensor%Storage.eq.'StorFull') then
        MQC_R4Tensor_HaveFull = .True. 
      Else
        MQC_R4Tensor_HaveFull = .False.
      EndIf
!
      Return
      End Function MQC_R4Tensor_HaveFull   
!
!
!     PROCEDURE MQC_R4Tensor_HaveSymmetric
!
!>    \brief <b> MQC_R4Tensor_HaveSymmetric is a function used to indicate if an MQC 
!>    rank-4 tensor is stored symmetric-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_HaveSymmetric is a function that returns TRUE if an MQC matrix is 
!>    stored symmetric-packed and FALSE if it is not.    
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_HaveSymmetric(Tensor)
!
!     Variable Declarations.
      Implicit None
      Logical::MQC_R4Tensor_HaveSymmetric 
      Type(MQC_R4Tensor),Intent(In)::Tensor
!
      If(Tensor%Storage.eq.'StorSymm') then
        MQC_R4Tensor_HaveSymmetric = .True. 
      Else
        MQC_R4Tensor_HaveSymmetric = .False.
      EndIf
!
      Return
      End Function MQC_R4Tensor_HaveSymmetric   
!
!
!     PROCEDURE MQC_R4Tensor_Full2Symm
!
!>    \brief <b> MQC_R4Tensor_Full2Symm is a subroutine that converts an unpacked MQC 
!>    rank-4 tensor to symmetric-packed</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Full2Symm is a subroutine that converts an unpacked MQC rank-4 
!>    tensor to symmetric-packed.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be symmetric packed.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Full2Symm(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor),Intent(InOut)::Tensor
      Real(kind=real64),Dimension(:,:,:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:,:,:),Allocatable::TempC
      Integer(kind=int64)::I,J,K,L,N
!
      If(.not.Tensor%Storage.eq.'StorFull') Call MQC_Error_A('Input rank-4 tensor must be full &
     &  packed in MQC_R4Tensor_Full2Symm', 6, 'Tensor%Storage', Tensor%Storage )
      N = MQC_R4Tensor_Size(Tensor)
      If(MQC_R4Tensor_HaveReal(Tensor)) then
        Allocate(Temp(N,N,N,N))
        Temp = Tensor%RTen
        Call MQC_Deallocate_R4Tensor(Tensor)
        Call MQC_Allocate_R4Tensor(Size(Temp,1),Size(Temp,2),Size(Temp,3),Size(Temp,4),Tensor, &
          'Real','StorSymm')
        Do I = 1, Size(Temp,1)
          Do J = 1, I
            Do K = 1, Size(Temp,1)
              Do L = 1, K
                If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                If((Temp(I,J,K,L).ne.Temp(J,I,K,L)).or.(Temp(I,J,K,L).ne.Temp(I,J,L,K)).or.(Temp(I,J,K,L).ne. &
                  Temp(J,I,L,K)).or.(Temp(I,J,K,L).ne.Temp(K,L,I,J)).or.(Temp(I,J,K,L).ne.Temp(K,L,J,I)).or. &
                  (Temp(I,J,K,L).ne.Temp(L,K,I,J)).or.(Temp(I,J,K,L).ne.Temp(L,K,J,I))) &
                  call mqc_error('Input rank-4 tensor is not symmetric')
                Tensor%RTen(SymIndexHash(I,J,K,L),1,1,1) = Temp(I,J,K,L)
              EndDo
            EndDo
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_R4Tensor_HaveInteger(Tensor)) then
        Allocate(Temp(N,N,N,N))
        Temp = Tensor%ITen
        Call MQC_Deallocate_R4Tensor(Tensor)
        Call MQC_Allocate_R4Tensor(Size(Temp,1),Size(Temp,2),Size(Temp,3),Size(Temp,4),Tensor, &
          'Integer','StorSymm')
        Do I = 1, Size(Temp,1)
          Do J = 1, I
            Do K = 1, Size(Temp,1)
              Do L = 1, K
                If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                If((Temp(I,J,K,L).ne.Temp(J,I,K,L)).or.(Temp(I,J,K,L).ne.Temp(I,J,L,K)).or.(Temp(I,J,K,L).ne. &
                  Temp(J,I,L,K)).or.(Temp(I,J,K,L).ne.Temp(K,L,I,J)).or.(Temp(I,J,K,L).ne.Temp(K,L,J,I)).or. &
                  (Temp(I,J,K,L).ne.Temp(L,K,I,J)).or.(Temp(I,J,K,L).ne.Temp(L,K,J,I))) &
                  call mqc_error('Input rank-4 tensor is not symmetric')
                Tensor%ITen(SymIndexHash(I,J,K,L),1,1,1) = Temp(I,J,K,L)
              EndDo
            EndDo
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_R4Tensor_HaveComplex(Tensor)) then
        Allocate(Temp(N,N,N,N))
        Temp = Tensor%CTen
        Call MQC_Deallocate_R4Tensor(Tensor)
        Call MQC_Allocate_R4Tensor(Size(TempC,1),Size(TempC,2),Size(TempC,3),Size(TempC,4),Tensor, &
          'Complex','StorSymm')
        Do I = 1, Size(TempC,1)
          Do J = 1, I
            Do K = 1, Size(TempC,1)
              Do L = 1, K
                If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                If((Temp(I,J,K,L).ne.Temp(J,I,K,L)).or.(Temp(I,J,K,L).ne.Temp(I,J,L,K)).or.(Temp(I,J,K,L).ne. &
                  Temp(J,I,L,K)).or.(Temp(I,J,K,L).ne.Temp(K,L,I,J)).or.(Temp(I,J,K,L).ne.Temp(K,L,J,I)).or. &
                  (Temp(I,J,K,L).ne.Temp(L,K,I,J)).or.(Temp(I,J,K,L).ne.Temp(L,K,J,I))) &
                  call mqc_error('Input rank-4 tensor is not symmetric')
                Tensor%CTen(SymIndexHash(I,J,K,L),1,1,1) = TempC(I,J,K,L)
              EndDo
            EndDo
          EndDo
        EndDo
        Deallocate(TempC)
      EndIf
!
      Return
      End Subroutine MQC_R4Tensor_Full2Symm
!
!
!     PROCEDURE MQC_R4Tensor_Symm2Full
!
!>    \brief <b> MQC_R4Tensor_Symm2Full is a subroutine that converts a symmetry-packed 
!>    MQC rank-4 tensor to unpacked</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Symm2Full is a subroutine that converts a symmetry-packed MQC rank-4 
!>    to unpacked. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to unpack.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Symm2Full(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor),Intent(InOut)::Tensor
      Real(kind=real64),Dimension(:,:,:,:),Allocatable::Temp
      Complex(Kind=real64),Dimension(:,:,:,:),Allocatable::TempC
      Integer(kind=int64)::I,J,K,L,N
!
      If(.not.Tensor%Storage.eq.'StorSymm') Call MQC_Error_A('Input rank-4 tensor must be &
     &  symmetric-packed in MQC_R4Tensor_Symm2Full',6,'Tensor%Storage',Tensor%Storage)
      N = MQC_R4Tensor_Size(Tensor)
      If(MQC_R4Tensor_HaveReal(Tensor)) then
        Allocate(Temp((N**4+2*N**3+3*N**2+2*N)/8,1,1,1))
        Temp = Tensor%RTen
        Call MQC_Deallocate_R4Tensor(Tensor)
        Call MQC_Allocate_R4Tensor(N,N,N,N,Tensor,'Real','StorFull')
        Do I = 1, N
          Do J = 1, I
            Do K = 1, N
              Do L = 1, K
                If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                Tensor%RTen(I,J,K,L) = Temp(symIndexHash(I,J,K,L),1,1,1)
                Tensor%RTen(J,I,K,L) = Tensor%RTen(I,J,K,L)
                Tensor%RTen(I,J,L,K) = Tensor%RTen(I,J,K,L)
                Tensor%RTen(J,I,L,K) = Tensor%RTen(I,J,K,L)
                Tensor%RTen(K,L,I,J) = Tensor%RTen(I,J,K,L)
                Tensor%RTen(K,L,J,I) = Tensor%RTen(I,J,K,L)
                Tensor%RTen(L,K,I,J) = Tensor%RTen(I,J,K,L)
                Tensor%RTen(L,K,J,I) = Tensor%RTen(I,J,K,L)
              EndDo
            EndDo
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_R4Tensor_HaveInteger(Tensor)) then
        Allocate(Temp((N**4+2*N**3+3*N**2+2*N)/8,1,1,1))
        Temp = Tensor%ITen
        Call MQC_Deallocate_R4Tensor(Tensor)
        Call MQC_Allocate_R4Tensor(N,N,N,N,Tensor,'Integer','StorFull')
        Do I = 1, N
          Do J = 1, I
            Do K = 1, N
              Do L = 1, K
                If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                Tensor%ITen(I,J,K,L) = Temp(symIndexHash(I,J,K,L),1,1,1)
                Tensor%ITen(J,I,K,L) = Tensor%ITen(I,J,K,L)
                Tensor%ITen(I,J,L,K) = Tensor%ITen(I,J,K,L)
                Tensor%ITen(J,I,L,K) = Tensor%ITen(I,J,K,L)
                Tensor%ITen(K,L,I,J) = Tensor%ITen(I,J,K,L)
                Tensor%ITen(K,L,J,I) = Tensor%ITen(I,J,K,L)
                Tensor%ITen(L,K,I,J) = Tensor%ITen(I,J,K,L)
                Tensor%ITen(L,K,J,I) = Tensor%ITen(I,J,K,L)
              EndDo
            EndDo
          EndDo
        EndDo
        Deallocate(Temp)
      ElseIf(MQC_R4Tensor_HaveComplex(Tensor)) then
        Allocate(Temp((N**4+2*N**3+3*N**2+2*N)/8,1,1,1))
        Temp = Tensor%CTen
        Call MQC_Deallocate_R4Tensor(Tensor)
        Call MQC_Allocate_R4Tensor(N,N,N,N,Tensor,'Complex','StorFull')
        Do I = 1, N
          Do J = 1, I
            Do K = 1, N
              Do L = 1, K
                If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                Tensor%CTen(I,J,K,L) = Temp(symIndexHash(I,J,K,L),1,1,1)
                Tensor%CTen(J,I,K,L) = Tensor%CTen(I,J,K,L)
                Tensor%CTen(I,J,L,K) = Tensor%CTen(I,J,K,L)
                Tensor%CTen(J,I,L,K) = Tensor%CTen(I,J,K,L)
                Tensor%CTen(K,L,I,J) = Tensor%CTen(I,J,K,L)
                Tensor%CTen(K,L,J,I) = Tensor%CTen(I,J,K,L)
                Tensor%CTen(L,K,I,J) = Tensor%CTen(I,J,K,L)
                Tensor%CTen(L,K,J,I) = Tensor%CTen(I,J,K,L)
              EndDo
            EndDo
          EndDo
        EndDo
        Deallocate(TempC)
      EndIf
!
      Return
      End Subroutine MQC_R4Tensor_Symm2Full
!
!
!     PROCEDURE MQC_R4Tensor_Size
!
!>    \brief <b> MQC_R4Tensor_Size is a function used to return the dimension of a 
!>    specified dimension of an MQC rank-4 tensor</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Size is a function used to return the dimension of a specified 
!>    dimension of a MQC rank-4 tensor. If the tensor is NOT allocated, the dimension  
!>    is returned as 0.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be tested.
!>    \endverbatim
!>
!>    \param[in] Axis
!>    \verbatim
!>        Axis is integer(kind=int64),optional
!>        The axis from which the dimension will be returned.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_Size(Tensor,axis) result(dimen)
!
!     Variable Declarations.
      Implicit None
      Integer(kind=int64)::dimen
      Type(MQC_R4Tensor),Intent(In)::Tensor
      integer(kind=int64),intent(in),optional::axis
      integer(kind=int64)::my_axis
!
      if(present(axis)) then
        my_axis = axis
      else
        my_axis = 1
      endIf
      if(my_axis.eq.1) then
        dimen = Tensor%I
      elseIf(my_axis.eq.2) then
        dimen = Tensor%J
      elseIf(my_axis.eq.3) then
        dimen = Tensor%K
      elseIf(my_axis.eq.4) then
        dimen = Tensor%L
      else
        call mqc_error_i('Axis out of range in MQC_R4Tensor_Size',6,'my_axis',my_axis)
      endIf
!
      Return
      End Function MQC_R4Tensor_Size
!
!
!     PROCEDURE MQC_R4Tensor_isAllocated
!
!>    \brief <b> MQC_R4Tensor_isAllocated is a function that returns the allocation
!>    status of a MQC_R4Tensor variable</b> 
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_R4Tensor_isAllocated is a function that returns the allocation status of a 
!>    MQC_R4Tensor variable. The function returns TRUE if the tensor is allocated 
!>    and FALSE if the tensor is not allocated.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in,out] Tensor
!>    \verbatim
!>        Tensor is Class(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be tested.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_isAllocated(Tensor) Result(isAllocated)
!
!     Variable Declarations.
      Implicit None
      Class(MQC_R4Tensor),Intent(In)::Tensor
      Logical::isAllocated
!
      isAllocated = .False.
      If(Allocated(Tensor%RTen)) isAllocated = .True.
      If(Allocated(Tensor%ITen)) isAllocated = .True.
      If(Allocated(Tensor%CTen)) isAllocated = .True.
!
      Return
      End Function MQC_R4Tensor_isAllocated
!
!
!     PROCEDURE MQC_R4Tensor_Copy_Int2Real
!
!>    \brief <b> MQC_R4Tensor_Copy_Int2Real is a subroutine used to copy an integer 
!>    MQC rank-4 tensor into its real space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Copy_Int2Real is a subroutine used to copy an integer MQC rank-4 
!>    tensor into its real space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be converted to real.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Copy_Int2Real(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor)::Tensor
!
      If(.not.MQC_R4Tensor_HaveInteger(Tensor)) Call MQC_Error_L('Incoming tensor not integer in MQC_R4Tensor_Copy_Int2Real', 6, &
           'MQC_R4Tensor_HaveInteger(Tensor)', MQC_R4Tensor_HaveInteger(Tensor) )
      Tensor%RTen = Tensor%ITen
      If(Allocated(Tensor%ITen)) Deallocate(Tensor%ITen)
      Tensor%Data_Type = 'Real'
!
      Return
      End Subroutine MQC_R4Tensor_Copy_Int2Real
!
!
!     PROCEDURE MQC_R4Tensor_Copy_Int2Complex
!
!>    \brief <b> MQC_R4Tensor_Copy_Int2Complex is a subroutine used to copy an integer 
!>    MQC rank-4 tensor into its complex space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Copy_Int2Complex is a subroutine used to copy an integer MQC rank-4 
!>    tensor into its complex space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be converted to complex.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Copy_Int2Complex(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor)::Tensor
!
      If(.not.MQC_R4Tensor_HaveInteger(Tensor)) Call MQC_Error_L('Incoming tensor not integer in MQC_R4Tensor_Copy_Int2Complex',6,&
           'MQC_R4Tensor_HaveInteger(Tensor)', MQC_R4Tensor_HaveInteger(Tensor) )
      Tensor%CTen = Tensor%ITen
      If(Allocated(Tensor%ITen)) Deallocate(Tensor%ITen)
      Tensor%Data_Type = 'Complex'
!
      Return
      End Subroutine MQC_R4Tensor_Copy_Int2Complex
!
!
!     PROCEDURE MQC_R4Tensor_Copy_Real2Int
!
!>    \brief <b> MQC_R4Tensor_Copy_Real2Int is a subroutine used to copy a real MQC 
!>    rank-4 tensor into its integer space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Copy_Real2Int is a subroutine used to copy a real MQC rank-4 
!>    tensor into its integer space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be converted to integer.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Copy_Real2Int(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor)::Tensor
!
      If(.not.MQC_R4Tensor_HaveReal(Tensor)) Call MQC_Error_L('Incoming tensor not real in MQC_R4Tensor_Copy_Real2Int', 6, &
           'MQC_R4Tensor_HaveReal(Tensor)', MQC_R4Tensor_HaveReal(Tensor) )
      Tensor%ITen = Tensor%RTen
      If(Allocated(Tensor%RTen)) Deallocate(Tensor%RTen)
      Tensor%Data_Type = 'Integer'
!
      Return
      End Subroutine MQC_R4Tensor_Copy_Real2Int
!
!
!     PROCEDURE MQC_R4Tensor_Copy_Real2Complex
!
!>    \brief <b> MQC_R4Tensor_Copy_Real2Complex is a subroutine used to copy a real MQC 
!>    rank-4 tensor into its complex space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Copy_Real2Complex is a subroutine used to copy a real MQC rank-4 
!>    tensor into its complex space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be converted to integer.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Copy_Real2Complex(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor)::Tensor
!
      If(.not.MQC_R4Tensor_HaveReal(Tensor)) Call MQC_Error_L('Incoming tensor not real in MQC_R4Tensor_Copy_Real2Complex', 6, &
           'MQC_R4Tensor_HaveReal(Tensor)', MQC_R4Tensor_HaveReal(Tensor) )
      Tensor%CTen = Tensor%RTen
      If(Allocated(Tensor%RTen)) Deallocate(Tensor%RTen)
      Tensor%Data_Type = 'Complex'
!
      Return
      End Subroutine MQC_R4Tensor_Copy_Real2Complex
!
!
!     PROCEDURE MQC_R4Tensor_Copy_Complex2Int
!
!>    \brief <b> MQC_R4Tensor_Copy_Complex2Int is a subroutine used to copy a complex
!>    MQC rank-4 tensor into its integer space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Copy_Complex2Int is a subroutine used to copy a complex MQC rank-4 
!>    tensor into its integer space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be converted to integer.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Copy_Complex2Int(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor)::Tensor
!
      If(.not.MQC_R4Tensor_HaveComplex(Tensor)) Call MQC_Error_L('Incoming tensor not complex in MQC_R4Tensor_Copy_Complex2Int',6,&
           'MQC_R4Tensor_HaveComplex(Tensor)', MQC_R4Tensor_HaveComplex(Tensor) )
      Tensor%ITen = Tensor%CTen
      If(Allocated(Tensor%CTen)) Deallocate(Tensor%CTen)
      Tensor%Data_Type = 'Integer'
!
      Return
      End Subroutine MQC_R4Tensor_Copy_Complex2Int
!
!
!     PROCEDURE MQC_R4Tensor_Copy_Complex2Real
!
!>    \brief <b> MQC_R4Tensor_Copy_Complex2Real is a subroutine used to copy a complex
!>    MQC rank-4 tensor into its real space</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Copy_Complex2Real is a subroutine used to copy a complex MQC rank-4 
!>    tensor into its real space.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC rank-4 tensor to be converted to real.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Subroutine MQC_R4Tensor_Copy_Complex2Real(Tensor)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor)::Tensor
!
      If(.not.MQC_R4Tensor_HaveComplex(Tensor)) Call MQC_Error_L('Incoming tensor not complex in MQC_R4Tensor_Copy_Complex2Real',6,&
           'MQC_R4Tensor_HaveComplex(Tensor)', MQC_R4Tensor_HaveComplex(Tensor) )
      Tensor%RTen = Tensor%CTen
      If(Allocated(Tensor%CTen)) Deallocate(Tensor%CTen)
      Tensor%Data_Type = 'Real'
!
      Return
      End Subroutine MQC_R4Tensor_Copy_Complex2Real
!
!
!     PROCEDURE MQC_R4Tensor_R4Tensor_Contraction
!
!>    \brief <b> MQC_R4Tensor_R4Tensor_Contraction is a function that returns the 
!>    contraction of two MQC rank-4 tensors</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_R4Tensor_Contraction is a function that returns the contraction of two 
!>    MQC rank-4 tensors.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4Tensor1
!>    \verbatim
!>        R4Tensor1 is Type(MQC_R4Tensor)
!>        The first MQC rank-4 tensor to contract.
!>    \endverbatim
!>
!>    \param[in] R4Tensor2
!>    \verbatim
!>        R4Tensor2 is Type(MQC_R4Tensor)
!>        The second MQC rank-4 tensor to contract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_R4Tensor_Contraction(R4Tensor1,R4Tensor2) Result(Contraction)
!
!     Variable Declarations.
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::R4Tensor1,R4Tensor2
      Type(MQC_Scalar)::Contraction
      Integer(kind=int64)::M,N,O,P,i,j,k,l
!
      Contraction = 0.0
      M = Min(size(R4Tensor1,1),size(R4Tensor2,1))
      N = Min(size(R4Tensor1,2),size(R4Tensor2,2))
      O = Min(size(R4Tensor1,3),size(R4Tensor2,3))
      P = Min(size(R4Tensor1,4),size(R4Tensor2,4))
      Do i = 1,M
        Do j = 1,N
          Do k = 1,O
            Do l = 1,P
              Contraction = Contraction + R4Tensor1%at(i,j,k,l)*R4Tensor2%at(i,j,k,l)
            EndDo
          EndDo
        EndDo
      EndDo
!
      End Function MQC_R4Tensor_R4Tensor_Contraction
!
!
!     PROCEDURE MQC_R4Tensor_R4Tensor_Sum
!
!>    \brief <b> MQC_R4Tensor_R4Tensor_Sum is a function that returns the 
!>    sum of two MQC rank-4 tensors</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_R4Tensor_Sum is a function that returns the sum of two 
!>    MQC rank-4 tensors.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4Tensor1
!>    \verbatim
!>        R4Tensor1 is Type(MQC_R4Tensor)
!>        The first MQC rank-4 tensor to sum.
!>    \endverbatim
!>
!>    \param[in] R4Tensor2
!>    \verbatim
!>        R4Tensor2 is Type(MQC_R4Tensor)
!>        The second MQC rank-4 tensor to sum.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_R4Tensor_Sum(R4Tensor1,R4Tensor2) Result(Summation)
!
!     Variable Declarations.
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::R4Tensor1,R4Tensor2
      Type(MQC_R4Tensor)::Summation,Tmp1,Tmp2
      Integer(kind=int64)::M,N,O,P,i,j,k,l
      character(len=8)::storage
!
      M = size(R4Tensor1,1)
      N = size(R4Tensor1,2)
      O = size(R4Tensor1,3)
      P = size(R4Tensor1,4)

      if(M.ne.size(R4Tensor2,1).or.N.ne.size(R4Tensor2,2).or.O.ne.size(R4Tensor2,3).or. &
        P.ne.size(R4Tensor2,4)) &
        call MQC_Error('R4Tensors not conformable in MQC_R4Tensor_R4Tensor_Sum',6)

      Tmp1 = R4Tensor1
      Tmp2 = R4Tensor2

      select case(Tmp1%Storage) 
      case('StorFull')
        storage = 'StorFull'
        select case(Tmp2%storage)
        case('StorSymm')
          call MQC_R4Tensor_Symm2Full(Tmp2)
        case('StorFull')
          !-Empty Case-!
        case default
          call mqc_error_A('Unkown storage type in MQC_R4Tensor_R4Tensor_Sum',6, &
            'Tmp2%Storage',Tmp2%Storage)
        end select
      case('StorSymm')
        select case (Tmp2%storage)
        case('StorSymm')
          storage = 'StorSymm'
        case('StorFull')
          call MQC_R4Tensor_Symm2Full(Tmp1)
          storage = 'StorFull'
        case default 
          call mqc_error_A('Unkown storage type in MQC_R4Tensor_R4Tensor_Sum',6, &
            'Tmp2%Storage',Tmp2%Storage)
        end select
      case default
        call mqc_error_A('Unkown storage type in MQC_R4Tensor_R4Tensor_Sum',6, &
          'Tmp1%Storage',Tmp1%Storage)
      end select


      select case(Tmp1%data_type)
      case('Real')
        select case(Tmp2%data_type)
        case('Real')
          summation = Tmp2
          summation%RTen = Tmp1%RTen + Tmp2%RTen
        case('Integer')
          summation = Tmp1
          summation%RTen = Tmp1%RTen + Tmp2%ITen
        case('Complex')
          summation = Tmp2
          summation%CTen = Tmp1%RTen + Tmp2%CTen
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_R4Tensor_R4Tensor_Sum.', 6, &
               'Tmp2%data_type', Tmp2%data_type) 
        end select
      case('Integer')
        select case(Tmp2%data_type)
        case('Real')
          summation = Tmp2
          summation%RTen = Tmp1%ITen + Tmp2%RTen
        case('Integer')
          summation = Tmp2
          summation%ITen = Tmp1%ITen + Tmp2%ITen
        case('Complex')
          summation = Tmp2
          summation%CTen = Tmp1%ITen + Tmp2%CTen
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_R4Tensor_R4Tensor_Sum.', 6, &
               'Tmp2%data_type', Tmp2%data_type) 
        end select
      case('Complex')
        select case(Tmp2%data_type)
        case('Real')
          summation = Tmp1
          summation%CTen = Tmp1%CTen + Tmp2%RTen
        case('Integer')
          summation = Tmp1
          summation%CTen = Tmp1%CTen + Tmp2%ITen
        case('Complex')
          summation = Tmp2
          summation%CTen = Tmp1%CTen + Tmp2%CTen
        case default
          call mqc_error_A('UNKNOWN matrix type in MQC_R4Tensor_R4Tensor_Sum.', 6, &
               'Tmp2%data_type', Tmp2%data_type) 
        end select
      case default
        call mqc_error_A('UNKNOWN matrix type in MQC_R4Tensor_R4Tensor_Sum.', 6, &
             'Tmp1%data_type', Tmp1%data_type) 
      end select

      summation%storage = storage
!
      End Function MQC_R4Tensor_R4Tensor_Sum
!
!
!     PROCEDURE MQC_R4Tensor_R4Tensor_Difference
!
!>    \brief <b> MQC_R4Tensor_R4Tensor_Difference is a function that returns the 
!>    difference of two MQC rank-4 tensors</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_R4Tensor_Difference is a function that returns the difference of 
!>    two MQC rank-4 tensors.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4Tensor1
!>    \verbatim
!>        R4Tensor1 is Type(MQC_R4Tensor)
!>        The first MQC rank-4 tensor to subtract.
!>    \endverbatim
!>
!>    \param[in] R4Tensor2
!>    \verbatim
!>        R4Tensor2 is Type(MQC_R4Tensor)
!>        The second MQC rank-4 tensor to subtract.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_R4Tensor_Difference(R4Tensor1,R4Tensor2) Result(Difference)
!
!     Variable Declarations.
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::R4Tensor1,R4Tensor2
      Type(MQC_R4Tensor)::Difference
      Integer(kind=int64)::M,N,O,P,i,j,k,l
!
      M = size(R4Tensor1,1)
      N = size(R4Tensor1,2)
      O = size(R4Tensor1,3)
      P = size(R4Tensor1,4)

      if(M.ne.size(R4Tensor2,1).or.N.ne.size(R4Tensor2,2).or.O.ne.size(R4Tensor2,3).or.P.ne.size(R4Tensor2,4)) &
        call MQC_Error('R4Tensors not conformable in MQC_R4Tensor_R4Tensor_Subtract',6)

      call difference%init(M,N,O,P)

      do i = 1,M
        do j = 1,N
          do k = 1,O
            do l = 1,P
              call difference%put(R4Tensor1%at(i,j,k,l)-R4Tensor2%at(i,j,k,l),i,j,k,l)
            endDo
          endDo
        endDo
      endDo
!
      End Function MQC_R4Tensor_R4Tensor_Difference
!
!
!     PROCEDURE MQC_R4Tensor_Vector_At
!
!>    \brief <b> MQC_R4Tensor_Vector_At is a function that returns a subvector of 
!>    the r4 tensor</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_R4Tensor_At is a function that returns the vector between indices 
!>    D1, D2, D3 and D4. If the values in the index specification are negative, the 
!>    index is counted back from the final element. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] TensorIn
!>    \verbatim
!>        TensorIn is Class(MQC_R4Tensor)
!>        Name of the input rank-4 tensor variable
!>    \endverbatim
!>
!>    \param[in] D1 
!>    \verbatim
!>        D1 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 1 A to B
!>          If (A,B)>0 dimension 1 count is from first index
!>          If (A,B)<0 dimension 1 count is from last index
!>        If = [0]: subarray of dimension 1 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D2
!>    \verbatim
!>        D2 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 2 A to B
!>          If (A,B)>0 dimension 2 count is from first index
!>          If (A,B)<0 dimension 2 count is from last index
!>        If = [0]: subarray of dimension 2 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D3
!>    \verbatim
!>        D3 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 3 A to B
!>          If (A,B)>0 dimension 3 count is from first index
!>          If (A,B)<0 dimension 3 count is from last index
!>        If = [0]: subarray of dimension 3 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D4
!>    \verbatim
!>        D4 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 4 A to B
!>          If (A,B)>0 dimension 4 count is from first index
!>          If (A,B)<0 dimension 4 count is from last index
!>        If = [0]: subarray of dimension 4 equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_R4Tensor_Vector_At(TensorIn,D1,D2,D3,D4) Result(VectorOut)
!
      Implicit None
      Class(MQC_R4Tensor),Intent(In)::TensorIn
      Type(MQC_Vector)::VectorOut
      Integer(kind=int64),Dimension(:),Intent(In)::D1,D2,D3,D4
      Real(kind=real64),Dimension(:,:,:,:),Allocatable::realR4Tensor
      Integer(kind=int64),Dimension(:,:,:,:),Allocatable::intR4Tensor
      Complex(kind=real64),Dimension(:,:,:,:),Allocatable::compR4Tensor
      
!     Check input indicies for consistency
      if(size(D1)*size(D2)*size(D3)*size(D4).ne.1.and.size(D1)*size(D2)*size(D3)*size(D4).ne.2)&
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_vector_At does not&
        & conform to a vector')
      if((D1(1).eq.0.and.D2(1).eq.0).or.(D1(1).eq.0.and.D3(1).eq.0).or. &
        (D1(1).eq.0.and.D4(1).eq.0).or.(D2(1).eq.0.and.D3(1).eq.0).or. &
        (D2(1).eq.0.and.D4(1).eq.0).or.(D3(1).eq.0.and.D4(1).eq.0)) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_vector_At does not&
        & conform to a vector')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.1.and.D1(1)*D2(1)*D3(1)*D4(1).ne.0) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_vector_At does not&
        & conform to a vector')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.2.and.D1(1)*D2(1)*D3(1)*D4(1).eq.0) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_vector_At does not&
        & conform to a vector ')

      if(MQC_R4Tensor_HaveReal(TensorIn)) then
        if(size(D1).eq.2.or.D1(1).eq.0) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            [D3(1),D3(1)],[D4(1),D4(1)])
          vectorOut = RealR4Tensor(:,1,1,1)
          vectorOut%Column = .True.
        elseIf(size(D2).eq.2.or.D2(1).eq.0) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            [D3(1),D3(1)],[D4(1),D4(1)])
          vectorOut = RealR4Tensor(1,:,1,1)
          vectorOut%Column = .False.
        elseIf(size(D3).eq.2.or.D3(1).eq.0) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            D3,[D4(1),D4(1)])
          vectorOut = RealR4Tensor(1,1,:,1)
          vectorOut%Column = .False.
        elseIf(size(D4).eq.2.or.D4(1).eq.0) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            [D3(1),D3(1)],D4)
          vectorOut = RealR4Tensor(1,1,1,:)
          vectorOut%Column = .True.
        endIf
      elseIf(MQC_R4Tensor_HaveInteger(TensorIn)) then
        if(size(D1).eq.2.or.D1(1).eq.0) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            [D3(1),D3(1)],[D4(1),D4(1)])
          vectorOut = IntR4Tensor(:,1,1,1)
          vectorOut%Column = .True.
        elseIf(size(D2).eq.2.or.D2(1).eq.0) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            [D3(1),D3(1)],[D4(1),D4(1)])
          vectorOut = IntR4Tensor(1,:,1,1)
          vectorOut%Column = .False.
        elseIf(size(D3).eq.2.or.D3(1).eq.0) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            D3,[D4(1),D4(1)])
          vectorOut = IntR4Tensor(1,1,:,1)
          vectorOut%Column = .False.
        elseIf(size(D4).eq.2.or.D4(1).eq.0) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            [D3(1),D3(1)],D4)
          vectorOut = IntR4Tensor(1,1,1,:)
          vectorOut%Column = .True.
        endIf
      elseIf(MQC_R4Tensor_HaveComplex(TensorIn)) then
        if(size(D1).eq.2.or.D1(1).eq.0) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            [D3(1),D3(1)],[D4(1),D4(1)])
          vectorOut = CompR4Tensor(:,1,1,1)
          vectorOut%Column = .True.
        elseIf(size(D2).eq.2.or.D2(1).eq.0) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            [D3(1),D3(1)],[D4(1),D4(1)])
          vectorOut = CompR4Tensor(1,:,1,1)
          vectorOut%Column = .False.
        elseIf(size(D3).eq.2.or.D3(1).eq.0) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            D3,[D4(1),D4(1)])
          vectorOut = CompR4Tensor(1,1,:,1)
          vectorOut%Column = .False.
        elseIf(size(D4).eq.2.or.D4(1).eq.0) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            [D3(1),D3(1)],D4)
          vectorOut = CompR4Tensor(1,1,1,:)
          vectorOut%Column = .True.
        endIf
      endIf

      End Function MQC_R4Tensor_Vector_At
!
!
!     PROCEDURE MQC_R4Tensor_Vector_Put
!
!>    \brief <b> MQC_R4Tensor_Vector_Put is a subroutine that updates an r4 tensor with
!>    a vector at the specified inidices</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_Vector_Put is a subroutine that updates an r4 tensor with a vector
!>    between inidices D1, D2, D3, D4. If the values in the index specification are 
!>    negative, the index is counted back from the final element.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] Ten
!>    \verbatim
!>        Ten is Class(MQC_R4Tensor)
!>        Name of the input rank-4 tensor variable to update with 
!>        vector.
!>    \endverbatim
!>    
!>    \param[in] VectorIn
!>    \verbatim
!>        VectorIn is Type(MQC_Vector)
!>        The vector to overwrite at the specified elements of Ten.
!>    \endverbatim
!>
!>    \param[in] D1 
!>    \verbatim
!>        D1 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 1 A to B
!>          If (A,B)>0 dimension 1 count is from first index
!>          If (A,B)<0 dimension 1 count is from last index
!>        If = [0]: subarray of dimension 1 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D2
!>    \verbatim
!>        D2 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 2 A to B
!>          If (A,B)>0 dimension 2 count is from first index
!>          If (A,B)<0 dimension 2 count is from last index
!>        If = [0]: subarray of dimension 2 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D3
!>    \verbatim
!>        D3 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 3 A to B
!>          If (A,B)>0 dimension 3 count is from first index
!>          If (A,B)<0 dimension 3 count is from last index
!>        If = [0]: subarray of dimension 3 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D4
!>    \verbatim
!>        D4 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 4 A to B
!>          If (A,B)>0 dimension 4 count is from first index
!>          If (A,B)<0 dimension 4 count is from last index
!>        If = [0]: subarray of dimension 4 equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2020
!
      Subroutine MQC_R4Tensor_Vector_Put(Ten,VectorIn,D1,D2,D3,D4) 
!
      Implicit None
      Class(MQC_R4Tensor),Intent(InOut)::Ten
      Type(MQC_Vector),Intent(In)::VectorIn
      Type(MQC_R4Tensor)::TensorIn
      Integer(kind=int64),Dimension(:),Intent(In)::D1,D2,D3,D4
      Real(kind=real64),Dimension(:,:,:,:),Allocatable::RtmpTensor
      Integer(kind=int64),Dimension(:,:,:,:),Allocatable::ItmpTensor
      Complex(kind=real64),Dimension(:,:,:,:),Allocatable::CtmpTensor
      Real(kind=real64),Dimension(:),Allocatable::RtmpVector
      Integer(kind=int64),Dimension(:),Allocatable::ItmpVector
      Complex(kind=real64),Dimension(:),Allocatable::CtmpVector
      
!     Check input indicies for consistency
      if(size(D1)*size(D2)*size(D3)*size(D4).ne.1.and.size(D1)*size(D2)*size(D3)*size(D4).ne.2)&
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Vector_Put does not&
        & conform to a vector')
      if((D1(1).eq.0.and.D2(1).eq.0).or.(D1(1).eq.0.and.D3(1).eq.0).or. &
        (D1(1).eq.0.and.D4(1).eq.0).or.(D2(1).eq.0.and.D3(1).eq.0).or. &
        (D2(1).eq.0.and.D4(1).eq.0).or.(D3(1).eq.0.and.D4(1).eq.0)) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Vector_Put does not&
        & conform to a vector')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.1.and.D1(1)*D2(1)*D3(1)*D4(1).ne.0) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Vector_Put does not&
        & conform to a vector')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.2.and.D1(1)*D2(1)*D3(1)*D4(1).eq.0) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Vector_Put does not&
        & conform to a vector ')

      if(size(D1,1).eq.2.or.D1(1).eq.0) then
        if(MQC_Vector_HaveInteger(VectorIn)) then
          ItmpVector = VectorIn
          allocate(ItmpTensor(size(ItmpVector),1,1,1))
          ItmpTensor(:,1,1,1) = ItmpVector
          TensorIn = ItmpTensor
        elseIf(MQC_Vector_HaveReal(VectorIn)) then
          RtmpVector = VectorIn
          allocate(RtmpTensor(size(RtmpVector),1,1,1))
          RtmpTensor(:,1,1,1) = RtmpVector
          TensorIn = RtmpTensor
        elseIf(MQC_Vector_HaveComplex(VectorIn)) then
          CtmpVector = VectorIn
          allocate(CtmpTensor(size(CtmpVector),1,1,1))
          CtmpTensor(:,1,1,1) = CtmpVector
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,D1,[D2(1),D2(1)],[D3(1),D3(1)],[D4(1),D4(1)])
      elseIf(size(D2,1).eq.2.or.D2(1).eq.0) then
        if(MQC_Vector_HaveInteger(VectorIn)) then
          ItmpVector = VectorIn
          allocate(ItmpTensor(1,size(ItmpVector),1,1))
          ItmpTensor(1,:,1,1) = ItmpVector
          TensorIn = ItmpTensor
        elseIf(MQC_Vector_HaveReal(VectorIn)) then
          RtmpVector = VectorIn
          allocate(RtmpTensor(1,size(RtmpVector),1,1))
          RtmpTensor(1,:,1,1) = RtmpVector
          TensorIn = RtmpTensor
        elseIf(MQC_Vector_HaveComplex(VectorIn)) then
          CtmpVector = VectorIn
          allocate(CtmpTensor(1,size(CtmpVector),1,1))
          CtmpTensor(1,:,1,1) = CtmpVector
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,[D1(1),D1(1)],D2,[D3(1),D3(1)],[D4(1),D4(1)])
      elseIf(size(D3,1).eq.2.or.D3(1).eq.0) then
        if(MQC_Vector_HaveInteger(VectorIn)) then
          ItmpVector = VectorIn
          allocate(ItmpTensor(1,1,size(ItmpVector),1))
          ItmpTensor(1,1,:,1) = ItmpVector
          TensorIn = ItmpTensor
        elseIf(MQC_Vector_HaveReal(VectorIn)) then
          RtmpVector = VectorIn
          allocate(RtmpTensor(1,1,size(RtmpVector),1))
          RtmpTensor(1,1,:,1) = RtmpVector
          TensorIn = RtmpTensor
        elseIf(MQC_Vector_HaveComplex(VectorIn)) then
          CtmpVector = VectorIn
          allocate(CtmpTensor(1,1,size(CtmpVector),1))
          CtmpTensor(1,1,:,1) = CtmpVector
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)],D3,[D4(1),D4(1)])
      elseIf(size(D4,1).eq.2.or.D4(1).eq.0) then
        if(MQC_Vector_HaveInteger(VectorIn)) then
          ItmpVector = VectorIn
          allocate(ItmpTensor(1,1,1,size(ItmpVector)))
          ItmpTensor(1,1,1,:) = ItmpVector
          TensorIn = ItmpTensor
        elseIf(MQC_Vector_HaveReal(VectorIn)) then
          RtmpVector = VectorIn
          allocate(RtmpTensor(1,1,1,size(RtmpVector)))
          RtmpTensor(1,1,1,:) = RtmpVector
          TensorIn = RtmpTensor
        elseIf(MQC_Vector_HaveComplex(VectorIn)) then
          CtmpVector = VectorIn
          allocate(CtmpTensor(1,1,1,size(CtmpVector)))
          CtmpTensor(1,1,1,:) = CtmpVector
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)],[D3(1),D3(1)],D4)
      endIf

      End Subroutine MQC_R4Tensor_Vector_Put
!
!
!     PROCEDURE MQC_R4Tensor_Matrix_At
!
!>    \brief <b> MQC_R4Tensor_Matrix_At is a function that returns a submatrix of 
!>    the r4 tensor</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_Matrix_At is a function that returns the matrix between indices 
!>    D1, D2, D3 and D4. If the values in the index specification are negative, the 
!>    index is counted back from the final element. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] TensorIn
!>    \verbatim
!>        TensorIn is Class(MQC_R4Tensor)
!>        Name of the input rank-4 tensor variable
!>    \endverbatim
!>
!>    \param[in] D1 
!>    \verbatim
!>        D1 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 1 A to B
!>          If (A,B)>0 dimension 1 count is from first index
!>          If (A,B)<0 dimension 1 count is from last index
!>        If = [0]: subarray of dimension 1 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D2
!>    \verbatim
!>        D2 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 2 A to B
!>          If (A,B)>0 dimension 2 count is from first index
!>          If (A,B)<0 dimension 2 count is from last index
!>        If = [0]: subarray of dimension 2 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D3
!>    \verbatim
!>        D3 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 3 A to B
!>          If (A,B)>0 dimension 3 count is from first index
!>          If (A,B)<0 dimension 3 count is from last index
!>        If = [0]: subarray of dimension 3 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D4
!>    \verbatim
!>        D4 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 4 A to B
!>          If (A,B)>0 dimension 4 count is from first index
!>          If (A,B)<0 dimension 4 count is from last index
!>        If = [0]: subarray of dimension 4 equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_R4Tensor_Matrix_At(TensorIn,D1,D2,D3,D4) Result(MatrixOut)
!
      Implicit None
      Class(MQC_R4Tensor),Intent(In)::TensorIn
      Type(MQC_Matrix)::MatrixOut
      Integer(kind=int64),Dimension(:),Intent(In)::D1,D2,D3,D4
      Real(kind=real64),Dimension(:,:,:,:),Allocatable::realR4Tensor
      Integer(kind=int64),Dimension(:,:,:,:),Allocatable::intR4Tensor
      Complex(kind=real64),Dimension(:,:,:,:),Allocatable::compR4Tensor
      
!     Check input indicies for consistency
      if(size(D1)*size(D2)*size(D3)*size(D4).ne.1.and. &
        size(D1)*size(D2)*size(D3)*size(D4).ne.2.and. &
        size(D1)*size(D2)*size(D3)*size(D4).ne.4) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_At does not&
        & conform to a matrix')
      if((D1(1).eq.0.and.D2(1).eq.0.and.D3(1).eq.0).or. &
        (D1(1).eq.0.and.D2(1).eq.0.and.D4(1).eq.0).or. &
        (D1(1).eq.0.and.D3(1).eq.0.and.D4(1).eq.0).or. &
        (D2(1).eq.0.and.D3(1).eq.0.and.D4(1).eq.0)) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_At does not&
        & conform to a matrix')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.4.and.D1(1)*D2(1)*D3(1)*D4(1).eq.0) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_At does not&
        & conform to a matrix')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.2.and. &
        ((D1(1)*D2(1)*D3(1)*D4(1).ne.0).or. &
        ((D1(1)*D2(1)*D3(1).eq.0).and.(D1(1)*D2(1)*D4(1).eq.0).and. &
        (D1(1)*D3(1)*D4(1).eq.0).and.(D2(1)*D3(1)*D4(1).eq.0)))) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_At does not&
        & conform to a matrix')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.1.and. &
        (D1(1).ne.0.and.D2(1).ne.0).and. &
        (D1(1).ne.0.and.D3(1).ne.0).and. &
        (D1(1).ne.0.and.D4(1).ne.0).and. &
        (D2(1).ne.0.and.D3(1).ne.0).and. &
        (D2(1).ne.0.and.D4(1).ne.0).and. &
        (D3(1).ne.0.and.D4(1).ne.0)) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_At does not&
        & conform to a matrix')

      if(MQC_R4Tensor_HaveReal(TensorIn)) then
        if((size(D1).eq.2.or.D1(1).eq.0).and.(size(D2).eq.2.or.D2(1).eq.0)) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,D2, &
            [D3(1),D3(1)],[D4(1),D4(1)])
          matrixOut = RealR4Tensor(:,:,1,1)
        elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            D3,[D4(1),D4(1)])
          matrixOut = RealR4Tensor(:,1,:,1)
        elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            [D3(1),D3(1)],D4)
          matrixOut = RealR4Tensor(:,1,1,:)
        elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            D3,[D4(1),D4(1)])
          matrixOut = RealR4Tensor(1,:,:,1)
        elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            [D3(1),D3(1)],D4)
          matrixOut = RealR4Tensor(1,:,1,:)
        elseIf((size(D3).eq.2.or.D3(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          RealR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            D3,D4)
          matrixOut = RealR4Tensor(1,1,:,:)
        endIf
      elseIf(MQC_R4Tensor_HaveInteger(TensorIn)) then
        if((size(D1).eq.2.or.D1(1).eq.0).and.(size(D2).eq.2.or.D2(1).eq.0)) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,D2, &
            [D3(1),D3(1)],[D4(1),D4(1)])
          matrixOut = IntR4Tensor(:,:,1,1)
        elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            D3,[D4(1),D4(1)])
          matrixOut = IntR4Tensor(:,1,:,1)
        elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            [D3(1),D3(1)],D4)
          matrixOut = IntR4Tensor(:,1,1,:)
        elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            D3,[D4(1),D4(1)])
          matrixOut = IntR4Tensor(1,:,:,1)
        elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            [D3(1),D3(1)],D4)
          matrixOut = IntR4Tensor(1,:,1,:)
        elseIf((size(D3).eq.2.or.D3(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          IntR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            D3,D4)
          matrixOut = IntR4Tensor(1,1,:,:)
        endIf
      elseIf(MQC_R4Tensor_HaveComplex(TensorIn)) then
        if((size(D1).eq.2.or.D1(1).eq.0).and.(size(D2).eq.2.or.D2(1).eq.0)) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,D2, &
            [D3(1),D3(1)],[D4(1),D4(1)])
          matrixOut = CompR4Tensor(:,:,1,1)
        elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            D3,[D4(1),D4(1)])
          matrixOut = CompR4Tensor(:,1,:,1)
        elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,D1,[D2(1),D2(1)], &
            [D3(1),D3(1)],D4)
          matrixOut = CompR4Tensor(:,1,1,:)
        elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            D3,[D4(1),D4(1)])
          matrixOut = CompR4Tensor(1,:,:,1)
        elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],D2, &
            [D3(1),D3(1)],D4)
          matrixOut = CompR4Tensor(1,:,1,:)
        elseIf((size(D3).eq.2.or.D3(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
          CompR4Tensor = MQC_R4Tensor_R4Tensor_At(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)], &
            D3,D4)
          matrixOut = CompR4Tensor(1,1,:,:)
        endIf
      endIf

      End Function MQC_R4Tensor_Matrix_At
!
!
!     PROCEDURE MQC_R4Tensor_Matrix_Put
!
!>    \brief <b> MQC_R4Tensor_Matrix_Put is a subroutine that updates an r4 tensor with
!>    a matrix at the specified inidices</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_Matrix_Put is a subroutine that updates an r4 tensor with a matrix
!>    between inidices D1, D2, D3, D4. If the values in the index specification are 
!>    negative, the index is counted back from the final element.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] Ten
!>    \verbatim
!>        Ten is Class(MQC_R4Tensor)
!>        Name of the input rank-4 tensor variable to update with 
!>        vector.
!>    \endverbatim
!>    
!>    \param[in] MatrixIn
!>    \verbatim
!>        VectorIn is Type(MQC_Matrix)
!>        The matrix to overwrite at the specified elements of Ten.
!>    \endverbatim
!>
!>    \param[in] D1 
!>    \verbatim
!>        D1 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 1 A to B
!>          If (A,B)>0 dimension 1 count is from first index
!>          If (A,B)<0 dimension 1 count is from last index
!>        If = [0]: subarray of dimension 1 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D2
!>    \verbatim
!>        D2 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 2 A to B
!>          If (A,B)>0 dimension 2 count is from first index
!>          If (A,B)<0 dimension 2 count is from last index
!>        If = [0]: subarray of dimension 2 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D3
!>    \verbatim
!>        D3 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 3 A to B
!>          If (A,B)>0 dimension 3 count is from first index
!>          If (A,B)<0 dimension 3 count is from last index
!>        If = [0]: subarray of dimension 3 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D4
!>    \verbatim
!>        D4 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 4 A to B
!>          If (A,B)>0 dimension 4 count is from first index
!>          If (A,B)<0 dimension 4 count is from last index
!>        If = [0]: subarray of dimension 4 equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2020
!
      Subroutine MQC_R4Tensor_Matrix_Put(Ten,matrixIn,D1,D2,D3,D4) 
!
      Implicit None
      Class(MQC_R4Tensor),Intent(InOut)::Ten
      Type(MQC_Matrix),Intent(In)::MatrixIn
      Type(MQC_R4Tensor)::TensorIn
      Integer(kind=int64),Dimension(:),Intent(In)::D1,D2,D3,D4
      Real(kind=real64),Dimension(:,:,:,:),Allocatable::RtmpTensor
      Integer(kind=int64),Dimension(:,:,:,:),Allocatable::ItmpTensor
      Complex(kind=real64),Dimension(:,:,:,:),Allocatable::CtmpTensor
      Real(kind=real64),Dimension(:,:),Allocatable::RtmpMatrix
      Integer(kind=int64),Dimension(:,:),Allocatable::ItmpMatrix
      Complex(kind=real64),Dimension(:,:),Allocatable::CtmpMatrix
      
!     Check input indicies for consistency
      if(size(D1)*size(D2)*size(D3)*size(D4).ne.1.and. &
        size(D1)*size(D2)*size(D3)*size(D4).ne.2.and. &
        size(D1)*size(D2)*size(D3)*size(D4).ne.4) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_Put does not&
        & conform to a matrix')
      if((D1(1).eq.0.and.D2(1).eq.0.and.D3(1).eq.0).or. &
        (D1(1).eq.0.and.D2(1).eq.0.and.D4(1).eq.0).or. &
        (D1(1).eq.0.and.D3(1).eq.0.and.D4(1).eq.0).or. &
        (D2(1).eq.0.and.D3(1).eq.0.and.D4(1).eq.0)) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_Put does not&
        & conform to a matrix')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.4.and.D1(1)*D2(1)*D3(1)*D4(1).eq.0) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_Put does not&
        & conform to a matrix')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.2.and. &
        ((D1(1)*D2(1)*D3(1)*D4(1).ne.0).or. &
        ((D1(1)*D2(1)*D3(1).eq.0).and.(D1(1)*D2(1)*D4(1).eq.0).and. &
        (D1(1)*D3(1)*D4(1).eq.0).and.(D2(1)*D3(1)*D4(1).eq.0)))) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_Put does not&
        & conform to a matrix')
      if(size(D1)*size(D2)*size(D3)*size(D4).eq.1.and. &
        (D1(1).ne.0.and.D2(1).ne.0).and. &
        (D1(1).ne.0.and.D3(1).ne.0).and. &
        (D1(1).ne.0.and.D4(1).ne.0).and. &
        (D2(1).ne.0.and.D3(1).ne.0).and. &
        (D2(1).ne.0.and.D4(1).ne.0).and. &
        (D3(1).ne.0.and.D4(1).ne.0)) &
        call mqc_error('Dimension of slice requested in MQC_R4Tensor_Matrix_Put does not&
        & conform to a matrix')

      if((size(D1).eq.2.or.D1(1).eq.0).and.(size(D2).eq.2.or.D2(1).eq.0)) then
        if(MQC_Matrix_HaveInteger(MatrixIn)) then
          ItmpMatrix = MatrixIn
          allocate(ItmpTensor(size(ItmpMatrix,1),size(ItmpMatrix,2),1,1))
          ItmpTensor(:,:,1,1) = ItmpMatrix
          TensorIn = ItmpTensor
        elseIf(MQC_Matrix_HaveReal(MatrixIn)) then
          RtmpMatrix = MatrixIn
          allocate(RtmpTensor(size(RtmpMatrix,1),size(RtmpMatrix,2),1,1))
          RtmpTensor(:,:,1,1) = RtmpMatrix
          TensorIn = RtmpTensor
        elseIf(MQC_Matrix_HaveComplex(MatrixIn)) then
          CtmpMatrix = MatrixIn
          allocate(CtmpTensor(size(CtmpMatrix,1),size(CtmpMatrix,2),1,1))
          CtmpTensor(:,:,1,1) = CtmpMatrix
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,D1,D2,[D3(1),D3(1)],[D4(1),D4(1)])
      elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
        if(MQC_Matrix_HaveInteger(MatrixIn)) then
          ItmpMatrix = MatrixIn
          allocate(ItmpTensor(size(ItmpMatrix,1),1,size(ItmpMatrix,2),1))
          ItmpTensor(:,1,:,1) = ItmpMatrix
          TensorIn = ItmpTensor
        elseIf(MQC_Matrix_HaveReal(MatrixIn)) then
          RtmpMatrix = MatrixIn
          allocate(RtmpTensor(size(RtmpMatrix,1),1,size(RtmpMatrix,2),1))
          RtmpTensor(:,1,:,1) = RtmpMatrix
          TensorIn = RtmpTensor
        elseIf(MQC_Matrix_HaveComplex(MatrixIn)) then
          CtmpMatrix = MatrixIn
          allocate(CtmpTensor(size(CtmpMatrix,1),1,size(CtmpMatrix,2),1))
          CtmpTensor(:,1,:,1) = CtmpMatrix
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,D1,[D2(1),D2(1)],D3,[D4(1),D4(1)])
      elseIf((size(D1).eq.2.or.D1(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
        if(MQC_Matrix_HaveInteger(MatrixIn)) then
          ItmpMatrix = MatrixIn
          allocate(ItmpTensor(size(ItmpMatrix,1),1,1,size(ItmpMatrix,2)))
          ItmpTensor(:,1,1,:) = ItmpMatrix
          TensorIn = ItmpTensor
        elseIf(MQC_Matrix_HaveReal(MatrixIn)) then
          RtmpMatrix = MatrixIn
          allocate(RtmpTensor(size(RtmpMatrix,1),1,1,size(RtmpMatrix,2)))
          RtmpTensor(:,1,1,:) = RtmpMatrix
          TensorIn = RtmpTensor
        elseIf(MQC_Matrix_HaveComplex(MatrixIn)) then
          CtmpMatrix = MatrixIn
          allocate(CtmpTensor(size(CtmpMatrix,1),1,1,size(CtmpMatrix,2)))
          CtmpTensor(:,1,1,:) = CtmpMatrix
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,D1,[D2(1),D2(1)],[D3(1),D3(1)],D4)
      elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D3).eq.2.or.D3(1).eq.0)) then
        if(MQC_Matrix_HaveInteger(MatrixIn)) then
          ItmpMatrix = MatrixIn
          allocate(ItmpTensor(1,size(ItmpMatrix,1),size(ItmpMatrix,2),1))
          ItmpTensor(1,:,:,1) = ItmpMatrix
          TensorIn = ItmpTensor
        elseIf(MQC_Matrix_HaveReal(MatrixIn)) then
          RtmpMatrix = MatrixIn
          allocate(RtmpTensor(1,size(RtmpMatrix,1),size(RtmpMatrix,2),1))
          RtmpTensor(1,:,:,1) = RtmpMatrix
          TensorIn = RtmpTensor
        elseIf(MQC_Matrix_HaveComplex(MatrixIn)) then
          CtmpMatrix = MatrixIn
          allocate(CtmpTensor(1,size(CtmpMatrix,1),size(CtmpMatrix,2),1))
          CtmpTensor(1,:,:,1) = CtmpMatrix
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,[D1(1),D1(1)],D2,D3,[D4(1),D4(1)])
      elseIf((size(D2).eq.2.or.D2(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
        if(MQC_Matrix_HaveInteger(MatrixIn)) then
          ItmpMatrix = MatrixIn
          allocate(ItmpTensor(1,size(ItmpMatrix,1),1,size(ItmpMatrix,2)))
          ItmpTensor(1,:,1,:) = ItmpMatrix
          TensorIn = ItmpTensor
        elseIf(MQC_Matrix_HaveReal(MatrixIn)) then
          RtmpMatrix = MatrixIn
          allocate(RtmpTensor(1,size(RtmpMatrix,1),1,size(RtmpMatrix,2)))
          RtmpTensor(1,:,1,:) = RtmpMatrix
          TensorIn = RtmpTensor
        elseIf(MQC_Matrix_HaveComplex(MatrixIn)) then
          CtmpMatrix = MatrixIn
          allocate(CtmpTensor(1,size(CtmpMatrix,1),1,size(CtmpMatrix,2)))
          CtmpTensor(1,:,1,:) = CtmpMatrix
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,[D1(1),D1(1)],D2,[D3(1),D3(1)],D4)
      elseIf((size(D3).eq.2.or.D3(1).eq.0).and.(size(D4).eq.2.or.D4(1).eq.0)) then
        if(MQC_Matrix_HaveInteger(MatrixIn)) then
          ItmpMatrix = MatrixIn
          allocate(ItmpTensor(1,1,size(ItmpMatrix,1),size(ItmpMatrix,2)))
          ItmpTensor(1,1,:,:) = ItmpMatrix
          TensorIn = ItmpTensor
        elseIf(MQC_Matrix_HaveReal(MatrixIn)) then
          RtmpMatrix = MatrixIn
          allocate(RtmpTensor(1,1,size(RtmpMatrix,1),size(RtmpMatrix,2)))
          RtmpTensor(1,1,:,:) = RtmpMatrix
          TensorIn = RtmpTensor
        elseIf(MQC_Matrix_HaveComplex(MatrixIn)) then
          CtmpMatrix = MatrixIn
          allocate(CtmpTensor(1,1,size(CtmpMatrix,1),size(CtmpMatrix,2)))
          CtmpTensor(1,1,:,:) = CtmpMatrix
          TensorIn = CtmpTensor
        endIf
        call Ten%tput(TensorIn,[D1(1),D1(1)],[D2(1),D2(1)],D3,D4)
      endIf

      End Subroutine MQC_R4Tensor_Matrix_Put
!
!
!     PROCEDURE MQC_R4Tensor_R4Tensor_At
!
!>    \brief <b> MQC_R4Tensor_R4Tensor_At is a function that returns a subtensor of 
!>    the r4 tensor</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_R4Tensor_At is a function that returns the r4 tensor between indices 
!>    D1, D2, D3 and D4. If the values in the index specification are negative, the 
!>    index is counted back from the final element. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] TensorIn
!>    \verbatim
!>        TensorIn is Class(MQC_R4Tensor)
!>        Name of the input rank-4 tensor variable
!>    \endverbatim
!>
!>    \param[in] D1 
!>    \verbatim
!>        D1 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 1 A to B
!>          If (A,B)>0 dimension 1 count is from first index
!>          If (A,B)<0 dimension 1 count is from last index
!>        If = [0]: subarray of dimension 1 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D2
!>    \verbatim
!>        D2 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 2 A to B
!>          If (A,B)>0 dimension 2 count is from first index
!>          If (A,B)<0 dimension 2 count is from last index
!>        If = [0]: subarray of dimension 2 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D3
!>    \verbatim
!>        D3 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 3 A to B
!>          If (A,B)>0 dimension 3 count is from first index
!>          If (A,B)<0 dimension 3 count is from last index
!>        If = [0]: subarray of dimension 3 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D4
!>    \verbatim
!>        D4 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: output is subarray of dimension 4 A to B
!>          If (A,B)>0 dimension 4 count is from first index
!>          If (A,B)<0 dimension 4 count is from last index
!>        If = [0]: subarray of dimension 4 equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_R4Tensor_At(TensorIn,D1,D2,D3,D4) Result(TensorOut)
!
      Implicit None
      Class(MQC_R4Tensor),Intent(In)::TensorIn
      Type(MQC_R4Tensor)::TensorOut
      Integer(kind=int64),Dimension(:),Intent(In)::D1,D2,D3,D4
      Integer(kind=int64)::Len1,Len2,Len3,Len4,IndI,IndJ,IndK,IndL,IndM,IndN,IndO,IndP
      Integer(kind=int64)::I,J,K,L,M,N,O,P,Q,R,S,T,Cnt1,Cnt2,Cnt3,Cnt4

      If(Size(D1).eq.1.and.D1(1).eq.0) then
        I = 1
        J = Size(TensorIn,1)
      elseIf(Size(D1).eq.2.and.D1(1).ne.0.and.D1(2).ne.(0)) then
        I = D1(1)
        J = D1(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D1)', Size(D1))
      endIf
      If(Size(D2).eq.1.and.D2(1).eq.0) then
        K = 1
        L = Size(TensorIn,2)
      elseIf(Size(D2).eq.2.and.D2(1).ne.0.and.D2(2).ne.(0)) then
        K = D2(1)
        L = D2(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D2)', Size(D2))
      endIf
      If(Size(D3).eq.1.and.D3(1).eq.0) then
        M = 1
        N = Size(TensorIn,3)
      elseIf(Size(D3).eq.2.and.D3(1).ne.0.and.D3(2).ne.(0)) then
        M = D3(1)
        N = D3(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D3)', Size(D3))
      endIf
      If(Size(D4).eq.1.and.D4(1).eq.0) then
        O = 1
        P = Size(TensorIn,4)
      elseIf(Size(D4).eq.2.and.D4(1).ne.0.and.D4(2).ne.(0)) then
        O = D4(1)
        P = D4(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D4)', Size(D4))
      endIf

      IndI = I
      IndJ = J
      If (IndI.lt.0) IndI = Size(TensorIn,1) + IndI + 1
      If (IndJ.lt.0) IndJ = Size(TensorIn,1) + IndJ + 1
      Len1 = IndJ-IndI+1
      If (Len1.le.0.or.Len1.gt.Size(TensorIn,1)) Call MQC_Error_I('Dimension 1 length badly &
           & defined in MQC_R4Tensor_R4Tensor_At',6,'Len1',Len1,'Size(TensorIn,1)', &
           Size(TensorIn,1) )
      If (IndI.le.0.or.IndI.gt.(Size(TensorIn,1)-Len1+1)) Call MQC_Error_I('Index I out of &
           & bounds in MQC_R4Tensor_R4Tensor_At',6,'IndI',IndI,'Size(TensorIn,1)', &
           Size(TensorIn,1),'Len1', Len1 )
      If (IndJ.lt.Len1.or.IndJ.gt.Size(TensorIn,1)) Call MQC_Error_I('Index J out of bounds &
           & in MQC_R4Tensor_R4Tensor_At',6,'IndJ',IndJ,'Len1',Len1,'Size(TensorIn,1)', &
           Size(TensorIn,1))
      IndK = K
      IndL = L
      If (IndK.lt.0) IndK = Size(TensorIn,2) + IndK + 1
      If (IndL.lt.0) IndL = Size(TensorIn,2) + IndL + 1
      Len2 = IndL-IndK+1
      If (Len2.le.0.or.Len2.gt.Size(TensorIn,2)) Call MQC_Error_I('Dimension 2 length badly &
           & defined in MQC_R4Tensor_R4Tensor_At',6,'Len2',Len2,'Size(TensorIn,2)', &
           Size(TensorIn,2) )
      If (IndK.le.0.or.IndK.gt.(Size(TensorIn,2)-Len2+1)) Call MQC_Error_I('Index K out of &
           & bounds in MQC_R4Tensor_R4Tensor_At',6,'IndK',IndK,'Size(TensorIn,2)', &
           Size(TensorIn,2),'Len2', Len2 )
      If (IndL.lt.Len2.or.IndL.gt.Size(TensorIn,2)) Call MQC_Error_I('Index L out of bounds &
           & in MQC_R4Tensor_R4Tensor_At',6,'IndL',IndL,'Len2',Len2,'Size(TensorIn,2)', &
           Size(TensorIn,2))
      IndM = M
      IndN = N
      If (IndM.lt.0) IndM = Size(TensorIn,3) + IndM + 1
      If (IndN.lt.0) IndN = Size(TensorIn,3) + IndN + 1
      Len3 = IndN-IndM+1
      If (Len3.le.0.or.Len3.gt.Size(TensorIn,3)) Call MQC_Error_I('Dimension 3 length badly &
           & defined in MQC_R4Tensor_R4Tensor_At',6,'Len3',Len3,'Size(TensorIn,3)', &
           Size(TensorIn,3) )
      If (IndM.le.0.or.IndM.gt.(Size(TensorIn,3)-Len3+1)) Call MQC_Error_I('Index M out of &
           & bounds in MQC_R4Tensor_R4Tensor_At',6,'IndM',IndM,'Size(TensorIn,3)', &
           Size(TensorIn,3),'Len3', Len3 )
      If (IndN.lt.Len3.or.IndN.gt.Size(TensorIn,3)) Call MQC_Error_I('Index N out of bounds &
           & in MQC_R4Tensor_R4Tensor_At',6,'IndN',IndN,'Len3',Len3,'Size(TensorIn,3)', &
           Size(TensorIn,3))
      IndO = O
      IndP = P
      If (IndO.lt.0) IndO = Size(TensorIn,4) + IndO + 1
      If (IndP.lt.0) IndP = Size(TensorIn,4) + IndP + 1
      Len4 = IndP-IndO+1
      If (Len4.le.0.or.Len4.gt.Size(TensorIn,4)) Call MQC_Error_I('Dimension 4 length badly &
           & defined in MQC_R4Tensor_R4Tensor_At',6,'Len4',Len4,'Size(TensorIn,4)', &
           Size(TensorIn,4) )
      If (IndO.le.0.or.IndO.gt.(Size(TensorIn,4)-Len4+1)) Call MQC_Error_I('Index O out of &
           & bounds in MQC_R4Tensor_R4Tensor_At',6,'IndO',IndO,'Size(TensorIn,4)', &
           Size(TensorIn,4),'Len4', Len4 )
      If (IndP.lt.Len4.or.IndP.gt.Size(TensorIn,4)) Call MQC_Error_I('Index P out of bounds &
           & in MQC_R4Tensor_R4Tensor_At',6,'IndP',IndP,'Len4',Len4,'Size(TensorIn,4)', &
           Size(TensorIn,4))

      If (MQC_R4Tensor_HaveFull(TensorIn)) then
        If (MQC_R4Tensor_HaveInteger(TensorIn)) then
          Call MQC_Allocate_R4Tensor(Len1,Len2,Len3,Len4,TensorOut,'Integer','StorFull')
          TensorOut%ITen = TensorIn%ITen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP)
        Elseif (MQC_R4Tensor_HaveReal(TensorIn)) then
          Call MQC_Allocate_R4Tensor(Len1,Len2,Len3,Len4,TensorOut,'Real','StorFull')
          TensorOut%RTen = TensorIn%RTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP)
        Elseif (MQC_R4Tensor_HaveComplex(TensorIn)) then
          Call MQC_Allocate_R4Tensor(Len1,Len2,Len3,Len4,TensorOut,'Complex','StorFull')
          TensorOut%CTen = TensorIn%CTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP)
        Else
          Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_At', 6, &
               'TensorIn%Data_Type', TensorIn%Data_Type )
        EndIf
      ElseIf (MQC_R4Tensor_HaveSymmetric(TensorIn)) then
        If (MQC_R4Tensor_HaveInteger(TensorIn)) then
          Call MQC_Allocate_R4Tensor(Len1,Len2,Len3,Len4,TensorOut,'Integer','StorFull')
        ElseIf (MQC_R4Tensor_HaveReal(TensorIn)) then
          Call MQC_Allocate_R4Tensor(Len1,Len2,Len3,Len4,TensorOut,'Real','StorFull')
        ElseIf (MQC_R4Tensor_HaveComplex(TensorIn)) then
          Call MQC_Allocate_R4Tensor(Len1,Len2,Len3,Len4,TensorOut,'Complex','StorFull')
        EndIf
        Q = 1
        Do Cnt1 = IndI, IndJ
          R = 1
          Do Cnt2 = IndK, IndL
            S = 1
            Do Cnt3 = IndM, IndN
              T = 1
              Do Cnt4 = IndO, IndP
                call TensorOut%Put(TensorIn%at(Cnt1,Cnt2,Cnt3,Cnt4),Q,R,S,T)
                T = T + 1
              EndDo
              S = S + 1
            EndDo
            R = R + 1
          EndDo
          Q = Q + 1
        EndDo
        If(MQC_R4Tensor_Test_Symmetric(TensorOut)) Call MQC_R4Tensor_Full2Symm(TensorOut)
      Else
        Call MQC_Error_A('R4Tensor type not recognised in MQC_R4Tensor_R4Tensor_At', 6, &
             'TensorIn%Storage', TensorIn%Storage )
      EndIf

      End Function MQC_R4Tensor_R4Tensor_At
!
!
!     PROCEDURE MQC_R4Tensor_R4Tensor_Put
!
!>    \brief <b> MQC_R4Tensor_R4Tensor_Put is a function that writes a subarray of the rank-4 tensor</b>
!
!>    \par Purpose:
!     =============
!>    
!>    \verbatim
!>
!>    MQC_R4Tensor_R4Tensor_Put is a subroutine that writes a subarray to the specified
!>    position of a MQC rank-4 tensor. The dimension specifications are given as a vector 
!>    where each vector must contain either zero or two non-zero integers to specify 
!>    the range of elements that will be overwritten by the subarray. If the value 
!>    of an element specification is negative, it counts from the last element back. 
!>    If the value of an element specification is zero, the whole dimension is 
!>    specified.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!     
!>    \param[in] Ten
!>    \verbatim
!>        Ten is Class(MQC_R4Tensor)
!>        Name of the input rank-4 tensor variable to update with 
!>        subarray.
!>    \endverbatim
!>    
!>    \param[in] TensorIn
!>    \verbatim
!>        TensorIn is Type(MQC_R4Tensor)
!>        The subarray to overwrite at the specified elements of
!>        Ten.
!>    \endverbatim
!>
!>    \param[in] D1 
!>    \verbatim
!>        D1 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: coordinates to write subarray of dimension 1 A to B
!>          If (A,B)>0 dimension 1 count is from first index
!>          If (A,B)<0 dimension 1 count is from last index
!>        If = [0]: subarray of dimension 1 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D2
!>    \verbatim
!>        D2 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: coordinates to write subarray of dimension 2 A to B
!>          If (A,B)>0 dimension 2 count is from first index
!>          If (A,B)<0 dimension 2 count is from last index
!>        If = [0]: subarray of dimension 2 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D3
!>    \verbatim
!>        D3 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: coordinates to write subarray of dimension 3 A to B
!>          If (A,B)>0 dimension 3 count is from first index
!>          If (A,B)<0 dimension 3 count is from last index
!>        If = [0]: subarray of dimension 3 equivalent to [1,-1].
!>    \endverbatim
!>
!>    \param[in] D4
!>    \verbatim
!>        D4 is Integer(kind=int64),Dimension(:)
!>        If = [A,B]: coordinates to write subarray of dimension 4 A to B
!>          If (A,B)>0 dimension 4 count is from first index
!>          If (A,B)<0 dimension 4 count is from last index
!>        If = [0]: subarray of dimension 4 equivalent to [1,-1].
!>    \endverbatim
!
!     Authors:
!     ========
!
!>    \author L. M. Thompson
!>    \date 2019
!
      Recursive Subroutine MQC_R4Tensor_R4Tensor_Put(Ten,TensorIn,D1,D2,D3,D4) 
!
      Implicit None
      Class(MQC_R4Tensor),Intent(InOut)::Ten
      Type(MQC_R4Tensor),Intent(In)::TensorIn
      Integer(kind=int64),Dimension(:),Intent(In)::D1,D2,D3,D4
      Integer(kind=int64)::Len1,Len2,Len3,Len4,IndI,IndJ,IndK,IndL,IndM,IndN,IndO,IndP
      Integer(kind=int64)::I,J,K,L,M,N,O,P

      If(Size(D1).eq.1.and.D1(1).eq.0) then
        I = 1
        J = Size(TensorIn,1)
      elseIf(Size(D1).eq.2.and.D1(1).ne.0.and.D1(2).ne.(0)) then
        I = D1(1)
        J = D1(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D1)', Size(D1))
      endIf
      If(Size(D2).eq.1.and.D2(1).eq.0) then
        K = 1
        L = Size(TensorIn,2)
      elseIf(Size(D2).eq.2.and.D2(1).ne.0.and.D2(2).ne.(0)) then
        K = D2(1)
        L = D2(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D2)', Size(D2))
      endIf
      If(Size(D3).eq.1.and.D3(1).eq.0) then
        M = 1
        N = Size(TensorIn,3)
      elseIf(Size(D3).eq.2.and.D3(1).ne.0.and.D3(2).ne.(0)) then
        M = D3(1)
        N = D3(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D3)', Size(D3))
      endIf
      If(Size(D4).eq.1.and.D4(1).eq.0) then
        O = 1
        P = Size(TensorIn,4)
      elseIf(Size(D4).eq.2.and.D4(1).ne.0.and.D4(2).ne.(0)) then
        O = D4(1)
        P = D4(2)
      else
        Call MQC_Error_I('Vector bounds badly specified in mqc_r4tensor_r4tensor_at', 6, &
          'Size(D4)', Size(D4))
      endIf

      IndI = I
      IndJ = J
      If (IndI.lt.0) IndI = Size(Ten,1) + IndI + 1
      If (IndJ.lt.0) IndJ = Size(Ten,1) + IndJ + 1
      Len1 = IndJ-IndI+1
      If (Len1.le.0.or.Len1.ne.Size(TensorIn,1).or.Len1.gt.Size(Ten,1)) &
        Call MQC_Error_I('Dimension 1 length badly defined in MQC_R4Tensor_R4Tensor_Put', &
        6,'Len1',Len1,'Size(TensorIn,1)',Size(TensorIn,1),'Size(Ten,1)',Size(Ten,1))
      If (IndI.le.0.or.IndI.gt.(Size(Ten,1)-Len1+1)) Call MQC_Error_I('Index I out of &
        & bounds in MQC_R4Tensor_R4Tensor_Put',6,'IndI',IndI,'Size(Ten,1)', Size(Ten,1), &
        'Len1', Len1 )
      If (IndJ.gt.Size(Ten,1)) Call MQC_Error_I('Index J out of bounds in  &
        & MQC_R4Tensor_R4Tensor_Put',6,'IndJ',IndJ,'Len1',Len1,'Size(Ten,1)', Size(Ten,1))
      IndK = K
      IndL = L
      If (IndK.lt.0) IndK = Size(Ten,2) + IndK + 1
      If (IndL.lt.0) IndL = Size(Ten,2) + IndL + 1
      Len2 = IndL-IndK+1
      If (Len2.le.0.or.Len2.ne.Size(TensorIn,2).or.Len2.gt.Size(Ten,2)) &
        Call MQC_Error_I('Dimension 2 length badly defined in MQC_R4Tensor_R4Tensor_Put', &
        6,'Len2',Len2,'Size(TensorIn,2)', Size(TensorIn,2) )
      If (IndK.le.0.or.IndK.gt.(Size(Ten,2)-Len2+1)) Call MQC_Error_I('Index K out of &
        & bounds in MQC_R4Tensor_R4Tensor_Put',6,'IndK',IndK,'Size(Ten,2)', &
        Size(Ten,2),'Len2', Len2 )
      If (IndL.gt.Size(Ten,2)) Call MQC_Error_I('Index L out of bounds in &
        & MQC_R4Tensor_R4Tensor_Put',6,'IndL',IndL,'Len2',Len2,'Size(Ten,2)',Size(TensorIn,2))
      IndM = M
      IndN = N
      If (IndM.lt.0) IndM = Size(Ten,3) + IndM + 1
      If (IndN.lt.0) IndN = Size(Ten,3) + IndN + 1
      Len3 = IndN-IndM+1
      If (Len3.le.0.or.Len3.ne.Size(TensorIn,3).or.Len3.gt.Size(Ten,3)) &
        Call MQC_Error_I('Dimension 3 length badly defined in MQC_R4Tensor_R4Tensor_Put', &
        6,'Len3',Len3,'Size(TensorIn,3)',Size(TensorIn,3) )
      If (IndM.le.0.or.IndM.gt.(Size(Ten,3)-Len3+1)) Call MQC_Error_I('Index M out of &
        & bounds in MQC_R4Tensor_R4Tensor_Put',6,'IndM',IndM,'Size(Ten,3)', Size(Ten,3), &
        'Len3', Len3 )
      If (IndN.gt.Size(Ten,3)) Call MQC_Error_I('Index N out of bounds in &
        & MQC_R4Tensor_R4Tensor_Put',6,'IndN',IndN,'Len3',Len3,'Size(Ten,3)', Size(Ten,3))
      IndO = O
      IndP = P
      If (IndO.lt.0) IndO = Size(Ten,4) + IndO + 1
      If (IndP.lt.0) IndP = Size(Ten,4) + IndP + 1
      Len4 = IndP-IndO+1
      If (Len4.le.0.or.Len4.ne.Size(TensorIn,4).or.Len4.gt.Size(Ten,4)) &
        Call MQC_Error_I('Dimension 4 length badly defined in MQC_R4Tensor_R4Tensor_Put',6, &
        'Len4',Len4,'Size(TensorIn,4)',Size(TensorIn,4) )
      If (IndO.le.0.or.IndO.gt.(Size(Ten,4)-Len4+1)) Call MQC_Error_I('Index O out of &
        & bounds in MQC_R4Tensor_R4Tensor_Put',6,'IndO',IndO,'Size(Ten,4)', Size(Ten,4), &
        'Len4', Len4 )
      If (IndP.gt.Size(Ten,4)) Call MQC_Error_I('Index P out of bounds in &
        & MQC_R4Tensor_R4Tensor_Put',6,'IndP',IndP,'Len4',Len4,'Size(Ten,4)', Size(Ten,4))

      If (MQC_R4Tensor_HaveFull(Ten)) then
        If (MQC_R4Tensor_HaveInteger(Ten)) then
          If (MQC_R4Tensor_HaveFull(TensorIn)) then
            If (MQC_R4Tensor_HaveInteger(TensorIn)) then
              Ten%ITen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%ITen
            ElseIf (MQC_R4Tensor_HaveReal(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Real(Ten)  
              Ten%RTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%RTen
            ElseIf (MQC_R4Tensor_HaveComplex(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Complex(Ten)  
              Ten%CTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%CTen
            Else
              Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
               'TensorIn%Data_Type', TensorIn%Data_Type )
            EndIf
          ElseIf (MQC_R4Tensor_HaveSymmetric(TensorIn)) then
            If (MQC_R4Tensor_HaveInteger(TensorIn)) then
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%ITen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%ITen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%ITen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%ITen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%ITen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%ITen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%ITen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%ITen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%ITen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            ElseIf (MQC_R4Tensor_HaveReal(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Real(Ten)  
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%RTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%RTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            ElseIf (MQC_R4Tensor_HaveComplex(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Complex(Ten)  
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%CTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%CTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            Else
              Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
               'TensorIn%Data_Type', TensorIn%Data_Type )
            EndIf
          Else
            Call MQC_Error_A('R4Tensor storage not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
             'TensorIn%Storage', TensorIn%Storage )
          EndIf
        ElseIf (MQC_R4Tensor_HaveReal(Ten)) then
          If (MQC_R4Tensor_HaveFull(TensorIn)) then
            If (MQC_R4Tensor_HaveInteger(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Real(TensorIn)  
              Ten%RTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%RTen
            ElseIf (MQC_R4Tensor_HaveReal(TensorIn)) then
              Ten%RTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%RTen
            ElseIf (MQC_R4Tensor_HaveComplex(TensorIn)) then
              Call MQC_R4Tensor_Copy_Real2Complex(Ten)  
              Ten%CTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%CTen
            Else
              Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
               'TensorIn%Data_Type', TensorIn%Data_Type )
            EndIf
          ElseIf (MQC_R4Tensor_HaveSymmetric(TensorIn)) then
            If (MQC_R4Tensor_HaveInteger(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Real(TensorIn)  
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%RTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%RTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            ElseIf (MQC_R4Tensor_HaveReal(TensorIn)) then
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%RTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%RTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%RTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%RTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            ElseIf (MQC_R4Tensor_HaveComplex(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Complex(Ten)  
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%CTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%CTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            Else
              Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
               'TensorIn%Data_Type', TensorIn%Data_Type )
            EndIf
          Else
            Call MQC_Error_A('R4Tensor storage not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
             'TensorIn%Storage', TensorIn%Storage )
          EndIf
        ElseIf (MQC_R4Tensor_HaveComplex(Ten)) then
          If (MQC_R4Tensor_HaveFull(TensorIn)) then
            If (MQC_R4Tensor_HaveInteger(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Complex(TensorIn)  
              Ten%CTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%CTen
            ElseIf (MQC_R4Tensor_HaveReal(TensorIn)) then
              Call MQC_R4Tensor_Copy_Real2Complex(TensorIn)  
              Ten%CTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%CTen
            ElseIf (MQC_R4Tensor_HaveComplex(TensorIn)) then
              Ten%CTen(IndI:IndJ,IndK:IndL,IndM:IndN,IndO:IndP) = TensorIn%CTen
            Else
              Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
               'TensorIn%Data_Type', TensorIn%Data_Type )
            EndIf
          ElseIf (MQC_R4Tensor_HaveSymmetric(TensorIn)) then
            If (MQC_R4Tensor_HaveInteger(TensorIn)) then
              Call MQC_R4Tensor_Copy_Int2Complex(TensorIn)  
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%CTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%CTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            ElseIf (MQC_R4Tensor_HaveReal(TensorIn)) then
              Call MQC_R4Tensor_Copy_Real2Complex(TensorIn)  
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%CTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%CTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            ElseIf (MQC_R4Tensor_HaveComplex(TensorIn)) then
              Do I = 1, Len1
                Do J = 1, I
                  Do K = 1, Len3
                    Do L = 1, K
                      If(I*(I-1)/2+J.lt.K*(K-1)/2+L) Cycle
                      Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) = TensorIn%CTen(symIndexHash(I,J,K,L),1,1,1)
                      Ten%CTen(Indk+J-1,IndI+I-1,IndM+K-1,IndO+L-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndI+I-1,Indk+J-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(Indk+J-1,IndI+I-1,IndO+L-1,IndM+K-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,IndI+I-1,Indk+J-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndM+K-1,IndO+L-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                      Ten%CTen(IndO+L-1,IndM+K-1,Indk+J-1,IndI+I-1) = Ten%CTen(IndI+I-1,Indk+J-1,IndM+K-1,IndO+L-1) 
                    EndDo
                  EndDo
                EndDo
              EndDo
            Else
              Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
               'TensorIn%Data_Type', TensorIn%Data_Type )
            EndIf
          Else
            Call MQC_Error_A('R4Tensor storage not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
             'TensorIn%Storage', TensorIn%Storage )
          EndIf
        Else
          Call MQC_Error_A('R4Tensor type not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
           'Ten%Data_Type', Ten%Data_Type )
        EndIf
      ElseIf (MQC_R4Tensor_HaveSymmetric(Ten)) then
        Call MQC_R4Tensor_Symm2Full(Ten)
        Call MQC_R4Tensor_R4Tensor_Put(Ten,TensorIn,[IndI,IndJ],[IndK,IndL],[IndM,IndN],[IndO,IndP])
        If(MQC_R4Tensor_Test_Symmetric(Ten)) Call MQC_R4Tensor_Full2Symm(Ten)
      Else
        Call MQC_Error_A('R4Tensor storage not defined in MQC_R4Tensor_R4Tensor_Put', 6, &
         'Ten%Storage', Ten%Storage )
      EndIf

      End Subroutine MQC_R4Tensor_R4Tensor_Put
!
!
!     PROCEDURE MQC_R4Tensor_Test_Symmetric
!
!>    \brief <b> MQC_R4Tensor_Test_Symmetric is a function that tests a MQC tensor for
!>    symmetry</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Test_Symmetric is a function that tests a MQC tensor for symmetry. 
!>    Note that this function differs from haveSymmetric subroutine which tests how a 
!>    matrix is packed.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4Tensor
!>    \verbatim
!>        R4Tensor is Class(mqc_r4tensor)
!>        The rank-4 tensor to be tested for symmetry.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2019
!
      Function MQC_R4Tensor_Test_Symmetric(R4Tensor) Result(Symmetric)
!
      Implicit None
      Class(MQC_R4Tensor),Intent(In)::R4Tensor
      Logical::Symmetric
      Integer(kind=int64)::I,J,K,L
      Real(kind=real64)::Thresh=1e-10

      Symmetric = .True.
        If(Size(R4Tensor,1).ne.Size(R4Tensor,2)) then
          Symmetric = .False.
          Return
        ElseIf(Size(R4Tensor,3).ne.Size(R4Tensor,4)) then
          Symmetric = .False.
          Return
        ElseIf(Size(R4Tensor,1).ne.Size(R4Tensor,3)) then
          Symmetric = .False.
          Return
        Else
          If(MQC_R4Tensor_HaveSymmetric(R4Tensor)) then
            Return
          ElseIf(MQC_R4Tensor_HaveFull(R4Tensor)) then
            Do I = 1, Size(R4Tensor,1)
              Do J = 1, I-1
                Do K = 1, Size(R4Tensor,3)
                  Do L = 1, K-1
                    If(MQC_R4Tensor_HaveInteger(R4Tensor)) then
                      If((R4Tensor%at(I,J,K,L)-R4Tensor%at(I,J,L,K)).ne.0.or. &
                        (R4Tensor%at(I,J,K,L)-R4Tensor%at(J,I,K,L)).ne.0.or. &
                        (R4Tensor%at(I,J,K,L)-R4Tensor%at(J,I,L,K)).ne.0.or. &
                        (R4Tensor%at(I,J,K,L)-R4Tensor%at(K,L,I,J)).ne.0.or. &
                        (R4Tensor%at(I,J,K,L)-R4Tensor%at(K,L,J,I)).ne.0.or. &
                        (R4Tensor%at(I,J,K,L)-R4Tensor%at(L,K,I,J)).ne.0.or. &
                        (R4Tensor%at(I,J,K,L)-R4Tensor%at(L,K,J,I)).ne.0) then
                        Symmetric = .False.
                        Return
                      EndIf
                    elseIf(MQC_R4Tensor_HaveReal(R4Tensor)) then
                      If(abs(R4Tensor%at(I,J,K,L)-R4Tensor%at(I,J,L,K)).gt.Thresh.or. &
                        abs(R4Tensor%at(I,J,K,L)-R4Tensor%at(J,I,K,L)).gt.Thresh.or. &
                        abs(R4Tensor%at(I,J,K,L)-R4Tensor%at(J,I,L,K)).gt.Thresh.or. &
                        abs(R4Tensor%at(I,J,K,L)-R4Tensor%at(K,L,I,J)).gt.Thresh.or. &
                        abs(R4Tensor%at(I,J,K,L)-R4Tensor%at(K,L,J,I)).gt.Thresh.or. &
                        abs(R4Tensor%at(I,J,K,L)-R4Tensor%at(L,K,I,J)).gt.Thresh.or. &
                        abs(R4Tensor%at(I,J,K,L)-R4Tensor%at(L,K,J,I)).gt.Thresh) then
                        Symmetric = .False.
                        Return
                      EndIf
                    elseIf(MQC_R4Tensor_HaveComplex(R4Tensor)) then
                      If(abs(Real(R4Tensor%at(I,J,K,L))-Real(R4Tensor%at(I,J,L,K))).gt.Thresh.or.&
                        abs(Real(R4Tensor%at(I,J,K,L))-Real(R4Tensor%at(J,I,K,L))).gt.Thresh.or.&
                        abs(Real(R4Tensor%at(I,J,K,L))-Real(R4Tensor%at(J,I,L,K))).gt.Thresh.or.&
                        abs(Real(R4Tensor%at(I,J,K,L))-Real(R4Tensor%at(K,L,I,J))).gt.Thresh.or.&
                        abs(Real(R4Tensor%at(I,J,K,L))-Real(R4Tensor%at(K,L,J,I))).gt.Thresh.or.&
                        abs(Real(R4Tensor%at(I,J,K,L))-Real(R4Tensor%at(L,K,I,J))).gt.Thresh.or.&
                        abs(Real(R4Tensor%at(I,J,K,L))-Real(R4Tensor%at(L,K,J,I))).gt.Thresh.or.&
                        abs(Aimag(R4Tensor%at(I,J,K,L))-Aimag(R4Tensor%at(I,J,L,K))).gt.Thresh.or.&
                        abs(Aimag(R4Tensor%at(I,J,K,L))-Aimag(R4Tensor%at(J,I,K,L))).gt.Thresh.or.&
                        abs(Aimag(R4Tensor%at(I,J,K,L))-Aimag(R4Tensor%at(J,I,L,K))).gt.Thresh.or.&
                        abs(Aimag(R4Tensor%at(I,J,K,L))-Aimag(R4Tensor%at(K,L,I,J))).gt.Thresh.or.&
                        abs(Aimag(R4Tensor%at(I,J,K,L))-Aimag(R4Tensor%at(K,L,J,I))).gt.Thresh.or.&
                        abs(Aimag(R4Tensor%at(I,J,K,L))-Aimag(R4Tensor%at(L,K,I,J))).gt.Thresh.or.&
                        abs(Aimag(R4Tensor%at(I,J,K,L))-Aimag(R4Tensor%at(L,K,J,I))).gt.Thresh) then
                        Symmetric = .False.
                        Return
                      EndIf
                    EndIf
                  EndDo
                EndDo
              EndDo
            EndDo
          Else
            Call MQC_Error_A('R4Tensor type not identified in MQC_R4Tensor_Test_Symmetric', 6, &
                 'R4Tensor%Storage', R4Tensor%Storage )
          EndIf
        EndIf

      Return
      End Function MQC_R4Tensor_Test_Symmetric
!
!
!     PROCEDURE MQC_R4TensorScalarDivide
!
!>    \brief <b> MQC_R4TensorScalarDivide is a function that returns a MQC R4 Tensor
!>    divided by a scalar</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4TensorScalarDivide is a function that returns a MQC R4 tensor divided by a 
!>    scalar.  
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC_R4Tensor to divide.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The scalar to divide by.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_R4TensorScalarDivide(tensor,scalarIn) Result(tensor_res)
!
      implicit none
      type(mqc_r4tensor),intent(in)::tensor
      class(*),intent(in)::scalarIn
      type(mqc_scalar)::scalar
      type(mqc_r4tensor)::tensor_res
      type(mqc_scalar)::zero,neg_one,reciprocal

      select type (scalarIn)
      type is (integer)
        scalar = scalarIn
      type is (real)
        scalar = scalarIn
      type is (complex)
        scalar = scalarIn
      type is (mqc_scalar)
        scalar = scalarIn
      class default
        call mqc_error('ScalarIn data type not recognized in MQC_R4TensorScalarDivide')
      end select

      zero = 0.0
      neg_one = -1.0

      if(scalar%abs() .le. zero) then 
        call mqc_error_a('Cannot divide by zero:', 6)
      else
        reciprocal = scalar
        reciprocal = reciprocal ** neg_one
      endif

      tensor_res = MQC_R4TensorScalarProduct(tensor,reciprocal)

      End Function MQC_R4TensorScalarDivide
!
!
!     PROCEDURE MQC_ScalarR4TensorProduct
!
!>    \brief <b> MQC_ScalarR4TensorProduct is a function that computes the product of
!>    a MQC R4 tensor and a scalar</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_ScalarR4TensorProduct is a function that computes the product of a MQC R4 
!>    tensor and a scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC scalar to multiply.
!>    \endverbatim
!>
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC matrix to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_ScalarR4TensorProduct(ScalarIn,Tensor) Result(Tensor_Res)
!
      Implicit None
      class(*),intent(in)::scalarIn
      Type(MQC_R4Tensor),Intent(In)::tensor
      Type(MQC_Scalar)::Scalar
      Type(MQC_R4Tensor)::Tensor_Res

      select type (scalarIn)
      type is (integer)
        scalar = scalarIn
      type is (real)
        scalar = scalarIn
      type is (complex)
        scalar = scalarIn
      type is (mqc_scalar)
        scalar = scalarIn
      class default
        call mqc_error('ScalarIn data type not recognized in MQC_R4TensorScalarProduct')
      end select

      Call MQC_Deallocate_R4Tensor(Tensor_Res)
      If (Tensor%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
          'Integer',Tensor%Storage)
        Tensor_Res%ITen = Scalar%ScaI * Tensor%ITen
      ElseIf (Tensor%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Real',Tensor%Storage)
        Tensor_Res%RTen = Scalar%ScaR * Tensor%ITen
      ElseIf (Tensor%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Real',Tensor%Storage)
        Tensor_Res%RTen = Scalar%ScaI * Tensor%RTen
      Else If (Tensor%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Real',Tensor%Storage)
        Tensor_Res%RTen = Scalar%ScaR * Tensor%RTen
      ElseIf (Tensor%Data_Type.eq.'Integer' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Complex',Tensor%Storage)
        Tensor_Res%CTen = Scalar%ScaC * Tensor%ITen
      Else If (Tensor%Data_Type.eq.'Real' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Complex',Tensor%Storage)
        Tensor_Res%CTen = Scalar%ScaC * Tensor%RTen
      ElseIf (Tensor%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Integer') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Complex',Tensor%Storage)
        Tensor_Res%CTen = Scalar%ScaI * Tensor%CTen
      Else If (Tensor%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Real') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Complex',Tensor%Storage)
        Tensor_Res%CTen = Scalar%ScaR * Tensor%CTen
      Else If (Tensor%Data_Type.eq.'Complex' .and. Scalar%Data_Type.eq.'Complex') then
        Call MQC_Allocate_R4Tensor(Tensor%I,Tensor%J,Tensor%K,Tensor%L,Tensor_Res, &
        'Complex',Tensor%Storage)
        Tensor_Res%CTen = Scalar%ScaC * Tensor%CTen
      Else
        Call MQC_Error_A('unrecognised data type in mqc_scalarr4tensorproduct', 6, &
             'Tensor%Data_Type', Tensor%Data_Type, &
             'Scalar%Data_Type', Scalar%Data_Type )
      EndIf

      End Function MQC_ScalarR4TensorProduct
!
!
!     PROCEDURE MQC_R4TensorScalarProduct
!
!>    \brief <b> MQC_R4TensorScalarProduct is a function that computes the product of
!>    a MQC R4 tensor and a scalar</b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4TensorScalarProduct is a function that computes the product of a MQC R4 
!>    tensor and a scalar.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] Tensor
!>    \verbatim
!>        Tensor is Type(MQC_R4Tensor)
!>        The MQC matrix to multiply.
!>    \endverbatim
!>
!>    \param[in] ScalarIn
!>    \verbatim
!>        ScalarIn is Type(MQC_Scalar)
!>        The MQC scalar to multiply.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_R4TensorScalarProduct(Tensor,ScalarIn) Result(Tensor_Res)
!
      Implicit None
      class(*),intent(in)::scalarIn
      Type(MQC_R4Tensor),Intent(In)::tensor
      Type(MQC_Scalar)::Scalar
      Type(MQC_R4Tensor)::Tensor_Res

      select type (scalarIn)
      type is (integer)
        scalar = scalarIn
      type is (real)
        scalar = scalarIn
      type is (complex)
        scalar = scalarIn
      type is (mqc_scalar)
        scalar = scalarIn
      class default
        call mqc_error('ScalarIn data type not recognized in MQC_R4TensorScalarProduct')
      end select

      Tensor_Res = MQC_ScalarR4TensorProduct(Scalar,Tensor)

      End Function MQC_R4TensorScalarProduct
!
!
!     PROCEDURE MQC_R4Tensor_Complex_Conjugate
!
!>    \brief <b> MQC_R4Tensor_Complex_Conjugate is a function that returns the complex conjugate 
!>    of an MQC_R4Tensor</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Complex_Conjugate is a function that returns the complex conjugate of an 
!>    MQC_Matrix. 
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] R4TensorIn
!>    \verbatim
!>        R4TensorIn is Type(MQC_R4Tensor)
!>        The MQC_R4Tensor input variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2020
!
      Function MQC_R4Tensor_Complex_Conjugate(R4TensorIn) Result(R4TensorOut)
!
!     Variable Declarations.
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::R4TensorIn
      Type(MQC_R4Tensor)::R4TensorOut
!
      R4TensorOut = R4TensorIn
      If(R4TensorIn%Data_Type.eq.'Complex') then
        R4TensorOut%CTen = conjg(R4TensorIn%CTen)
      EndIf
!
      Return
      End Function MQC_R4Tensor_Complex_Conjugate
!
!
!     PROCEDURE MQC_R4Tensor_Complex_RealPart
!
!>    \brief <b> MQC_R4Tensor_Complex_RealPart is a function that returns a MQC R4Tensor
!>    with elements containing the real part of elements of another MQC R4Tensor</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_R4Tensor_Complex_RealPart is a function that returns a MQC R4Tensor with 
!>    elements containing the real part of elements of another MQC R4Tensor.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_R4Tensor)
!>        The name of the MQC_R4Tensor variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2022
!
      function mqc_R4Tensor_complex_realPart(A) result(output)
!
      Implicit None
      class(mqc_R4Tensor),intent(in)::A
      type(mqc_R4Tensor)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      output = A
      if(A%Data_Type.eq.'Complex') then
        call MQC_R4Tensor_Copy_Complex2Real(output)
      endIf
!
      end function mqc_R4Tensor_complex_realPart
!
!
!     PROCEDURE MQC_R4Tensor_Complex_ImagPart
!
!>    \brief <b> MQC_R4Tensor_Complex_ImagPart is a function that returns a MQC R4Tensor
!>    with elements containing the imaginary part of elements of another MQC R4Tensor</b>
!
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>
!>    MQC_R4Tensor_Complex_ImagPart is a function that returns a MQC R4Tensor with 
!>    elements containing the imaginary part of elements of another MQC R4Tensor.
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] A
!>    \verbatim
!>        A is Class(MQC_R4Tensor)
!>        The name of the MQC_R4Tensor variable.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author L. M. Thompson
!>    \date 2022
!
      function mqc_R4Tensor_complex_imagPart(A) result(output)
!
      Implicit None
      class(mqc_R4Tensor),intent(in)::A
      type(mqc_R4Tensor)::output
      integer(kind=int64)::i
!
!     Do the work.
!
      output = A
      select case (A%Data_Type)
      case('Integer')
        output%ITen = 0
      case('Real')
        output%RTen = 0.0
      case('Complex')
        call MQC_R4Tensor_Copy_Complex2Real(output)
        output%RTen = aimag(A%CTen)
      case default
        call mqc_error_a('Unrecognized MQC_R4Tensor data type in mqc_matrix_complex_realPart',&
          6,'A%Data_Type',A%Data_Type)
      end select
!
      end function mqc_R4Tensor_complex_imagPart
!
!

!
!
!     PROCEDURE MQC_R4Tensor_Matrix_Contraction
!
!>    \brief <b> MQC_R4Tensor_Matrix_Contraction 
!>    </b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_Matrix_Contraction
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RA
!>    \verbatim
!>        RA is Type(MQC_R4Tensor)
!>    \endverbatim
!>
!>    \param[in] MB
!>    \verbatim
!>        MB is Type(MQC_Matrix)
!>        The MQC matrix multiply.
!>    \endverbatim
!>
!>    \param[in] inorder
!>    \verbatim
!>        inorder is Integer(kind=int64),dimension(2),optional
!>        Contain the indexes to be contracted.
!>        Ex: if inorder=[3,2], the thrid and second indexes of RA is contacted
!>            with the first and second of MB, respectivelly.
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2024
!
      Function MQC_R4Tensor_Matrix_Contraction(RA,MB,inorder) Result(MC)
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::RA
      Type(MQC_Matrix),Intent(In)::MB
      Integer(kind=int64),dimension(2),Intent(In),optional::inorder
      Type(MQC_R4Tensor)::RAreal
      Type(MQC_Matrix)::MC,MCreal,MBreal
      Type(MQC_Matrix)::tmpM,tmpR
      Integer(kind=int64)::ia,ib,ic,id,i,j,k
      Integer(kind=int64)::dima,dimb,dimc,dimd
      Integer(kind=int64),dimension(2)::va,vb

      if(present(inorder)) then
        ia=inorder(1)
        ib=inorder(2)
        ic=0
        id=0
        if (ia.eq.ib) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_Matrix_Contraction', 6, &
             'ia', ia,'ib',ib)
        if (ia.gt.4.or.ia.le.0.or.ib.gt.4.or.ib.le.0) Call MQC_Error_I(&
             'Index out of range in MQC_R4Tensor_Matrix_Contraction', 6, &
             'ia', ia,'ib',ib)
        do i=1,4
          if (i.ne.ia.and.i.ne.ib) then
            if(ic.eq.0) then
              ic=i
            else
              id=i
            endif
          endif
        end do
      else
        ia=1
        ib=2
        ic=3
        id=4
      endif
      dima = MQC_R4Tensor_Size(RA,ia)
      dimb = MQC_R4Tensor_Size(RA,ib)
      dimc = MQC_R4Tensor_Size(RA,ic)
      dimd = MQC_R4Tensor_Size(RA,id)
      If (MB%NRow.ne.dima.or.MB%NCol.ne.dimb) then
        Call MQC_Error_I('R4Tensor and Matrix are not conformable for contraction', 6, &
             'MB%NRow', MB%NRow,'MQC_R4Tensor_Size(RA%ia)',dima,&
             'MB%NCol', MB%NCol,'MQC_R4Tensor_Size(RA%ib)',dimb)
      EndIf

      If (MQC_R4Tensor_HaveInteger(RA)) RAreal = MQC_Cast_Real(RA)
      If (MQC_Matrix_HaveInteger(MB)) MBreal = MQC_Cast_Real(MB)
      If (MQC_R4Tensor_HaveComplex(RA) .or. MQC_Matrix_HaveComplex(MB)) then
        Call MQC_Allocate_Matrix(dimc,dimd,MC,'Complex','StorFull')
      ElseIf (MQC_R4Tensor_HaveReal(RA) .or. MQC_Matrix_HaveReal(MB)) then
        Call MQC_Allocate_Matrix(dimc,dimd,MC,'Real','StorFull')
       !!TODO:Consider symm
      Else
        Call MQC_Allocate_Matrix(dimc,dimd,MC,'Integer','StorFull')
      EndIf
      
      va=[1,dima]
      vb=[1,dimb]
      do i=1,dimc
        do j=1,dimd
          select case(ia)
          case(1)      
            select case(ib)
            case(2)      
              tmpR = RA%mat(va,vb,[i],[j])
            case(3)      
              tmpR = RA%mat(va,[i],vb,[j])
            case(4)
              tmpR = RA%mat(va,[i],[j],vb)
            end select      
          case(2)      
            select case(ib)
            case(1)      
              tmpR = transpose(RA%mat(vb,va,[i],[j]))
            case(3)      
              tmpR = RA%mat([i],va,vb,[j])
            case(4)
              tmpR = RA%mat([i],va,[j],vb)
            end select      
          case(3)      
            select case(ib)
            case(1)      
              tmpR = transpose(RA%mat(vb,[i],va,[j]))
            case(2)      
              tmpR = transpose(RA%mat([i],vb,va,[j]))
            case(4)
              tmpR = RA%mat([i],[j],va,vb)
            end select      
          case(4)
            select case(ib)
            case(1)      
              tmpR = transpose(RA%mat(vb,[i],[j],va))
            case(2)       
              tmpR = transpose(RA%mat([i],vb,[j],va))
            case(3)       
              tmpR = transpose(RA%mat([i],[j],vb,va))
            end select      
          end select      
          call MC%put(Contraction(tmpR,MB),i,j)
        enddo
      enddo


      EndFunction MQC_R4Tensor_Matrix_Contraction

!
!
!     PROCEDURE MQC_R4Tensor_R4Tensor_Partial_Contraction
!
!>    \brief <b> MQC_R4Tensor_R4Tensor_Partial_Contraction 
!>    </b>
!>
!>    \par Purpose:
!     =============
!>
!>    \verbatim
!>       
!>    MQC_R4Tensor_R4Tensor_Partial_Contraction
!>
!>    \endverbatim
!
!     Arguments:
!     ==========
!>    \param[in] RA
!>    \verbatim
!>        RA is Type(MQC_R4Tensor)
!>        The MQC  R4Tensor to be partially contracted.
!>    \endverbatim
!>
!>    \param[in] RB
!>    \verbatim
!>        RB is Type(MQC_R4Tensor)
!>        The MQC  R4Tensor to be partially contracted.
!>    \endverbatim
!>
!>    \param[in] orderA
!>    \verbatim
!>        inorder is Integer(kind=int64),dimension(4),optional
!>        Contain the indexes of RA to be contracted.
!>        The two first integers in the object are the ones to be contracted,
!>        while the two last are the one to be multiplied.
!>        Ex: If orderA=[3,2,4,1], the thrid and second indexes of RA are contacted.
!>            The fourth and first are multiplied to form the first and second indexes
!>            of the result matrix, respectivelly.
!>    \endverbatim
!>
!>    \param[in] orderB
!>    \verbatim
!>        inorder is Integer(kind=int64),dimension(B),optional
!>        Contain the indexes of RB to be contracted.
!>        The two first integers in the object are the ones to be contracted,
!>        while the two last are the one to be multiplied.
!>
!>        Ex: orderA=[3,2,4,1] and orderB=[2,1,4,3]
!>        sum_{i,j} RA_{ljik} RB_{jilk} = MC_{kl}
!>
!>    \endverbatim
!
!     Authors:
!     ========
!>    \author M. M. F. Moraes
!>    \date 2024
!
      Function MQC_R4Tensor_R4Tensor_Partial_Contraction(RA,RB,orderA,orderB) Result(MC)
!
      Implicit None
      Type(MQC_R4Tensor),Intent(In)::RA,RB
      Integer(kind=int64),dimension(4),Intent(In),optional::orderA,orderB
      Type(MQC_R4Tensor)::RAreal,RBreal
      Type(MQC_Matrix)::MC,MCreal
      Type(MQC_Matrix)::tmpRB,tmpRA
      Integer(kind=int64)::ia,ja,ka,la,ib,jb,kb,lb,i,j,k,l
      Integer(kind=int64)::dimAi,dimAj,dimAk,dimAl,dimBi,dimBj,dimBk,dimBl
      Integer(kind=int64),dimension(2)::vi,vj

      if(present(orderA)) then
        ia=orderA(1)
        ja=orderA(2)
        ka=orderA(3)
        la=orderA(4)
        if (ia.eq.ja) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Contraction',&
                                        6,'ia', ia,'ja',ja)             
        if (ia.eq.ka) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Contraction',&
                                        6,'ia', ia,'ka',ka)             
        if (ia.eq.la) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Contraction',&
                                        6,'ia', ia,'la',la)             
        if (ja.eq.ka) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Contraction',&
                                        6,'ja', ja,'ka',ka)             
        if (ja.eq.la) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Contraction',&
                                        6,'ja', ja,'la',la)             
        if (ka.eq.la) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Contraction',&
                                        6,'ka', ka,'la',la)
      else
        ia=1
        ja=2
        ka=3
        la=4
      endif
      if(present(orderB)) then
        ib=orderB(1)
        jb=orderB(2)
        kb=orderB(3)
        lb=orderB(4)
        if (ib.eq.jb) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Partial_Contraction',&
                                        6,'ib', ib,'jb',jb)
        if (ib.eq.kb) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Partial_Contraction',&
                                        6,'ib', ib,'kb',kb)
        if (ib.eq.lb) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Partial_Contraction',&
                                        6,'ib', ib,'lb',lb)
        if (jb.eq.kb) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Partial_Contraction',&
                                        6,'jb', jb,'kb',kb)
        if (jb.eq.lb) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Partial_Contraction',&
                                        6,'jb', jb,'lb',lb)
        if (kb.eq.lb) Call MQC_Error_I('Duplicated index in MQC_R4Tensor_R4Tensor_Partial_Contraction',&
                                        6,'kb', kb,'lb',lb)
      else
        ib=1
        jb=2
        kb=3
        lb=4
      endif
      if (ia.gt.4.or.ia.le.0.or.ib.gt.4.or.ib.le.0.or.&
          ja.gt.4.or.ja.le.0.or.jb.gt.4.or.jb.le.0.or.&
          ka.gt.4.or.ka.le.0.or.kb.gt.4.or.kb.le.0.or.&
          la.gt.4.or.la.le.0.or.lb.gt.4.or.lb.le.0.) Call MQC_Error(&
           'Index out of range in MQC_R4Tensor_R4Tensor_Partial_Contraction', 6)
      dimAi = MQC_R4Tensor_Size(RA,ia)
      dimAj = MQC_R4Tensor_Size(RA,ja)
      dimAk = MQC_R4Tensor_Size(RA,ka)
      dimAl = MQC_R4Tensor_Size(RA,la)

      dimBi = MQC_R4Tensor_Size(RB,ib)
      dimBj = MQC_R4Tensor_Size(RB,jb)
      dimBk = MQC_R4Tensor_Size(RB,kb)
      dimBl = MQC_R4Tensor_Size(RB,lb)

      If (dimAi.ne.dimBi.or.dimAj.ne.dimBj.or.&
          dimAk.ne.dimBk.or.dimAl.ne.dimBl) Call MQC_Error(&
             'R4Tensor are not conformable for partial contraction', 6)

      If (MQC_R4Tensor_HaveInteger(RA)) RAreal = MQC_Cast_Real(RA)
      If (MQC_R4Tensor_HaveInteger(RB)) RBreal = MQC_Cast_Real(RB)
      If (MQC_R4Tensor_HaveComplex(RA) .or. MQC_R4Tensor_HaveComplex(RB)) then
        Call MQC_Allocate_Matrix(dimAk,dimAl,MC,'Complex','StorFull')
      ElseIf (MQC_R4Tensor_HaveReal(RA) .or. MQC_R4Tensor_HaveReal(RB)) then
        Call MQC_Allocate_Matrix(dimAk,dimAl,MC,'Real','StorFull')
       !!TODO:Consider symm
      Else
        Call MQC_Allocate_Matrix(dimAk,dimAl,MC,'Integer','StorFull')
      EndIf
      
      vi=[1,dimAi]
      vj=[1,dimAj]
!$OMP PARALLEL DO DEFAULT(NONE), &
!$OMP SHARED(RA,RB,vi,vj,ia,ja,la,ka,&
!$OMP       ib,jb,lb,kb,MC,dimAl,dimAk),&
!$OMP PRIVATE(tmpRA,tmpRB,k,l)
      do k=1,dimAl
        do l=1,dimAk
          select case(ia)
          case(1)      
            select case(ja)
            case(2)      
              if(ka.eq.3) tmpRA = RA%mat(vi,vj,[k],[l])
              if(ka.eq.4) tmpRA = RA%mat(vi,vj,[l],[k])
            case(3)      
              if(ka.eq.2) tmpRA = RA%mat(vi,[k],vj,[l])
              if(ka.eq.4) tmpRA = RA%mat(vi,[l],vj,[k])
            case(4)
              if(ka.eq.2) tmpRA = RA%mat(vi,[k],[l],vj)
              if(ka.eq.3) tmpRA = RA%mat(vi,[l],[k],vj)
            end select      
          case(2)      
            select case(ja)
            case(1)      
              if(ka.eq.3) tmpRA = transpose(RA%mat(vj,vi,[k],[l]))
              if(ka.eq.4) tmpRA = transpose(RA%mat(vj,vi,[l],[k]))
            case(3)      
              if(ka.eq.1) tmpRA = RA%mat([k],vi,vj,[l])
              if(ka.eq.4) tmpRA = RA%mat([l],vi,vj,[k])
            case(4)
              if(ka.eq.1) tmpRA = RA%mat([k],vi,[l],vj)
              if(ka.eq.3) tmpRA = RA%mat([l],vi,[k],vj)
            end select      
          case(3)      
            select case(ja)
            case(1)      
              if(ka.eq.2) tmpRA = transpose(RA%mat(vj,[k],vi,[l]))
              if(ka.eq.4) tmpRA = transpose(RA%mat(vj,[l],vi,[k]))
            case(2)      
              if(ka.eq.1) tmpRA = transpose(RA%mat([k],vj,vi,[l]))
              if(ka.eq.4) tmpRA = transpose(RA%mat([l],vj,vi,[k]))
            case(4)
              if(ka.eq.1) tmpRA = RA%mat([k],[l],vi,vj)
              if(ka.eq.2) tmpRA = RA%mat([l],[k],vi,vj)
            end select      
          case(4)
            select case(ib)
            case(1)      
              if(ka.eq.2) tmpRA = transpose(RA%mat(vj,[k],[l],vi))
              if(ka.eq.3) tmpRA = transpose(RA%mat(vj,[l],[k],vi))
            case(2)       
              if(ka.eq.1) tmpRA = transpose(RA%mat([k],vj,[l],vi))
              if(ka.eq.3) tmpRA = transpose(RA%mat([l],vj,[k],vi))
            case(3)       
              if(ka.eq.1) tmpRA = transpose(RA%mat([k],[l],vj,vi))
              if(ka.eq.2) tmpRA = transpose(RA%mat([l],[k],vj,vi))
            end select      
          end select      
         select case(ib)
          case(1)
            select case(jb)
            case(2)
              if(kb.eq.3) tmpRB = RB%mat(vi,vj,[k],[l])
              if(kb.eq.4) tmpRB = RB%mat(vi,vj,[l],[k])
            case(3)
              if(kb.eq.2) tmpRB = RB%mat(vi,[k],vj,[l])
              if(kb.eq.4) tmpRB = RB%mat(vi,[l],vj,[k])
            case(4)
              if(kb.eq.2) tmpRB = RB%mat(vi,[k],[l],vj)
              if(kb.eq.3) tmpRB = RB%mat(vi,[l],[k],vj)
            end select
          case(2)
            select case(ja)
            case(1)
              if(kb.eq.3) tmpRB = transpose(RB%mat(vj,vi,[k],[l]))
              if(kb.eq.4) tmpRB = transpose(RB%mat(vj,vi,[l],[k]))
            case(3)
              if(kb.eq.1) tmpRB = RB%mat([k],vi,vj,[l])
              if(kb.eq.4) tmpRB = RB%mat([l],vi,vj,[k])
            case(4)
              if(kb.eq.1) tmpRB = RB%mat([k],vi,[l],vj)
              if(kb.eq.3) tmpRB = RB%mat([l],vi,[k],vj)
            end select
          case(3)
            select case(ja)
            case(1)
              if(kb.eq.2) tmpRB = transpose(RB%mat(vj,[k],vi,[l]))
              if(kb.eq.4) tmpRB = transpose(RB%mat(vj,[l],vi,[k]))
            case(2)
              if(kb.eq.1) tmpRB = transpose(RB%mat([k],vj,vi,[l]))
              if(kb.eq.4) tmpRB = transpose(RB%mat([l],vj,vi,[k]))
            case(4)
              if(kb.eq.1) tmpRB = RB%mat([k],[l],vi,vj)
              if(kb.eq.2) tmpRB = RB%mat([l],[k],vi,vj)
            end select
          case(4)
            select case(ib)
            case(1)
              if(kb.eq.2) tmpRB = transpose(RB%mat(vj,[k],[l],vi))
              if(kb.eq.3) tmpRB = transpose(RB%mat(vj,[l],[k],vi))
            case(2)
              if(kb.eq.1) tmpRB = transpose(RB%mat([k],vj,[l],vi))
              if(kb.eq.3) tmpRB = transpose(RB%mat([l],vj,[k],vi))
            case(3)
              if(kb.eq.1) tmpRB = transpose(RB%mat([k],[l],vj,vi))
              if(kb.eq.2) tmpRB = transpose(RB%mat([l],[k],vj,vi))
            end select
          end select
          call MC%put(Contraction(tmpRA,tmpRB),k,l)
        enddo
      enddo
!$OMP END PARALLEL DO



      EndFunction MQC_R4Tensor_R4Tensor_Partial_Contraction

      End Module MQC_Algebra
